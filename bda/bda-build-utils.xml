<project name="bda-utils" xmlns:antunit="antlib:org.apache.ant.antunit" xmlns="antlib:org.apache.tools.ant">
	<!--
	$Id$
	$HeadURL$
	-->

 	<!-- Properties -->
	<property name="bda-utils.lib.dir" value="${basedir}/bda-utils"/>
	<property name="bda-utils.resource.dir" value="${basedir}/bda-utils/resource"/>	
 	<property name="antunit.jar" value="antunit-1.0.jar"/>
	<property name="template.dbintegrate.file" value="${bda-utils.resource.dir}/template-db-integrate.xml"/>

	<!-- PATHS -->
	<path id="macrodef.classpath">
		<fileset dir="bda-utils">
			<include name="**/*.jar" />
		</fileset>
	</path>

	<!-- Taskdefs -->
	<typedef resource="net/ggtools/grand/antlib.xml" classpath="${bda-utils.lib.dir}/grand-1.8.jar"/>
	<taskdef name="dbconfig" classname="com.dbconfig.anttask.DbConfig" classpathref="macrodef.classpath" />
	<taskdef name="svn" classpathref="macrodef.classpath" classname="org.tigris.subversion.svnant.SvnTask" />

 	<taskdef resource="net/sf/antcontrib/antcontrib.properties">
 		<classpath>
			<pathelement location="${bda-utils.lib.dir}/ant-contrib-1.0b3.jar"/>
			<pathelement location="${bda-utils.lib.dir}/bcel-5.1.jar"/>
			<pathelement location="${bda-utils.lib.dir}/commons-httpclient-3.0.1.jar"/>
			<pathelement location="${bda-utils.lib.dir}/commons-logging-1.0.4.jar"/>
			<pathelement location="${bda-utils.lib.dir}/ivy-1.3.1.jar"/>
 		</classpath>
 	</taskdef>
 
 	<taskdef uri="antlib:org.apache.ant.antunit" resource="org/apache/ant/antunit/antlib.xml">
 		<classpath>
			<pathelement location="${bda-utils.lib.dir}/${antunit.jar}"/>
 		</classpath>
 	</taskdef>
	
	<taskdef name="elopeif" classname="ise.antelope.tasks.IfTask">
		<classpath>
			<pathelement location="${bda-utils.lib.dir}/antelope_app-3.4.1.jar"/>
		</classpath>
	</taskdef>
	
	<taskdef name="for" classname="net.sf.antcontrib.logic.ForTask">
		<classpath>
			<pathelement location="${bda-utils.lib.dir}/ant-contrib-1.0b3.jar"/>
		</classpath>
	</taskdef>
	
	<taskdef name="ncitask" classname="gov.nih.ncicb.anttasks.PropertyValidator" classpathref="macrodef.classpath" />
	
 	<tstamp>
 		<format property="run.date" pattern="yyMMddHHmm"/>
 	</tstamp>

	<!-- init tasks -->
	<mkdir dir="${basedir}/tmp"/>
	<property name="database.type" value="mysql"/>
	<if>
		<equals arg1="${database.type}" arg2="oracle"/>
		<then>  
			<property name="database.dialect" value="org.hibernate.dialect.OracleDialect"/>
			<property name="is.oracle" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/ojdbc14-10.2.0.3.0.jar "/>
		</then> 
		<elseif>    
			<equals arg1="${database.type}" arg2="mysql"/>
			<then>  
				<property name="database.dialect" value="org.hibernate.dialect.MySQLDialect"/>
				<property name="is.mysql" value="true"/>
				<property name="database.driver.file" value="${bda-utils.dir}/mysql-connector-java-5.0.5.jar"/>
			</then> 
		</elseif> 
		<else>  
			<fail message="Invalid or unsupported database type ${database.type}"/>
		</else> 
	</if>
	
	<!-- run-junit-tests macro runs the unit test cases  
	usage: <run-junit-tests test.src.dir="${test.src.dir}" xml.output.dir="${target.dir}/junit" instrumented.classes="${instrumented.classes.dir}" classpath="${caarray-client.test.classes.dir};${test.data.files.dir};${test.classes.dir};${commons-lang.jar};${commons-io.jar};${caarray-client.test.files.dir};${caarray-client.classes.dir};${caarray-client.resources.dir};${junit.jar};${nci-commons-core.jar}" />
	-->
	<macrodef name="run-junit-tests">
		<attribute name="test.src.dir" />
		<attribute name="xml.output.dir" />
		<attribute name="classpath" default="" />
		<attribute name="instrumented.classes" default="" />

		<sequential>
			<mkdir dir="@{xml.output.dir}" />
			<junit printsummary="on" failureproperty="junit.failure" fork="true" forkmode="once" maxmemory="256m">
				<sysproperty key="net.sourceforge.cobertura.datafile" file="${cobertura.file}" />
				<sysproperty key="server.hostname" value="${jboss.server.hostname}" />
				<sysproperty key="server.port" value="${jboss.server.port}" />
				<sysproperty key="server.jndi.port" value="${jboss.server.jndi.port}" />
				<sysproperty key="selenium.server.port" value="${selenium.server.port}" />

				<classpath>
					<pathelement path="@{instrumented.classes}" />
					<pathelement path="@{classpath}" />
					<path refid="cobertura.classpath" />
				</classpath>
				<formatter type="xml" />
				<batchtest todir="@{xml.output.dir}">
					<fileset dir="@{test.src.dir}">
						<include name="**/*Test.java" />
						<exclude name="**/Abstract*Test.java" />
					</fileset>
				</batchtest>
			</junit>
		</sequential>
	</macrodef>

	<!-- run-sql-script macro executes the sql scripts for a database 
	usage: <run-sql-script database.url="${database.url}" database.user="${database.user}" database.password="${database.password}" sql.file="${sql.dir}/create_table.sql" /> 
	-->
	<macrodef name="run-sql-script" description="By default this will use the database.url, to use drop database &amp; user use the database.system.url property">
		<attribute name="sql.file" />
		<attribute name="sql.delimiter" default=";" />
		<attribute name="sql.delimitertype" default="normal" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="onerror" default="abort" />
		<sequential>
			<sql driver="${database.driver}" url="@{database.url}" userid="@{database.user}" password="@{database.password}" src="@{sql.file}" onerror="@{onerror}" autocommit="true" delimiter="@{sql.delimiter}" delimitertype="@{sql.delimitertype}" keepformat="true">
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
			</sql>
		</sequential>
	</macrodef>

	<!-- remote-ssh macro is a remote SSH procedure. It will use SSH connection defaults as defined in the environment property file to initiate SSH connections and execure remote unix commands. remoteSshCommand is a mandatory attribute to this macrodef.
	usage: <remote-ssh remotesshcommand="mv ${jboss.temp.dir}/caarray.ear ${jboss.home}/deploy/" /> 
	-->
	<macrodef name="remote-ssh" description="This is a remote SSH procedure. It will use SSH connection defaults as defined in the environment property file to initiate SSH connections and execure remote unix commands. remoteSshCommand is a mandatory attribute to this macrodef.">
		<attribute name="remoteSshCommand" />
		<attribute name="remoteSshPort" default="${ssh.port}" />
		<attribute name="remoteSshHost" default="${ssh.server.hostname}" />
		<attribute name="remoteSshUser" default="${ssh.server.username}" />
		<attribute name="remoteSshKeyfile" default="${ssh.key.file}" />
		<attribute name="remoteSshSleep" default="5" />
		<sequential>
			<sshexec port="@{remotesshport}" host="@{remotesshhost}" username="@{remoteSshUser}" keyfile="@{remoteSshKeyfile}" trust="true" passphrase="" verbose="true" command="@{remotesshcommand}" />
			<sleep seconds="@{remoteSshSleep}" />
			<echo message="Performed @{remoteSshCommand} command on @{remoteSshHost}:@{remoteSshPort} using SSH..." />
		</sequential>
	</macrodef>

	<!-- remote-scp macro copies files in a secure manner using SCP. 
	remoteScpToDir and remoteScpFileToCopy are required attributes to this macrodef
	usage: <remote-scp remoteScpFileToCopy="${caarray.ear}" 
	remoteScpToDir="${ssh.server.username}@${ssh.server.hostname}:${jboss.temp.dir}" />
	-->
	<macrodef name="remote-scp" description="This task copies files in a secure manner using SCP. 
	remoteScpToDir and remoteScpFileToCopy are required attributes to this macrodef.">
		<attribute name="remoteScpFileToCopy" />
		<attribute name="remoteScpToDir" />
		<attribute name="remoteScpKeyFile" default="${ssh.key.file}" />
		<attribute name="remoteScpPassphrase" default="" />
		<attribute name="remoteScpTrust" default="true" />
		<attribute name="remoteScpVerbose" default="true" />
		<attribute name="remoteScpSleep" default="5"  />
		<sequential>
			<scp file="@{remoteScpFileToCopy}" keyfile="@{remoteScpKeyFile}" passphrase="@{remoteScpPassphrase}" trust="@{remoteScpTrust}" verbose="@{remoteScpVerbose}" todir="@{remoteScpToDir}" />
			<sleep seconds="@{remoteScpSleep}" />
			<echo message="Copied @{remoteScpFileToCopy} to @{remoteScpToDir} using SCP..." />
		</sequential>
	</macrodef>

	<!-- 
	jboss-stop-jboss macro will stop the jboss instance
	usage: 	<jboss-start-jboss jboss.home="${jboss.home}"/>
		jboss.home is the location where Jboss is installed
		jboss.server.hostname is the host name where the application server is installed
		jboss.server.jndi.port is the JNDI port on which the server listens
	-->
	<macrodef name="jboss-stop-jboss">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<attribute name="jboss.server.jndi.port" default="${jboss.server.jndi.port}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>
			<available file="@{jboss.home}/server/@{jboss.server.name}/bin" property="jboss.bin.exists"/>
			<if>
				<isset property="jboss.bin.exists"/>
				<then>
					<echo message="Shutting down jboss with stop_jboss"/>
					<exec executable="sh" os="Linux" dir="@{jboss.home}/server/@{jboss.server.name}/bin" spawn="true">
						<env key="NOPAUSE" value="true" />
						<arg line="stop_jboss" />
					</exec>
				</then>
				<else>
					<echo message="Shutting down jboss with shutdown.jar"/>

					<java classname="org.jboss.Shutdown" fork="true" spawn="false">
						<arg line="-s @{jboss.server.hostname}:@{jboss.server.jndi.port} -S" />
						<classpath>
							<pathelement location="@{jboss.home}/bin/shutdown.jar" />
						</classpath>
					</java>
				</else>
			</if>
			<sleep seconds="15" />
		</sequential>
	</macrodef>

	<!-- 
	jboss-check-if-jboss-is-running macro checks if the jboss server is up and listening
	usage: 	<jboss-check-if-jboss-is-running jboss.server.port="${jboss.server.port}" jboss.server.hostname="${jboss.server.hostname}" jboss.server.jndi.port="${jboss.server.jndi.port}"/>
		jboss.server.port is the http port number of which the web container listens
		jboss.server.hostname is the host name where the application server is installed		
	-->
	<macrodef name="jboss-check-if-jboss-is-running" description="Checks if a local JBoss instance is running">
		<attribute name="jboss.server.port" default="${jboss.server.port}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<sequential>
			<condition property="jboss.running">
				<socket port="@{jboss.server.port}" server="@{jboss.server.hostname}" />
			</condition>
		</sequential>
	</macrodef>

	<!-- 
	jboss-start-jboss macro will start the jboss instance
	usage: 	<jboss-start-jboss jboss.home="${jboss.home}"/>
		jboss.home is the location where Jboss is installed		
	-->
	<macrodef name="jboss-start-jboss" description="Starts a local JBoss instance">
		<attribute name="jboss.home" default="${jboss.home}" />
		<sequential>
			<available file="@{jboss.home}/server/@{jboss.server.name}/bin" property="jboss.bin.exists"/>
			<if>
				<isset property="jboss.bin.exists"/>
				<then>
					<echo message="Starting JBoss instance at @{jboss.home} with start_jboss" />
					<exec executable="sh" os="Linux" dir="@{jboss.home}/server/@{jboss.server.name}/bin" spawn="true">
						<env key="NOPAUSE" value="true" />
						<arg line="start_jboss" />
					</exec>
				</then>
				<else>
					<echo message="Starting JBoss instance at @{jboss.home} with run.sh" />
					<exec os="Linux" executable="chmod" spawn="true">
						<arg value="+x" />
						<arg file="@{jboss.home}/bin/run.sh" />
						<arg file="@{jboss.home}/bin/shutdown.sh" />
					</exec>
		
					<exec executable="sh" os="Linux" dir="@{jboss.home}/bin" spawn="true">
						<env key="NOPAUSE" value="true" />
						<arg line="run.sh" />
					</exec>

					<exec os="Windows XP, Windows 2000, Windows 2003" executable="cmd" dir="@{jboss.home}/bin" spawn="true" >
						<env key="NOPAUSE" value="true" />
						<arg line="/c run.bat" />
					</exec>
					<sleep seconds="15" />
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	jboss-update-shutdown macro updates the shutdown.jar with the host and jndi port information
	usage: 	<jboss-update-runconf jboss.home="${jboss.home}" jboss.server.hostname="${jboss.server.hostname}" jboss.server.jndi.port="${jboss.server.jndi.port}"/>
		jboss.home is the location where Jboss is installed
		jboss.server.hostname is the host name where the application server is installed
		jboss.server.jndi.port is the JNDI port on which the server listens
	-->
	<macrodef name="jboss-update-shutdown" description="Update the shutdown.jar ">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<attribute name="jboss.server.jndi.port" default="${jboss.server.jndi.port}" />
		<sequential>
			<delete dir="${temp.dir}/shutdown"/>
			<unzip src="${jboss.home}/bin/shutdown.jar" dest="${temp.dir}/shutdown" />
			<replaceregexp file="${temp.dir}/shutdown/jndi.properties" byline="true"
				match="^(java.naming.provider.url)=(.*)"
				replace="\1=jnp://@{jboss.server.hostname}:@{jboss.server.jndi.port}"/>
			
			<jar jarfile="${temp.dir}/shutdown/shutdown.jar" compress="false" manifest="${temp.dir}/shutdown/META-INF/MANIFEST.MF">
				<fileset dir="${temp.dir}/shutdown">
					<include name="*/**" />
				</fileset>
			</jar>
			<copy file="${temp.dir}/shutdown/shutdown.jar" todir="${jboss.home}/bin" overwrite="true"/>
		</sequential>
	</macrodef>
	
	<!-- 
	jboss-update-runconf macro updates the configuration of run.conf and sets the desired JAVA_OPTS
	usage: 	<jboss-update-runconf jboss.home="${jboss.home}" jboss.java.opts="${jboss.java.opts}"/>
		jboss.home is the location where Jboss is installed
		jboss.java.opts are the desired java options for the application server
	-->
	<macrodef name="jboss-update-runconf">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.java.opts" default="${jboss.java.opts}" />
		<sequential>
			<replaceregexp file="${jboss.home}/bin/run.conf" byline="true"
				match="^(\s+JAVA_OPTS)=(.*)"
				replace="\1='@{jboss.java.opts}'"/>
		</sequential>
	</macrodef>

	<!-- 
	validate-pre-install macro is a wrapper for all the pre-install validations and would vaildate for the environment, properties and directory structure of the host before application installation
	usage: 	<validate-pre-install />
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database		
		database.name is the name of the database
		database.url is the url of the database where it is hosted
		database.user is the user of the database
		database.password is the password of the user for the database
		validate-ports-preinstall is the list of comma seperated port numbers		
		ant.check.version is the version of ant. By default the ant version should be greater than 1.7.0
		java.check.version.major is the major version of java. By default the major version should be greater than 1.5
		java.check.version.minor is the minor version of java. By default the minor version should be greater than 1.5.0_10
		The property.template.file is the template file to compare with
		The envpropertyfile is the properties file to be compared to
	-->
	<!-- System Diagnostics  -->
	<macrodef name="validate-pre-install" description="Diagnose the host system before the installation">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
 		<attribute name="validation.pre.port.list" default="${validation.pre.port.list}" />
		<attribute name="ant.check.version" default="1.7.0" />
		<attribute name="java.check.version.major" default="1.5" />
		<attribute name="java.check.version.minor" default="1.5.0_10" />
		<attribute name="property.template.file" default="${properties.template.file}"/>
		<attribute name="envpropertyfile" default="${properties.file}"/>
		<sequential>
			<validate-environment
				ant.check.version="@{ant.check.version}"
				java.check.version.major="@{java.check.version.major}"
				java.check.version.minor="@{java.check.version.minor}"
				/>
			<validate-database
				database.driver="@{database.driver}"
				database.system.url="@{database.system.url}"
				database.system.user="@{database.system.user}"
				database.system.password="@{database.system.password}"
				database.url="@{database.url}"
				database.user="@{database.user}"
				database.password="@{database.password}"
				database.version="@{database.version}"
				database.name="@{database.name}"
				/>
			<validate-properties/>
			<!-- comment out until we add more functionality 
			<compare-properties
				property.template.file="@{property.template.file}"
				envpropertyfile="@{envpropertyfile}"
				/>
			-->
			<check-direct-child-directory
				parent.dir.property="application.base.path"
				child.dir.property="jboss.home"
				/>
			<check-not-child-directory
				parent.dir.property="application.base.path"
				child.dir.property="basedir"
				/>
			<check-valid-directory-name
				directory.property="application.base.path"
				/>
			<check-application-exists
				application.dir.property="jboss.home"
				/>
			<check-database-exists
				database.driver="@{database.driver}"
				database.system.url="@{database.system.url}"
				database.system.user="@{database.system.user}"
				database.system.password="@{database.system.password}"
				database.name="@{database.name}"
				/>
		</sequential>
	</macrodef>

	<!-- 
	validate-environment macro validates host environment i.e the version of the installed ant, jdk.
	usage: 	<validate-environment ant.check.version="1.7.0" java.check.version.major="1.5" java.check.version.minor="1.5.0_10"/>
		ant.check.version is the version of ant. By default the ant version should be greater than 1.7.0
		java.check.version.major is the major version of java. By default the major version should be greater than 1.5
		java.check.version.minor is the minor version of java. By default the minor version should be greater than 1.5.0_10	
	-->
	<macrodef name="validate-environment" description="Diagnose the host system before the installation">
		<attribute name="ant.check.version" default="1.7.0" />
		<attribute name="java.check.version.major" default="1.5" />
		<attribute name="java.check.version.minor" default="1.5.0_10" />
		<sequential>
			<!-- Echo the properties for diagnostic purposes -->
			<echoproperties/>
			<!-- Validate Ant version is 1.7.x -->
			<echo message="Validating Ant version..." />
			<condition property="ant.version.success">
				<antversion atleast="@{ant.check.version}" />
			</condition>
			<antunit:assertPropertyEquals name="ant.version.success" value="true" />
			<echo message="Ant Version: PASSED" />

 			<echo message="Validating Java version..."/>
 			<condition property="java.major.version.good">
				<equals arg1="${ant.java.version}" arg2="@{java.check.version.major}" />
 			</condition>
 			<antunit:assertTrue message="${line.separator}${line.separator}    Your Java SDK version must be 1.5 (1.5.0_10 recommended). The version you have installed is ${java.version}. Please install the correct version of the Java SDK and update your System PATH to point to directory where you installed it. ${line.separator}">
 				<isset property="java.major.version.good"/>
 			</antunit:assertTrue>
			<if>
				<equals arg1="${java.version}" arg2="@{java.check.version.minor}" />
				<then>
					<echo message="Java version check: PASSED" />
				</then>
				<else>
					<echo message="Java version check: WARNING, version is not 1.5.0_10" />
				</else>
			</if>
 			<echo message="Java version check: PASSED" /> 

			<!-- Checks if user running build is root, if so it fails -->
			<if>
				<equals arg1="${user.name}" arg2="root"/>
				<then>
					<fail message="Cannot run build as root."/>
				</then>
				<else>
					<echo message="Not running as root."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	validate-properties macro validates the property values in the property file. The checks include if an REPLACE are left and fails the build,compares database system user and databases users are the same,Checks that hostnames are reachable.
	usage: 	<validate-properties />
		properties.file property should be set before calling this macro		
	-->
	<macrodef name="validate-properties" description="Diagnose the host system before the installation">
		<sequential>
			<!-- Validate properties, checks if an REPLACE are left and fails the build -->
			<if>
				<isset property="properties.file"/>
				<then>
					<echo message="Validating properties file  ${properties.file}..."/>
					<loadfile
						property="fail.properties"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="REPLACE"/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="fail.properties"/>
						<then>
							<echo message="Property file validation: FAILED 'replace' found in file"/>
							<echo message="${fail.properties}"/>
							<fail message="Some properties still have 'REPLACE' in them. These properties require valid values. Please update ${properties.file} and run the installer again. " />
						</then>
					</if>
				</then>
				<else>
					<echo message="Warning: properties.file property is not set"/>
				</else>	
			</if>
			<if>
				<isset property="properties.file"/>
				<then>
					<loadfile
						property="warn.properties"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="replace"/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="warn.properties"/>
						<then>
							<echo message="Some properties still have 'replace' in them, this may cause issues."/> 
							<echo message="${warn.properties}"/>
						</then>
					</if>
				</then>
				<else>
					<echo message="Properties file validation: PASSED"/>
				</else>	
			</if>
			
			<!-- Validate database properties, compares database.system.user to other *databases.*.user  -->
			<if>
				<and>
					<isset property="properties.file"/>
					<isset property="database.system.user"/>
				</and>
				<then>
					<loadfile
						property="all.match.property"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern=".*database.*user=${database.system.user}\r*\n"/> 
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="all.match.property"/>
						<then>
							<for list="${all.match.property}" delimiter="${line.separator}" param="matches.line">
								<sequential>
									<echo message="Evaluating line in properties file = @{matches.line}"/>
									<property name="match.tmp" value="@{matches.line}"/>
									<propertyregex property="is.system.user"
										input="${match.tmp}"
										regexp="database.system.user.*"
										select="true"
										/>
									<if>
										<isset property="is.system.user"/>
										<else>
											<fail message="${line.separator}    The above line in the properties file uses the same user as the database.system.user. This will cause problems creating the database. Please change the mentioned property value to something other than ${database.system.user} and run the install again."/>
										</else>
									</if>
								</sequential>
							</for>
						</then>
						<else> 
							<echo message="No other users match database.system.user = ${database.system.user}"/>
						</else>
					</if>
				</then>
			</if>
			<!-- Checks that hostnames are reachable, does not fail build, just prints message -->
			<if>
				<isset property="properties.file"/>
				<then>
					<propertyselector property="hostname.property.list"
						delimiter=","
						match="^(.*hostname)$"
						select="\1"              
						casesensitive="true" /> 

					<if>
						<isset property="hostname.property.list"/>
						<then>
							<for list="${hostname.property.list}"  param="hostname.property" >
								<sequential>
		 							<propertycopy name="hostname.value" from="@{hostname.property}" />
									<echo message="Attempting to connnect to ${hostname.value}...."/>
									<if>
										<isreachable host="${hostname.value}" timeout="5"/>
										<then>
											<echo message="${hostname.value} reached. (@{hostname.property})"/>
										</then>
										<else>
											<echo message="Could not reach host from property @{hostname.property} with value of ${hostname.value}"/>
										</else>
									</if>
								</sequential>
							</for>
						</then>
					</if>
				</then>
			</if>
		</sequential>
	</macrodef>
			
	<!-- 
	validate-ports-preinstall macro validates whether the host listens on provided list of comma seperated ports 
	usage: 	<validate-ports-preinstall validate-ports-preinstall="${validate-ports-preinstall}" hostname="${jboss.server.hostname}" />
		validate-ports-preinstall is the list of comma seperated port numbers
		hostname is the host name of the machine e.x.localhost
	-->
	<macrodef name="validate-ports-preinstall" description="Diagnose the host system before the installation">
		<attribute name="validation.pre.port.list" default="${validation.pre.port.list}" />
		<attribute name="hostname" default="${jboss.server.hostname}" />
		<sequential>
			<!-- Validate ports are not listening -->
			<if>
				<isset property="validation.pre.port.list"/>
				<then>
 					<echo message="Validationg Ports Are not in use..."/>
 					<for list="@{validation.pre.port.list}" param="validate.port">
						<sequential>
				 			<echo message="Checking if @{validate.port} is running."/>
				 			<condition property="port.listening">
				 				<socket server="@{hostname}" port="@{validate.port}" />
							</condition>
				 			<antunit:assertFalse message="${line.separator}${line.separator}    Port is listening at @{hostname}:@{validate.port}.${line.separator}Verify the JBoss server is not running at @{hostname}:@{validate.port}. If it is not, there may be a different process or application using this port (@{validate.port}).  You can either change the port this application uses by updating your *-install.properties file or change your other application to resolve this issue and continue installing.">
				 				<isset property="port.listening"/>
				 			</antunit:assertFalse>
 							<echo message="Ports check: PASSED" /> 
						</sequential>
					</for>
				</then>
			</if>
		</sequential>
	</macrodef>
 			
	<!-- 
	check-direct-child-directory macro checks the child directory is the child of the parent directory
	usage: 	<check-direct-child-directory parent.dir.property="application.base.path" child.dir.property="jboss.home" />
		parent.dir.property is the property for the parent directory
		child.dir.property is the property for the child directory
	-->
	<macrodef name="check-direct-child-directory" description="Diagnose the host system before the installation">
		<attribute name="parent.dir.property" />
		<attribute name="child.dir.property" />
		<sequential>
			<!-- Application.base.path compare to Jboss.home -->
			<propertycopy name="child.dir" from="@{child.dir.property}" />
			<propertycopy name="parent.dir" from="@{parent.dir.property}" />
			<propertyregex property="child.good"
				input="${child.dir}"
				regexp="${parent.dir}/[\d\w\.\-\_]+"
				select="true"
				/>
			<if>
				<isset property="child.good"/>
				<then>
					<echo message="@{child.dir.property}=${child.dir} is direct child of @{parent.dir.property}=${parent.dir}."/>
				</then>
				<else>
					<echo message="@{child.dir.property}=${child.dir} is not a direct child of @{parent.dir.property}=${parent.dir}."/>
					<fail message="@{child.dir.property} needs to be direct child of @{parent.dir.property}, please update the properties file and retry the build."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	check-not-child-directory macro checks the parent and child directories do not have the same name
	usage: 	<check-not-child-directory parent.dir.property="application.base.path" child.dir.property="basedir" />
		parent.dir.property is the property for the parent directory
		child.dir.property is the property for the child directory
	-->
	<macrodef name="check-not-child-directory" description="Diagnose the host system before the installation">
		<attribute name="parent.dir.property" />
		<attribute name="child.dir.property" />
		<sequential>
			<!-- Application.base.path compare basedir -->
			<propertycopy name="not.child.dir" from="@{child.dir.property}" />
			<propertycopy name="not.parent.dir" from="@{parent.dir.property}" />
			<propertyregex property="child.bad"
				input="${not.child.dir}"
				regexp="${not.parent.dir}"
				select="true"
				/>
			<if>
				<isset property="child.bad"/>
				<then>
					<echo message="@{child.dir.property}=${not.child.dir} is child of @{parent.dir.property}=${not.parent.dir}."/>
					<fail message="@{child.dir.property} cannt be be direct child of @{parent.dir.property}, please update the properties file and retry the build."/>
				</then>
				<else>
					<echo message="@{child.dir.property}=${not.child.dir} is not child of @{parent.dir.property}=${not.parent.dir}."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	check-valid-directory-name macro checks for the possible combinations of the directories and should be called before deleting any directories
	usage: <check-valid-directory-name directory.property="jboss.home" />
		directory.property is the property for the directory to be checked
	-->
	<macrodef name="check-valid-directory-name" description="Diagnose the host system before the installation">
		<attribute name="directory.property" />
		<sequential>
			<!-- Application.base.path check for bad directory -->
			<propertycopy name="directory.value" from="@{directory.property}" />
			<propertyregex property="has.spaces"
				regexp="\s+"
				input="${directory.value}"
				select="\1"
				/>
			<if>
				<isset property="has.spaces"/>
				<then>
					<fail message="@{directory.property} is using directory that space in the name, this is not supported by our current build process.  Please chose another diretory name without a space in it."/>
				</then>
			</if>

			<!-- Application.base.path check for bad directory -->
			<propertyregex property="directory.bad"
				regexp="^(\w:[\/\\])$"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\w:[\\\/]win.*)"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\w:[\\\/]WIN.*)"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\/)$"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\/usr)$"
				input="${directory.value}"
				select="\1"
				/>
			<!-- Relax this one for local installs
			<propertyregex property="directory.bad"
				regexp="^(\/usr\/local)$"
				input="${directory.value}"
				select="\1"
				/>
			-->
			<propertyregex property="directory.bad"
				regexp="^(\/opt)$"
				input="${directory.value}"
				select="\1"
				/>
			<if>
				<isset property="directory.bad"/>
				<then>
					<fail message="@{directory.property} is set to or includes '${directory.bad}, this is not allowed.  As part of the install proces the first thing we do is delete this directory.  Deleting the directory you specified may cause system issues, please chose another directory."/>
				</then>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	check-application-exists macro checks if the application exists. The property where the applications is installed should be priovided as input
	usage: <check-application-exists application.dir.property="jboss.home" />
		application.dir.property is the property for the installation directory of the application
	-->
	<macrodef name="check-application-exists" description="Diagnose the host system before the installation">
		<attribute name="application.dir.property" />
		<sequential>
			<!-- If jboss.home exists prompt to conntinue -->
			<propertycopy name="application.dir" from="@{application.dir.property}" />
			<available property="${application.dir.exists}" file="${application.dir}"/>
			<if>
				<and>
					<isset property="application.dir.exists"/>
					<not>
						<isset property="force.reinstall"/>
					</not>
				</and>
				<then>
					<input message="The @{application.dir.property} (${application.dir}) already exists.  Please be sure you have a recent backup of this directory.  This process will alter files in this path and any customizations you have could be lost.  Do you want to proceed?"
						validargs="y,n"
						addproperty="accept.application.dir.update" />
					<if>
						<equals arg1="${accept.application.dir.update}" arg2="n"/>
						<then>
							<fail message="User tereminated the build."/>
						</then>
					</if>
				</then>
				<else>
					<echo message="@{application.dir.property} ${application.dir} does not exist or the force.reinstall property is set."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	check-database-exists macro checks if the database exists. The root user name and password should be provided
	usage: <check-database-exists database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password} database.name="${database.name}" />
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database		
		database.name is the name of the database
	-->
	<macrodef name="check-database-exists" description="Checks if the database exists">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.name" default="${database.name}" />
		<sequential>
			<if>
				<equals arg1="${database.type}" arg2="mysql" />
				<then>
					<dbconfig property="database.exists" 
						driver="@{database.driver}" url="@{database.system.url}"  user="@{database.system.user}" password="@{database.system.password}">
						<validate />
						<checkdatabaseexists exactly="${database.name}" />
					</dbconfig>
					<echo message="Does @{database.name} exist = ${database.exists} "/>
					<if>
						<and>
							<equals arg1="${database.exists}" arg2="true"/>
							<not>
								<isset property="force.reinstall"/>
							</not>
						</and>
						<then>
							<input message="The database @{database.name} already exists.  Please be sure you have a recent backup of this database.  This process will alter the database if you need to return your database to the current state you need a good backup.  Please ensure you have a good backup before proceeding.  Do you want to proceed?"
								validargs="y,n"
								addproperty="accept.database.update" />
							<if>
								<equals arg1="${accept.database.update}" arg2="n"/>
								<then>
									<fail message="User tereminated the build."/>
								</then>
							</if>
						</then>
						<else>
							<echo message="Database @{database.name} does not exist or the force.reinstall property is set."/>
						</else>
					</if>
				</then>
				<else>
					<echo message="Database is ${database.type}, warning prompt not displayed."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	validate-post-install macro Diagnose the host system after the installation
	usage: <validate-post-install validation.post.http.list="${validation.post.http.list}" validation.post.socket.list="${validation.post.socket.list}" jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}"/>
		validation.post.http.list is the list of all comma seperated ports numbers 
		validation.post.socket.list is the list of all comma seperated sockets
		jboss.home is the location where Jboss is installed
		jboss.server.name is the name of the deployed Jboss server 
	-->
	<macrodef name="validate-post-install" description="Diagnose the host system after the installation">
 		<attribute name="validation.post.http.list" default="${validation.post.http.list}" />
 		<attribute name="validation.post.socket.list" default="${validation.post.socket.list}" />
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>

			<!-- Echo the properties for diagnostic purposes -->
			<echoproperties/>

			<!-- Give JBOSS another couple of seconds to come up -->
			<validate-ports-postinstall  
				validation.post.http.list="@{validation.post.http.list}"
				validation.post.socket.list="@{validation.post.socket.list}"
			/>
			<validate-jboss-logs-postinstall
				jboss.home="@{jboss.home}"
				jboss.server.name="@{jboss.server.name}"
			/>

			<!-- Send test message if smtp proeprties are set
			<if>
				<and>
					<isset property="mail.smtp.host"/>
					<isset property="mail.smtp.port"/>
					<isset property="validation.email.from"/>
					<isset property="validation.email.to"/>
				</and>
			<then>
				<if>
						<socket port="${mail.smtp.port}" server="${mail.smtp.host}" />
					<then>
						<echo message="Able to connect to smpt host on port."/>
					</then>
					<else>
						<echo message="Failed to connnect to ${mail.smtp.host}:${mail.smtp.port}"/>
					</else>
				</if>
				<echo message="Sending Test message- look for errors below"/>
				<mail mailhost="${mail.smtp.host}" mailport="${mail.smtp.port}" subject="Test Message" failonerror="false">
					<from address="${validation.email.from}"/>
					<to address="${validation.email.to}"/>
				<message>Attempting install of ${project.name} ${env.USER}@${env.HOSTNAME} at ${run.date}.</message>
				</mail>
			</then>
			</if>
			-->
			<echo message="******* INSTALLATION COMPLETED SUCESSFULLY *******"/>
			<echo message="${line.separator}To view your application goto ${application.url}."/>
		</sequential>
	</macrodef>

	<!-- 
	validate-ports-postinstall macro checks if the application listens on the specified port numbers and is part of postinstall checks
	usage: <validate-ports-postinstall validation.post.http.list="${validation.post.http.list}" validation.post.socket.list="${validation.post.socket.list}" hostname="${jboss.server.hostname}" />
		validation.post.http.list is the list of all comma seperated ports numbers 
		validation.post.socket.list is the list of all comma seperated sockets
		hostname is the deployed host ex. localhost
	-->
	<macrodef name="validate-ports-postinstall" description="Diagnose the host system after the installation">
		<attribute name="validation.post.http.list" default="${validation.post.http.list}" />
		<attribute name="validation.post.socket.list" default="${validation.post.socket.list}" />
		<attribute name="hostname" default="${jboss.server.hostname}" />
		<sequential>
			<!-- For each http port call validate:post:http -->
			<for list="${validation.post.http.list}" param="validate.port">
				<sequential>
					<echo message="Checking if @{validate.port} is running."/>
					<condition property="port.listening">
						<http url="http://@{hostname}:@{validate.port}" />
					</condition>
					<if>
						<isset property="port.listening"/>
						<then>
							<echo message="Port is @{validate.port} RUNNNING as expected."/>
						</then>
						<else>
							<echo message="Port is not responding or giving an HTTP error code @{hostname}:@{validate.port}. You may experience problems using the application."/>
						</else>
					</if>
				</sequential>
			</for>

			<!-- For each socket port call validate:post:socket -->
			<for list="${validation.post.http.list}" param="validate.port" >
				<sequential>
					<echo message="Checking if @{validate.port} is running."/>
					<condition property="port.listening">
						<socket server="@{hostname}" port="@{validate.port}" />
					</condition>
					<if>
						<isset property="port.listening"/>
						<then>
							<echo message="Port is @{validate.port} RUNNNING as expected."/>
						</then>
						<else>
							<echo message="Unable to reach @{hostname}:@{validate.port}. You may experience problems using the application."/>
						</else>
					</if>
				</sequential>
			</for>
		</sequential>
	</macrodef>

	<!-- 
	validate-jboss-logs-postinstall macro is part of postinstall checks and parses the the jboss server.log and boot.log for any warning and errors after the installation.
	usage: <validate-jboss-logs-postinstall jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}" />
		jboss.home is the location where Jboss is installed
		jboss.server.name is the name of the deployed Jboss server 
	-->
	<macrodef name="validate-jboss-logs-postinstall" description="Diagnose the host system after the installation">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>
			<!-- Process jboss server.log for errors and warnings and display on screen -->
			<property name="server.log" value="@{jboss.home}/server/@{jboss.server.name}/log/server.log"/>
			<property name="boot.log" value="@{jboss.home}/server/@{jboss.server.name}/log/boot.log"/>
			<available property="server.log.exists" file="${server.log}"/>
			<available property="boot.log.exists" file="${boot.log}"/>
			<if>
				<isset property="server.log.exists"/>
				<then>
					<loadfile
						property="log.server.errors"
						srcFile="${server.log}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="^\w+.* ERROR "/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.server.errors"/>
						<then>
							<echo message="The following are ERRORS from the ${server.log}."/>
							<echo message="${log.server.errors}"/>
						</then>
					</if>
			
					<loadfile
						property="log.server.warnings"
						srcFile="${server.log}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="^\w+.* WARN "/>
							</linecontainsregexp>
	
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.server.warnings"/>
						<then>
							<echo message="${line.separator}The following are WARNINGS from the ${server.log}."/>
							<echo message="${log.server.warnings}"/>
						</then>
					</if>
				</then>
			</if>
	
			<!-- Process jboss boot.log for errors and warnings and display on screen -->
			<if>
				<isset property="boot.log.exists"/>
				<then>
					<loadfile
						property="log.boot.errors"
						srcFile="${boot.log}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="^\w+.* ERROR "/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.boot.errors"/>
						<then>
							<echo message="The following are ERRORS from the ${boot.log}."/>
							<echo message="${log.boot.errors}"/>
						</then>
					</if>
			
					<loadfile
						property="log.boot.warnings"
						srcFile="${boot.log}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="^\w+.* WARN "/>
							</linecontainsregexp>
			
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.boot.warnings"/>
						<then>
							<echo message="${line.separator}The following are WARNINGS from the ${boot.log}."/>
							<echo message="${log.boot.warnings}"/>
						</then>
					</if>
				</then>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	database-create macro create the mysql database and user and grant priledges to the user
	usage: <database-create database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password} database.name="${database.name}" database.url="${database.url}" database.password="${database.password}"/>
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database		
		database.name is the name of the database
		database.url is the url of the database where it is hosted
		database.user is the user of the database
		database.password is the password of the user for the database
	-->
	<macrodef name="database-create">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<sequential>
			<if>
				<and>
					<equals arg1="${database.type}" arg2="mysql"/>
					<isset property="force.reinstall"/>
				</and>
				<then>
					<echo message="Database @{database.name} does not exist or the force.reinstall property is set."/>
					<property name="create.sql.dir" value="${bda-utils.resource.dir}/target" />
					<delete dir="${create.sql.dir}"/>
					<!--
					<copy todir="${create.sql.dir}">
						<filterset>
							<filtersfile file="${properties.file}" />
						</filterset>
						<fileset dir="${bda-utils.resource.dir}" includes="create_database_and_user.sql" />									
					</copy>		
					-->
					<sql    
						driver="@{database.driver}"
						url="@{database.system.url}"
						userid="@{database.system.user}"
						password="@{database.system.password}"
						expandproperties="true"
						>
						<classpath>
							<pathelement location="${database.driver.file}" />
						</classpath>
						<transaction>
							DROP DATABASE IF EXISTS @{database.name};
							CREATE DATABASE @{database.name} DEFAULT CHARACTER SET latin1;
							DELETE FROM mysql.user WHERE User='@{database.user}';
							GRANT ALL ON @{database.name}.* TO '@{database.user}'@'localhost' IDENTIFIED BY '@{database.password}' WITH GRANT OPTION;
							GRANT ALL ON @{database.name}.* TO '@{database.user}'@'%' IDENTIFIED BY '@{database.password}' WITH GRANT OPTION;
						</transaction>
					</sql>  
				</then>
			</if>
			<database-create-control-table
				database.url="@{database.url}"
				database.user="@{database.user}"
				database.password="@{database.password}"
				/>
		</sequential>
	</macrodef>

	<!-- 
	database-create-control-table macro creates the build control table which stores the revision number of the build that was last executed
	usage: <database-create-control-table database.url="${database.url}" database.user="${database.user}" database.password="${database.password}"/>
		database.url is the url of the database where it is hosted
		database.user is the user of the database
		database.password is the password of the user for the database
	-->		
	<macrodef name="database-create-control-table">
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<sequential>
			<echo message="Please ignore errors about build_control table already exists."/>
			<sql    
				driver="${database.driver}"
				url="@{database.url}"
				userid="@{database.user}"
				password="@{database.password}"
				expandproperties="true"
				onerror="continue"
				>
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
				<transaction>
					CREATE TABLE build_control (
						revision_number int NOT NULL,
						build_date timestamp
						);
				</transaction>
			</sql>  
		</sequential>
	</macrodef>
	
	<!-- 
	validate-database macro validates the creadentials of the provided system user and the installed version of the database
	usage: <validate-database database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password}" database.version="${database.version}"/>
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database
		database.version is the version of the installed database
	-->
	<macrodef name="validate-database">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
		<sequential>
			<!-- Only validates connection for oracle -->
			<echo message="Validating database connection..." />
			<if>
				<equals arg1="${database.type}" arg2="mysql"/>
				<then>
					<dbconfig property="db.connection.success" 
						driver="@{database.driver}" url="@{database.system.url}"  user="@{database.system.user}" password="@{database.system.password}">
						<validate />
						<checkversion atleast="@{database.version}" />
					</dbconfig>
					<antunit:assertPropertyEquals message="Database connection failed for @{database.system.url}. Verify that your database.system.user and database.system.password property values are valid in the *-install.properties file.  Your database version must be least @{database.version}" name="db.connection.success" value="true" />
					<echo message="Database Connection: PASSED" />
				</then>
				<elseif>
					<equals arg1="${database.type}" arg2="oracle"/>
					<then>
						<dbconfig property="oracle.connection.success" 
							driver="@{database.driver}"
							url="@{database.url}"
							user="@{database.user}"
							password="@{database.password}">
							<validate />
						</dbconfig>
						<antunit:assertPropertyEquals
							message="Database connection failed for @{database.system.url}. Validate your database related properties in the *-install.properties file."
							name="oracle.connection.success"
						       	value="true" />
						<echo message="Database Connection: PASSED" />
					</then>
				</elseif>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	database-identify-scripts identifies the incremental sql scripts which should be executed and added them to the db-integrate target
	This macro is part of the incremental database upgrade and is called during the install time.
	usage: <database-identify-scripts database.sql.dir="${database.sql.dir}" sqlfiles.list.file="${sqlfiles.list.file}" build.properties.file="${build.properties.file}" />
		database.sql.dir is the directory that has the sql files needed to be executed.
		sqlfiles.list.file is the list of sql files with the revision number.By default the macro writes into dbfiles_list.txt
		build.properties.file is the file that stores the build revision number.By default the macro writes into build.properties
	-->	
	<macrodef name="database-identify-scripts">
		<attribute name="sqlfiles.list.file" default="dbfiles_list.txt" />
 		<attribute name="build.properties.file" default="build.properties" />
 		<attribute name="database.sql.dir" />
 		<attribute name="sql.delimiter" default=";" />
 		<attribute name="sql.delimitertype" default="normal" />

		<sequential>
			<loadfile
				property="dbfiles.list.property"
				srcFile="@{sqlfiles.list.file}">
			</loadfile>
			
			<property file="@{sqlfiles.list.file}" />			
			<property file="@{build.properties.file}" />
			
			<copy file="${template.dbintegrate.file}" tofile="${basedir}/db-integrate.xml" overwrite="true" />
			<if>
				<equals arg1="${database.type}" arg2="mysql" />
				<then>
					<property name="sql.revision_number" value="select  ifnull(max(revision_number),0) as revision_number from build_control"/>
				</then>
				<elseif>
					<equals arg1="${database.type}" arg2="oracle" />
					<then>
						<property name="sql.revision_number" value="select max(nvl(revision_number,0)) as revision_number from build_control"/>
					</then>
				</elseif>
			</if>

			<sql
				driver="${database.driver}"
				url="${database.url}"
				userid="${database.user}"
				password="${database.password}"
				print="yes"
				output="outputfile.txt"
				expandproperties="true"
			    >
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
					${sql.revision_number}
			</sql>
			<loadfile
				property="revision.list.property"
				srcFile="outputfile.txt">
			</loadfile>
			<for list="${revision.list.property}" delimiter="${line.separator}" param="last.revision.property" >
				<sequential>
					<if> 
						<equals arg1="@{last.revision.property}" arg2="revision_number" casesensitive="false"/>
						<elseif>
							<equals arg1="@{last.revision.property}" arg2="0 rows affected" />
						</elseif>
						<else>
						 	<property name="last.execute.property" value="@{last.revision.property}"/>
						</else>
					</if> 	
				
				</sequential>
			</for>
			
			<var name="counter" value="1"/>
			<for list="${dbfiles.list.property}" delimiter="${line.separator}" param="file.line.property" >
				<sequential>
					<propertyregex property="commit.revision.value"
						input="@{file.line.property}"
						regexp="(.*)=(.*)"
						select="\2"
						/>

					<propertyregex property="file.name.property"
						input="@{file.line.property}"
						regexp="(.*)=(.*)"
						select="\1"
						/>


					<elopeif>
						<bool>						
							<and>
								<isgreaterthan arg1="${last.execute.property}" arg2="${commit.revision.value}" />
								<not>
									<equals arg1="${commit.revision.value}" arg2="null" casesensitive="false"/>
								</not>
							</and>
						</bool>	
						
						<echo>${commit.revision.value} is less than ${last.execute.property}, Skips the execution of ${file.name.property}</echo>

						<!-- if false, then tasks inside the "else" will execute -->
						<else>
							<if>
								<equals arg1="${last.execute.property}" arg2="${commit.revision.value}" />
								<then>
									<echo>${commit.revision.value} is equal to ${last.execute.property}, Skips the execution of ${file.name.property}</echo>
								</then>
								<else>
									<echo>${commit.revision.value} is greater than ${last.execute.property}</echo>
									<echo>execute the script ${file.name.property} </echo>
									<xmlconfig in="${basedir}/db-integrate.xml" verbose="false">
									<insert name="run-sql-script" type="element" path="//target[@name='database-integrate']" />
									<insert name="database.url" value="${database.url}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="database.user" value="${database.user}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="database.password" value="${database.password}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="sql.file" value="@{database.sql.dir}/${file.name.property}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="sql.delimiter" value="@{sql.delimiter}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="sql.delimitertype" value="@{sql.delimitertype}" type="attribute" path="//target/run-sql-script[${counter}]" />
									</xmlconfig>
									<math result="counter" operand1="${counter}" operation="+" operand2="1" datatype="int"/>
									<echo>${counter}</echo>
								</else>
							</if>
						</else>
					</elopeif>
					

					<var name="commit.revision.value" unset="true"/>
					<var name="file.name.property" unset="true"/>
					
				</sequential>
			</for>
	
		</sequential>
	</macrodef>
	
	<!-- 
	database-build-filelist builds a file with the list of all sqlfiles and the lastCommitRevision for the file in the provided directory.
	It also generates a file with the revision number of the repository on which the build is performed
	This macro is part of the incremental database upgrade and is called during the build time.
	usage: <database-build-filelist incr.sql.dir="${incr.sql.dir}" sqlfiles.list.file="${sqlfiles.list.file}" build.properties.file="${build.properties.file}" />
		incr.sql.dir is the name of the directory where the sql files are stored
		sqlfiles.list.file is the list of sql files with the revision number.By default the macro writes into dbfiles_list.txt
		build.properties.file is the file that stores the build revision number.By default the macro writes into build.properties
	-->
	<macrodef name="database-build-filelist">
		<attribute name="incr.sql.dir"/>
		<attribute name="sqlfiles.list.file" default="dbfiles_list.txt" />
 		<attribute name="build.properties.file" default="build.properties" />
		<sequential>
			<delete file="@{sqlfiles.list.file}"/>
			<delete file="@{build.properties.file}"/>

			<for param="file">
				<path>
					<fileset dir="@{incr.sql.dir}" includes="*.sql"/>
				</path>
				<sequential>
					<echo message="file name is "/>
					<echo message="echo @{file}"/>

					<propertyregex property="file.name.property"
						input="@{file}"
						regexp=".*[\\\/]+(.*.sql)"
						select="\1"
						/>
					<echo message="${file.name.property}"/>

					<svn javahl="false">
						<status path="@{file}" lastChangedRevisionProperty="svn.revision" revisionProperty="build.svn.revision"/>
					</svn>
					<echo message="${svn.revision}"/>
					<echo file="@{sqlfiles.list.file}" append="true" message="${file.name.property}=${svn.revision}${line.separator}"/>
					<var name="file.name.property" unset="true"/>
				</sequential>
			</for>  
			<echo file="@{build.properties.file}" append="true">build.repository.revision=${build.svn.revision}</echo>
		</sequential>
	</macrodef>

	<!-- 
	database-update-version-table macro updates the build_control table in the database with the lastest build revision repository number.
	This macro is part of the incremental database upgrade and is called after the database scripts are executed 
	usage: <database-update-version-table />
		The database information is read from install.properties file and latest build revision repository number 
		is read from build.properties file
	-->
	<macrodef name="database-update-version-table">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<sequential>
			<if>
				<equals arg1="${database.type}" arg2="mysql" />
				<then>
					<property name="insert.revision_number" value="insert into build_control values(${build.repository.revision},now())"/>
				</then>
				<elseif>
					<equals arg1="${database.type}" arg2="oracle" />
					<then>
						<property name="insert.revision_number" value="insert into build_control values(${build.repository.revision},sysdate)"/>
					</then>
				</elseif>
			</if>
			<sql    
				driver="${database.driver}"
				url="${database.url}"
				userid="${database.user}"
				password="${database.password}"
				expandproperties="true"
				>
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
				<transaction>
					${insert.revision_number}
				</transaction>
			</sql>  

			
		</sequential>
	</macrodef>

	<!-- 
	tomcat-stop macro stops the tomcat instance and can be used in both linux and windows platforms	
	usage: <tomcat-stop tomcat.home="${tomcat.home}"/>
		The tomcat.home must be set and passed when calling this macro		
	-->
	<macrodef name="tomcat-stop" description="Stops a local tomcat instance">
		<attribute name="tomcat.home" />
		<sequential>
			<echo message="Stopping Tomcat instance at @{tomcat.home}" />
			<exec executable="sh" os="Linux" dir="@{tomcat.home}/bin" spawn="true">
				<env key="NOPAUSE" value="true" />
				<arg line="shutdown.sh" />
			</exec>
			<exec os="Windows XP, Windows 2000, Windows 2003" executable="cmd" dir="@{tomcat.home}/bin" spawn="true" >
				<env key="NOPAUSE" value="true" />
				<arg line="/c shutdown.bat" />
			</exec>
			<sleep seconds="5" />
		</sequential>
	</macrodef>
	
	<!-- 
	tomcat-stop macro starts the tomcat instance and can be used in both linux and windows platforms	
	usage: <tomcat-start tomcat.home="${tomcat.home}"/>
		The tomcat.home must be set and passed when calling this macro		
	-->	
	<macrodef name="tomcat-start" description="Starts a local tomcat instance">
		<attribute name="tomcat.home" />
		<sequential>
			<echo message="Starting Tomcat instance at @{tomcat.home}" />
			<exec executable="sh" os="Linux" dir="@{tomcat.home}/bin" spawn="true">
				<env key="NOPAUSE" value="true" />
				<arg line="startup.sh" />
			</exec>
			<exec os="Windows XP, Windows 2000, Windows 2003" executable="cmd" dir="@{tomcat.home}/bin" spawn="true" >
				<env key="NOPAUSE" value="true" />
				<arg line="/c startup.bat" />
			</exec>
			<sleep seconds="5" />
		</sequential>
	</macrodef>
	
	<!-- 
	properties-exist macro checks if the value of the property is set in the list of properties seperated by ','
	usage: <properties-exist properties.list="${properties.list}"/>
		The properties.list must be set and passed when calling this macro		
	-->
	<macrodef name="properties-exist" description="Check if the value of the property is set">
		<attribute name="properties.list" />
		<sequential>
			<for list="@{properties.list}" param="prop.list.item" delimiter=",">
				<sequential>
					<echo message="checking for existance of property @{prop.list.item}"/>
					<if>
						<not>
							<isset property="@{prop.list.item}"/>
						</not>
						<then>
							<fail message="Property @{property.list.item} is not set, it needs to be set, please set it to continue"/>
						</then>
					</if>
				</sequential>
			</for>
		</sequential>
	</macrodef>

	<!-- 
	compare-properties macro checks that there are same number of key for a given property files
	usage: <compare-properties property.template.file="${property.template.file} envpropertyfile="${envpropertyfile} "/>
		The property.template.file is the template file to compare with
		The envpropertyfile is the properties file to be compared to
	-->
	<macrodef name="compare-properties" description="validate the properties from the given files">
		<attribute name="property.template.file" />
		<attribute name="envpropertyfile" default="${properties.file}"/>
		<sequential>		
			<ncitask keyFile="@{property.template.file}" compareFile="@{envpropertyfile}" />
		</sequential>
	</macrodef>
	
	<!-- 
	svn-co macro checks out from a subversion repository based on properties passed to macro, clean the destination directory, then check out the tag specified into the destination directory. 
	The macro assumes that all code required to build the application will be located under the software folder off the project root.  You will not be able to use this macro if you do not adhere to this structure.
	usage: <svn-co svn.project.base.url="${svn.project.base.url}" svn.project.name="${svn.project.name}" svn.tag="${svn.tag}" svn.co.base.dir="${svn.co.base.dir}"/>
		The svn.project.base.url is the URL of Subverion reposition to check out from
		The svn.project.name is the name of the project in the repositiory
		The svn.tag is the tag of the build ex. trunk
		The svn.co.base.dir is the local directory to the checkout
	-->	
	<macrodef name="svn-co" description="based on properties passed to macro, clean the destination directory, then check out the tag specified into the destination directory.">
		<attribute name="svn.project.base.url" default="${svn.project.base.url}" />
		<attribute name="svn.project.name" default="${svn.project.name}"/>
		<attribute name="svn.tag" default="trunk"/>
		<attribute name="svn.co.base.dir" default="${user.home}/tmp/" />
		<sequential>		
			<if>
				<equals arg1="@{svn.tag}" arg2="trunk"/>
				<then>
					<property name="svn.url" value="@{svn.project.base.url}/trunk/software"/>
				</then>
				<else>
					<property name="svn.url" value="@{svn.project.base.url}/tags/@{svn.tag}/software"/>
				</else>
			</if>
			<property name="svn.co.dir" value="@{svn.co.base.dir}/svn/@{svn.tag}/@{svn.project.name}"/>
			<echo message="Scorching temporary checkout directory ${svn.co.dir}."/>
			<delete dir="${svn.co.dir}" failonerror="false"/>
			<mkdir dir="${svn.co.dir}"/>
			<echo message="Checking out @{svn.tag} from ${svn.url} to ${svn.co.dir}."/>
			<svn username="anonymous" password="">
				<checkout url="${svn.url}" revision="HEAD" destPath="${svn.co.dir}" />
			</svn> 
		</sequential>
	</macrodef>

	<macrodef name="report-grand" description="generates grand graphs of build.xml files">
		<attribute name="build.file.location" default="build.xml"/>
		<attribute name="output.file.dir" default="."/>
		<attribute name="output.file.name" default="build.xml"/>
		<attribute name="file.type" default="pdf"/>
		<sequential>		
			<property name="grand.output.file" value="grand.dot" />
			<grand output="${grand.output.file}" buildfile="@{build.file.location}"/>
			<exec executable="dot" >
				<arg line="-T@{file.type} -Gsize=11.69,8.27 -Grotate=90 -o @{output.file.dir}/@{output.file.name}.@{file.type} ${grand.output.file}"/>
			</exec>
		</sequential>
	</macrodef>
	
	<!-- 
	jboss-bindings macro configures the binding.xml and the jboss-service.xml which is used by jboss Binding Manager. 	
	usage: <jboss-bindings jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}" jboss.server.ports.name="${jboss.server.ports.name}" jboss.server.bindingfile.location="${jboss.server.bindingfile.location}"/>
		The jboss.home is the location where Jboss is installed
		The jboss.server.name is the name of the deployed Jboss server 
		The jboss.server.ports.name is the name of the configuration to be used from binding.xml	
		jboss.server.bindingfile.location is the location of the binding.xml
	-->		
	<macrodef name="jboss-bindings" description="configures the binding.xml and the jboss-service.xml">
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="jboss.server.ports.name" default="ports-01"/>
		<attribute name="jboss.server.bindingfile.location" default="${jboss.server.bindingfile.location}"/>
		<sequential>						
			<copy tofile="@{jboss.server.bindingfile.location}" file="${bda-utils.resource.dir}/template-binding.xml">
				<filterset>
					<filtersfile file="${properties.file}" />
					<filter token="jboss.server.ports.name" value="@{jboss.server.ports.name}"/>
					<filter token="jboss.server.bindingfile.location" value="@{jboss.server.bindingfile.location}"/>
				</filterset>
			</copy> 
	
			<copy file="${bda-utils.resource.dir}/template-jboss-service.xml" tofile="@{jboss.home}/server/@{jboss.server.name}/conf/jboss-service.xml" overwrite="true">
				<filterset>
					<filter token="jboss.server.ports.name" value="@{jboss.server.ports.name}"/>
					<filter token="jboss.server.bindingfile.location" value="@{jboss.server.bindingfile.location}"/>
				</filterset>
			</copy>

			<!-- Use tokens where possible
			<xmlconfig in="${jboss-service.file}" verbose="false">
				<update path="(//mbean)[@code='org.jboss.services.binding.ServiceBindingManager']/attribute[@name='ServerName']" value="@{jboss.server.ports.name}" />
				<update path="(//mbean)[@code='org.jboss.services.binding.ServiceBindingManager']/attribute[@name='StoreURL']" value="file://@{jboss.server.bindingfile.location}" />
			</xmlconfig>
			-->
		</sequential>
	</macrodef>

	<!-- 
	jboss-read-dbconfig macro reads the database information from the application ds.xml and makes connection to the database to check is the application and the database is installed
		usage: <jboss-read-dbconfig jboss.home="${jboss.home} jboss.server.name="${svn.project.name} jboss.ds-xml.file="name if the ds file"/>
			The jboss.home is the location where Jboss is installed
			The jboss.server.name is the name of the deployed Jboss server 
			The jboss.ds-xml.file is the name of the ds.xml file	
		-->
		<macrodef name="jboss-read-dbconfig" description="check if the application is installed">
			<attribute name="jboss.home" default="${jboss.home}"/>
			<attribute name="jboss.server.name" default="${jboss.server.name}"/>
			<attribute name="jboss.ds-xml.file"/>
			<attribute name="database.url.property.name" default="database.url" />
			<attribute name="database.name.property.name" default="database.name" />
			<attribute name="database.user.property.name" default="database.user" />
			<attribute name="database.password.property.name" default="database.password" />
			<sequential>
				<echo  message="Value of properites before reading existing *-ds.xml file: URL- ${database.url}  USER- ${database.user} PASS- ${database.password} NAME- ${database.name}"/>
				<xmlconfig in="@{jboss.home}/server/@{jboss.server.name}/deploy/@{jboss.ds-xml.file}" verbose="false">
					<read path="//datasources/local-tx-datasource/connection-url" property="read.database.url" />
					<read path="//datasources/local-tx-datasource/user-name" property="read.database.user" />
					<read path="//datasources/local-tx-datasource/password" property="read.database.password" />
				</xmlconfig>
				<dbconfig property="db.appuser.works" 
					driver="${read.database.driver}"
					url="${read.database.url}"
					user="${read.database.user}"
					password="${read.database.password}">
					<validate />
				</dbconfig>
				<propertyregex property="read.database.name"
					input="${read.database.url}"
					regexp=".*[\/\:](.*)"
					select="\1"
					/>
				
				<property name="@{database.url.property.name}" value="${read.database.url}" />
				<property name="@{database.user.property.name}" value="${read.database.user}" />
				<property name="@{database.password.property.name}" value="${read.database.password}" />
				<property name="@{database.name.property.name}" value="${read.database.name}" />

				<if>    
					<isset property="db.appuser.works"/>
					<then>  
						<echo message="Read application database configuration from ${jboss.home}/server/${jboss.server.name}/deploy/@{jboss.ds-xml.file}"/>
						<echo  message="Value after read of *-ds.xml: URL- ${database.url}  USER- ${database.user} PASS- ${database.password} NAME- ${database.name}"/>
					</then> 
					<else>  
						<fail  message="Failed to connect to database URL- ${database.url}  USER- ${database.user} PASS- ${database.password}"/>
					</else> 
				</if>   
		</sequential>
	</macrodef>
	
	<!-- 
	svn-getinfo macro gets the latest revision number in the repository for the give path and will set the lsd.revision property
		usage: <svn-getinfo />
		my.path is the checked out location of the project
	-->
	<macrodef name="svn-getinfo">		
		<attribute name="my.path" default="${basedir}"/>
		<sequential>			
			<svn javahl="false">
				<status path="@{my.path}" revisionProperty="svn.revision" urlProperty="svn.url"/>
			</svn>
			<property name="lsd.revision" value="${svn.revision}" />
			<echo> in macrodef - @{my.path} </echo>
		</sequential>
	</macrodef>
</project>
