<project name="bda-utils" xmlns:antunit="antlib:org.apache.ant.antunit" xmlns="antlib:org.apache.tools.ant">
<!--
$Id$
$HeadURL$
-->

 	<!-- Properties -->
	<property name="software.dir" value="${basedir}"/>
	<property name="temp.dir" value="${software.dir}/target/temp"/>
	<property name="bda-utils.dir" value="${software.dir}/bda-utils"/>
	<property name="bda-utils.resource.dir" value="${bda-utils.dir}/resource"/>	
 	<property name="antunit.jar" value="antunit-1.0.jar"/>
	<property name="template.dbintegrate.file" value="${bda-utils.resource.dir}/template-db-integrate.xml"/>

	<!-- PATHS -->
	<path id="macrodef.classpath">
		<fileset dir="${bda-utils.dir}">
			<include name="**/*.jar" />
		</fileset>
	</path>

	<!-- Taskdefs -->
	<typedef resource="net/ggtools/grand/antlib.xml" classpathref="macrodef.classpath" />
	<taskdef name="dbconfig" classname="com.dbconfig.anttask.DbConfig" classpathref="macrodef.classpath" />
	<taskdef name="svn" classpathref="macrodef.classpath" classname="org.tigris.subversion.svnant.SvnTask" />
	<taskdef resource="net/sf/antcontrib/antcontrib.properties" classpathref="macrodef.classpath"/>
	<taskdef uri="antlib:org.apache.ant.antunit" resource="org/apache/ant/antunit/antlib.xml" classpathref="macrodef.classpath"/>
	<taskdef name="elopeif" classname="ise.antelope.tasks.IfTask" classpathref="macrodef.classpath"/>
	<taskdef name="for" classname="net.sf.antcontrib.logic.ForTask" classpathref="macrodef.classpath"/>
	<taskdef name="propertyvalidator" classname="gov.nih.nci.bda.PropertyValidator" classpathref="macrodef.classpath"/>
	<taskdef resource="liquibasetasks.properties" classpathref="macrodef.classpath"/>
	<taskdef name="xmltask" classname="com.oopsconsultancy.xmltask.ant.XmlTask" classpathref="macrodef.classpath"/>

	<xmlcatalog id="bda.xml.catalog">
		<dtd
			publicId="-//Sun Microsystems, Inc.//DTD J2EE Application Client 1.3//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/application-client_1_3.dtd"
			/>
		<dtd
			publicId="-//Sun Microsystems, Inc.//DTD J2EE Application 1.3//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/application_1_3.dtd"
			/>
		<dtd
			publicId="-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/ejb-jar_2_0.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JAWS 2.4//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jaws_2_4.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD Application Client 3.2//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jboss-client_3_2.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD Application Client 4.0//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jboss-client_4_0.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD Web Application 2.4//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jboss-web_4_0.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSS//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jboss.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSS 2.4//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jboss_2_4.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSS 3.0//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jboss_3_0.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSS 3.2//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jboss_3_2.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSS 4.0//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jboss_4_0.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSSCMP-JDBC 3.0//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jbosscmp-jdbc_3_0.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSSCMP-JDBC 3.2//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jbosscmp-jdbc_3_2.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSSCMP-JDBC 4.0//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/jbosscmp-jdbc_4_0.dtd"
			/>
		<dtd
			publicId="-//JBoss//DTD JBOSS Security Config 3.0//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/security_config.dtd"
			/>
		<dtd
			publicId="-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/web-app_2_3.dtd"
			/>
		<!--
		The following dtds are included in the jboss.jar but do not have public ids so they are not included here
			application_1_2.dtd
			connector_1_0.dtd
			datatypes.dtd
			ejb-jar.dtd
			jaws.dtd
			jboss-app_3_0.dtd
			jboss-app_3_2.dtd
			jboss-app_4_0.dtd
			jboss-web.dtd
			jboss-web_3_0.dtd
			jboss-web_3_2.dtd
			web-app_2_2.dtd
		-->
		<!--
		<dtd
			publicId=""
			location="${bda-utils.resource.dir}/jboss-4.0.5.GA-jems-ejb3/dtd/"
			/>
			/>
		-->
	</xmlcatalog>

	
 	<tstamp>
 		<format property="run.date" pattern="yyMMddHHmm"/>
 	</tstamp>

	<!-- init tasks -->
	<mkdir dir="${temp.dir}"/>
	<property name="database.type" value="mysql"/>
	<switch value="${database.type}">
		<case value="oracle">
			<property name="database.dialect" value="org.hibernate.dialect.OracleDialect"/>
			<property name="is.oracle" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/ojdbc14-10.2.0.3.0.jar "/>
			<property name="database.driver" value="oracle.jdbc.driver.OracleDriver"/>
			<property name="database.schema" value="${database.name}"/>
		</case> 
		<case value="mysql">
			<property name="database.dialect" value="org.hibernate.dialect.MySQLDialect"/>
			<property name="is.mysql" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/mysql-connector-java-5.0.5.jar"/>
			<property name="database.driver" value="com.mysql.jdbc.Driver"/>
			<property name="database.schema" value="${database.name}"/>
		</case> 
		<case value="postgresql">
			<property name="database.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
			<property name="is.postgresql" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/postgresql-jdbc3-8.3-603.jar"/>
			<property name="database.driver" value="org.postgresql.Driver"/>
			<property name="database.schema" value="public"/>
			<!-- 
				driver = org.postgresql.Driver
				url = jdbc:postgresql://localhost/mydatabase
			-->
		</case> 
		<case value="hsqldb">
			<property name="database.dialect" value=""/>
			<property name="is.mysql" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/hsqldb-1.8.0.7.jar"/>
		</case> 
		<default>  
			<fail message="Invalid or unsupported database type ${database.type}"/>
		</default> 
	</switch>
	<path id="jdbc.driver.classpath">
		<pathelement location="${database.driver.file}"/>
	</path>

	
	<!-- run-junit-tests macro runs the unit test cases  
	usage: <run-junit-tests test.src.dir="${test.src.dir}" xml.output.dir="${target.dir}/junit" instrumented.classes="${instrumented.classes.dir}" classpath="${caarray-client.test.classes.dir};${test.data.files.dir};${test.classes.dir};${commons-lang.jar};${commons-io.jar};${caarray-client.test.files.dir};${caarray-client.classes.dir};${caarray-client.resources.dir};${junit.jar};${nci-commons-core.jar}" />
	-->
	<macrodef name="run-junit-tests">
		<attribute name="test.src.dir" />
		<attribute name="xml.output.dir" />
		<attribute name="classpath" default="" />
		<attribute name="instrumented.classes" default="" />

		<sequential>
			<mkdir dir="@{xml.output.dir}" />
			<junit printsummary="on" failureproperty="junit.failure" fork="true" forkmode="once" maxmemory="256m">
				<sysproperty key="net.sourceforge.cobertura.datafile" file="${cobertura.file}" />
				<sysproperty key="server.hostname" value="${jboss.server.hostname}" />
				<sysproperty key="server.port" value="${jboss.server.port}" />
				<sysproperty key="server.jndi.port" value="${jboss.server.jndi.port}" />
				<sysproperty key="selenium.server.port" value="${selenium.server.port}" />

				<classpath>
					<pathelement path="@{instrumented.classes}" />
					<pathelement path="@{classpath}" />
					<path refid="cobertura.classpath" />
				</classpath>
				<formatter type="xml" />
				<batchtest todir="@{xml.output.dir}">
					<fileset dir="@{test.src.dir}">
						<include name="**/*Test.java" />
						<exclude name="**/Abstract*Test.java" />
					</fileset>
				</batchtest>
			</junit>
		</sequential>
	</macrodef>

	<!-- run-sql-script macro executes the sql scripts for a database 
	usage: <run-sql-script database.url="${database.url}" database.user="${database.user}" database.password="${database.password}" sql.file="${sql.dir}/create_table.sql" /> 
	-->
	<macrodef name="run-sql-script" description="By default this will use the database.url, to use drop database &amp; user use the database.system.url property">
		<attribute name="sql.file" />
		<attribute name="sql.delimiter" default=";" />
		<attribute name="sql.delimitertype" default="normal" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="onerror" default="abort" />
		<sequential>
			<sql driver="${database.driver}" url="@{database.url}" userid="@{database.user}" password="@{database.password}" src="@{sql.file}" onerror="@{onerror}" autocommit="true" delimiter="@{sql.delimiter}" delimitertype="@{sql.delimitertype}" keepformat="true">
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
			</sql>
		</sequential>
	</macrodef>

	<!-- remote-ssh macro is a remote SSH procedure. It will use SSH connection defaults as defined in the environment property file to initiate SSH connections and execure remote unix commands. remoteSshCommand is a mandatory attribute to this macrodef.
	usage: <remote-ssh remotesshcommand="mv ${jboss.temp.dir}/caarray.ear ${jboss.home}/deploy/" /> 
	-->
	<macrodef name="remote-ssh" description="This is a remote SSH procedure. It will use SSH connection defaults as defined in the environment property file to initiate SSH connections and execure remote unix commands. remoteSshCommand is a mandatory attribute to this macrodef.">
		<attribute name="remoteSshCommand" />
		<attribute name="remoteSshPort" default="${ssh.port}" />
		<attribute name="remoteSshHost" default="${ssh.server.hostname}" />
		<attribute name="remoteSshUser" default="${ssh.server.username}" />
		<attribute name="remoteSshKeyfile" default="${ssh.key.file}" />
		<attribute name="remoteSshSleep" default="5" />
		<sequential>
			<sshexec port="@{remotesshport}" host="@{remotesshhost}" username="@{remoteSshUser}" keyfile="@{remoteSshKeyfile}" trust="true" passphrase="" verbose="true" command="@{remotesshcommand}" />
			<sleep seconds="@{remoteSshSleep}" />
			<echo message="Performed @{remoteSshCommand} command on @{remoteSshHost}:@{remoteSshPort} using SSH..." />
		</sequential>
	</macrodef>

	<!-- remote-scp macro copies files in a secure manner using SCP. 
	remoteScpToDir and remoteScpFileToCopy are required attributes to this macrodef
	usage: <remote-scp remoteScpFileToCopy="${caarray.ear}" 
	remoteScpToDir="${ssh.server.username}@${ssh.server.hostname}:${jboss.temp.dir}" />
	-->
	<macrodef name="remote-scp" description="This task copies files in a secure manner using SCP. 
	remoteScpToDir and remoteScpFileToCopy are required attributes to this macrodef.">
		<attribute name="remoteScpFileToCopy" />
		<attribute name="remoteScpToDir" />
		<attribute name="remoteScpKeyFile" default="${ssh.key.file}" />
		<attribute name="remoteScpPassphrase" default="" />
		<attribute name="remoteScpTrust" default="true" />
		<attribute name="remoteScpVerbose" default="true" />
		<attribute name="remoteScpSleep" default="5"  />
		<sequential>
			<scp file="@{remoteScpFileToCopy}" keyfile="@{remoteScpKeyFile}" passphrase="@{remoteScpPassphrase}" trust="@{remoteScpTrust}" verbose="@{remoteScpVerbose}" todir="@{remoteScpToDir}" />
			<sleep seconds="@{remoteScpSleep}" />
			<echo message="Copied @{remoteScpFileToCopy} to @{remoteScpToDir} using SCP..." />
		</sequential>
	</macrodef>

	<!-- 
	jboss-stop-jboss macro will stop the jboss instance
	usage: 	<jboss-start-jboss jboss.home="${jboss.home}"/>
		jboss.home is the location where Jboss is installed
		jboss.server.hostname is the host name where the application server is installed
		jboss.server.jndi.port is the JNDI port on which the server listens
	-->
	<macrodef name="jboss-stop-jboss">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<attribute name="jboss.server.jndi.port" default="${jboss.server.jndi.port}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>
			<available file="@{jboss.home}/server/@{jboss.server.name}/bin" property="jboss.bin.exists"/>
			<if>
				<isset property="jboss.bin.exists"/>
				<then>
					<echo message="Shutting down jboss with stop_jboss"/>
					<exec executable="@{jboss.home}/server/@{jboss.server.name}/bin/stop_jboss" osfamily="unix"/>
				</then>
				<else>
					<echo message="Shutting down jboss with shutdown.jar"/>

					<java classname="org.jboss.Shutdown" fork="true" spawn="false">
						<arg line="-s @{jboss.server.hostname}:@{jboss.server.jndi.port} -u admin -p admin -S" />
						<classpath>
							<pathelement location="@{jboss.home}/bin/shutdown.jar" />
						</classpath>
					</java>
				</else>
			</if>
			<sleep seconds="15" />
		</sequential>
	</macrodef>

	<!-- 
	jboss-check-if-jboss-is-running macro checks if the jboss server is up and listening
	usage: 	<jboss-check-if-jboss-is-running jboss.server.port="${jboss.server.port}" jboss.server.hostname="${jboss.server.hostname}" jboss.server.jndi.port="${jboss.server.jndi.port}"/>
		jboss.server.port is the http port number of which the web container listens
		jboss.server.hostname is the host name where the application server is installed		
	-->
	<macrodef name="jboss-check-if-jboss-is-running" description="Checks if a local JBoss instance is running">
		<attribute name="jboss.server.port" default="${jboss.server.port}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<sequential>
			<condition property="jboss.running">
				<socket port="@{jboss.server.port}" server="@{jboss.server.hostname}" />
			</condition>
		</sequential>
	</macrodef>

	<!-- 
	jboss-start-jboss macro will start the jboss instance
	usage: 	<jboss-start-jboss jboss.home="${jboss.home}"/>
		jboss.home is the location where Jboss is installed		
	-->
	<macrodef name="jboss-start-jboss" description="Starts a local JBoss instance">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>
			<available file="@{jboss.home}/server/@{jboss.server.name}/bin" property="jboss.bin.exists"/>
			<if>
				<isset property="jboss.bin.exists"/>
				<then>
					<echo message="Starting JBoss instance at @{jboss.home} with start_jboss" />
					<exec executable="@{jboss.home}/server/@{jboss.server.name}/bin/start_jboss" osfamily="unix" />
				</then>
				<else>
					<echo message="Starting JBoss instance at @{jboss.home} with run.sh" />
					<exec osfamily="unix" executable="chmod" spawn="true">
						<arg value="+x" />
						<arg file="@{jboss.home}/bin/run.sh" />
						<arg file="@{jboss.home}/bin/shutdown.sh" />
					</exec>
		
					<exec executable="sh" osfamily="unix" dir="@{jboss.home}/bin" spawn="true">
						<env key="NOPAUSE" value="true" />
						<arg line="run.sh" />
					</exec>

					<exec osfamily="windows" executable="cmd" dir="@{jboss.home}/bin" spawn="true" >
						<env key="NOPAUSE" value="true" />
						<arg line="/c run.bat" />
					</exec>
					<sleep seconds="15" />
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	jboss-update-shutdown macro updates the shutdown.jar with the host and jndi port information
	usage: 	<jboss-update-runconf jboss.home="${jboss.home}" jboss.server.hostname="${jboss.server.hostname}" jboss.server.jndi.port="${jboss.server.jndi.port}"/>
		jboss.home is the location where Jboss is installed
		jboss.server.hostname is the host name where the application server is installed
		jboss.server.jndi.port is the JNDI port on which the server listens
	-->
	<macrodef name="jboss-update-shutdown" description="Update the shutdown.jar ">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<attribute name="jboss.server.jndi.port" default="${jboss.server.jndi.port}" />
		<sequential>
			<delete dir="${temp.dir}/shutdown"/>
			<unzip src="@{jboss.home}/bin/shutdown.jar" dest="${temp.dir}/shutdown" />
			<replaceregexp file="${temp.dir}/shutdown/jndi.properties" byline="true"
				match="^(java.naming.provider.url)=(.*)"
				replace="\1=jnp://@{jboss.server.hostname}:@{jboss.server.jndi.port}"/>
			
			<jar jarfile="${temp.dir}/shutdown/shutdown.jar" compress="false" manifest="${temp.dir}/shutdown/META-INF/MANIFEST.MF">
				<fileset dir="${temp.dir}/shutdown">
					<include name="*/**" />
				</fileset>
			</jar>
			<copy file="${temp.dir}/shutdown/shutdown.jar" todir="@{jboss.home}/bin" overwrite="true"/>
		</sequential>
	</macrodef>
	
	<!-- 
	jboss-update-runconf macro updates the configuration of run.conf and sets the desired JAVA_OPTS
	usage: 	<jboss-update-runconf jboss.home="${jboss.home}" jboss.java.opts="${jboss.java.opts}"/>
		jboss.home is the location where Jboss is installed
		jboss.java.opts are the desired java options for the application server
	-->
	<macrodef name="jboss-update-runconf">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.java.opts" default="${jboss.java.opts}" />
		<sequential>
			<replaceregexp file="${jboss.home}/bin/run.conf" byline="true"
				match="^(\s+JAVA_OPTS)=(.*)"
				replace="\1='@{jboss.java.opts}'"/>
		</sequential>
	</macrodef>

	<!-- 
	validate-pre-install macro is a wrapper for all the pre-install validations and would vaildate for the environment, properties and directory structure of the host before application installation
	usage: 	<validate-pre-install />
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database		
		database.name is the name of the database
		database.url is the url of the database where it is hosted
		database.user is the user of the database
		database.password is the password of the user for the database
		validate-ports-preinstall is the list of comma seperated port numbers		
		ant.check.version is the version of ant. By default the ant version should be greater than 1.7.0
		java.check.version.major is the major version of java. By default the major version should be greater than 1.5
		java.check.version.minor is the minor version of java. By default the minor version should be greater than 1.5.0_10
		The property.template.file is the template file to compare with
		The envpropertyfile is the properties file to be compared to
	-->
	<!-- System Diagnostics  -->
	<macrodef name="validate-pre-install" description="Diagnose the host system before the installation">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
 		<attribute name="validation.pre.port.list" default="${validation.pre.port.list}" />
		<attribute name="ant.check.version" default="1.7.0" />
		<attribute name="java.check.version.major" default="1.5" />
		<attribute name="java.check.version.minor" default="1.5.0_10" />
		<attribute name="property.template.file" default="${properties.template.file}"/>
		<attribute name="envpropertyfile" default="${properties.file}"/>
		<sequential>
			<validate-environment
				ant.check.version="@{ant.check.version}"
				java.check.version.major="@{java.check.version.major}"
				java.check.version.minor="@{java.check.version.minor}"
				/>
			<validate-database
				database.driver="@{database.driver}"
				database.system.url="@{database.system.url}"
				database.system.user="@{database.system.user}"
				database.system.password="@{database.system.password}"
				database.url="@{database.url}"
				database.user="@{database.user}"
				database.password="@{database.password}"
				database.version="@{database.version}"
				database.name="@{database.name}"
				/>
			<validate-properties/>
			<compare-properties
				property.template.file="@{property.template.file}"
				envpropertyfile="@{envpropertyfile}"
				/>

			<check-direct-child-directory
				parent.dir.property="application.base.path"
				child.dir.property="jboss.home"
				/>
			<check-not-child-directory
				parent.dir.property="application.base.path"
				child.dir.property="basedir"
				/>
			<check-valid-directory-name
				directory.property="application.base.path"
				/>
			<check-application-exists
				application.dir.property="jboss.home"
				/>
			<check-database-exists
				database.driver="@{database.driver}"
				database.system.url="@{database.system.url}"
				database.system.user="@{database.system.user}"
				database.system.password="@{database.system.password}"
				database.name="@{database.name}"
				/>
		</sequential>
	</macrodef>

	<!-- 
	validate-environment macro validates host environment i.e the version of the installed ant, jdk.
	usage: 	<validate-environment ant.check.version="1.7.0" java.check.version.major="1.5" java.check.version.minor="1.5.0_10"/>
		ant.check.version is the version of ant. By default the ant version should be greater than 1.7.0
		java.check.version.major is the major version of java. By default the major version should be greater than 1.5
		java.check.version.minor is the minor version of java. By default the minor version should be greater than 1.5.0_10	
	-->
	<macrodef name="validate-environment" description="Diagnose the host system before the installation">
		<attribute name="ant.check.version" default="1.7.0" />
		<attribute name="java.check.version.major" default="1.5" />
		<attribute name="java.check.version.minor" default="1.5.0_10" />
		<sequential>
			<!-- Echo the properties for diagnostic purposes -->
			<echoproperties/>
			<!-- Validate Ant version is 1.7.x -->
			<echo message="Validating Ant version..." />
			<condition property="ant.version.success">
				<antversion atleast="@{ant.check.version}" />
			</condition>
			<antunit:assertPropertyEquals name="ant.version.success" value="true" />
			<echo message="Ant Version: PASSED" />

 			<echo message="Validating Java version..."/>
 			<condition property="java.major.version.good">
				<equals arg1="${ant.java.version}" arg2="@{java.check.version.major}" />
 			</condition>
 			<antunit:assertTrue message="${line.separator}${line.separator}    Your Java SDK version must be 1.5 (1.5.0_10 recommended). The version you have installed is ${java.version}. Please install the correct version of the Java SDK and update your System PATH to point to directory where you installed it. ${line.separator}">
 				<isset property="java.major.version.good"/>
 			</antunit:assertTrue>
			<if>
				<equals arg1="${java.version}" arg2="@{java.check.version.minor}" />
				<then>
					<echo message="Java version check: PASSED" />
				</then>
				<else>
					<echo message="Java version check: WARNING, version is not 1.5.0_10" />
				</else>
			</if>
 			<echo message="Java version check: PASSED" /> 

			<!-- Checks if user running build is root, if so it fails -->
			<if>
				<equals arg1="${user.name}" arg2="root"/>
				<then>
					<fail message="Cannot run build as root."/>
				</then>
				<else>
					<echo message="Not running as root."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	validate-properties macro validates the property values in the property file. The checks include if an REPLACE are left and fails the build,compares database system user and databases users are the same,Checks that hostnames are reachable.
	usage: 	<validate-properties />
		properties.file property should be set before calling this macro		
	-->
	<macrodef name="validate-properties" description="Diagnose the host system before the installation">
		<sequential>
			<!-- Validate properties, checks if an REPLACE are left and fails the build -->
			<if>
				<isset property="properties.file"/>
				<then>
					<echo message="Validating properties file  ${properties.file}..."/>
					<loadfile
						property="fail.properties"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="REPLACE"/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="fail.properties"/>
						<then>
							<echo message="Property file validation: FAILED 'replace' found in file"/>
							<echo message="${fail.properties}"/>
							<fail message="Some properties still have 'REPLACE' in them. These properties require valid values. Please update ${properties.file} and run the installer again. " />
						</then>
					</if>
				</then>
				<else>
					<echo message="Warning: properties.file property is not set"/>
				</else>	
			</if>
			<if>
				<isset property="properties.file"/>
				<then>
					<loadfile
						property="warn.properties"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="replace"/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="warn.properties"/>
						<then>
							<echo message="Some properties still have 'replace' in them, this may cause issues."/> 
							<echo message="${warn.properties}"/>
						</then>
					</if>
				</then>
				<else>
					<echo message="Properties file validation: PASSED"/>
				</else>	
			</if>
			
			<!-- Validate database properties, compares database.system.user to other *databases.*.user  -->
			<if>
				<and>
					<isset property="properties.file"/>
					<isset property="database.system.user"/>
				</and>
				<then>
					<loadfile
						property="all.match.property"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern=".*database.*user=${database.system.user}\r*\n"/> 
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="all.match.property"/>
						<then>
							<for list="${all.match.property}" delimiter="${line.separator}" param="matches.line">
								<sequential>
									<echo message="Evaluating line in properties file = @{matches.line}"/>
									<property name="match.tmp" value="@{matches.line}"/>
									<propertyregex property="is.system.user"
										input="${match.tmp}"
										regexp="database.system.user.*"
										select="true"
										/>
									<if>
										<isset property="is.system.user"/>
										<else>
											<fail message="${line.separator}    The above line in the properties file uses the same user as the database.system.user. This will cause problems creating the database. Please change the mentioned property value to something other than ${database.system.user} and run the install again."/>
										</else>
									</if>
								</sequential>
							</for>
						</then>
						<else> 
							<echo message="No other users match database.system.user = ${database.system.user}"/>
						</else>
					</if>
				</then>
			</if>
			<!-- Checks that hostnames are reachable, does not fail build, just prints message -->
			<if>
				<isset property="properties.file"/>
				<then>
					<propertyselector property="hostname.property.list"
						delimiter=","
						match="^(.*hostname)$"
						select="\1"              
						casesensitive="true" /> 

					<if>
						<isset property="hostname.property.list"/>
						<then>
							<for list="${hostname.property.list}"  param="hostname.property" >
								<sequential>
		 							<propertycopy name="hostname.value" from="@{hostname.property}" />
									<echo message="Attempting to connnect to ${hostname.value}...."/>
									<if>
										<isreachable host="${hostname.value}" timeout="5"/>
										<then>
											<echo message="${hostname.value} reached. (@{hostname.property})"/>
										</then>
										<else>
											<echo message="Could not reach host from property @{hostname.property} with value of ${hostname.value}"/>
										</else>
									</if>
								</sequential>
							</for>
						</then>
					</if>
				</then>
			</if>
		</sequential>
	</macrodef>
			
	<!-- 
	validate-ports-preinstall macro validates whether the host listens on provided list of comma seperated ports 
	usage: 	<validate-ports-preinstall validate-ports-preinstall="${validate-ports-preinstall}" hostname="${jboss.server.hostname}" />
		validate-ports-preinstall is the list of comma seperated port numbers
		hostname is the host name of the machine e.x.localhost
	-->
	<macrodef name="validate-ports-preinstall" description="Diagnose the host system before the installation">
		<attribute name="validation.pre.port.list" default="${validation.pre.port.list}" />
		<attribute name="hostname" default="${jboss.server.hostname}" />
		<sequential>
			<!-- Validate ports are not listening -->
			<if>
				<isset property="validation.pre.port.list"/>
				<then>
 					<echo message="Validationg Ports Are not in use..."/>
 					<for list="@{validation.pre.port.list}" param="validate.port">
						<sequential>
				 			<echo message="Checking if @{validate.port} is running."/>
				 			<condition property="port.listening">
				 				<socket server="@{hostname}" port="@{validate.port}" />
							</condition>
				 			<antunit:assertFalse message="${line.separator}${line.separator}    Port is listening at @{hostname}:@{validate.port}.${line.separator}Verify the JBoss server is not running at @{hostname}:@{validate.port}. If it is not, there may be a different process or application using this port (@{validate.port}).  You can either change the port this application uses by updating your *-install.properties file or change your other application to resolve this issue and continue installing.">
				 				<isset property="port.listening"/>
				 			</antunit:assertFalse>
 							<echo message="Ports check: PASSED" /> 
						</sequential>
					</for>
				</then>
			</if>
		</sequential>
	</macrodef>
 			
	<!-- 
	check-direct-child-directory macro checks the child directory is the child of the parent directory
	usage: 	<check-direct-child-directory parent.dir.property="application.base.path" child.dir.property="jboss.home" />
		parent.dir.property is the property for the parent directory
		child.dir.property is the property for the child directory
	-->
	<macrodef name="check-direct-child-directory" description="Diagnose the host system before the installation">
		<attribute name="parent.dir.property" />
		<attribute name="child.dir.property" />
		<sequential>
			<!-- Application.base.path compare to Jboss.home -->
			<propertycopy name="child.dir" from="@{child.dir.property}" />
			<propertycopy name="parent.dir" from="@{parent.dir.property}" />
			<propertyregex property="child.good"
				input="${child.dir}"
				regexp="${parent.dir}/[\d\w\.\-\_]+"
				select="true"
				/>
			<if>
				<isset property="child.good"/>
				<then>
					<echo message="@{child.dir.property}=${child.dir} is direct child of @{parent.dir.property}=${parent.dir}."/>
				</then>
				<else>
					<echo message="@{child.dir.property}=${child.dir} is not a direct child of @{parent.dir.property}=${parent.dir}."/>
					<fail message="@{child.dir.property} needs to be direct child of @{parent.dir.property}, please update the properties file and retry the build."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	check-not-child-directory macro checks the parent and child directories do not have the same name
	usage: 	<check-not-child-directory parent.dir.property="application.base.path" child.dir.property="basedir" />
		parent.dir.property is the property for the parent directory
		child.dir.property is the property for the child directory
	-->
	<macrodef name="check-not-child-directory" description="Diagnose the host system before the installation">
		<attribute name="parent.dir.property" />
		<attribute name="child.dir.property" />
		<sequential>
			<!-- Application.base.path compare basedir -->
			<propertycopy name="not.child.dir" from="@{child.dir.property}" />
			<propertycopy name="not.parent.dir" from="@{parent.dir.property}" />
			<propertyregex property="child.bad"
				input="${not.child.dir}"
				regexp="${not.parent.dir}"
				select="true"
				/>
			<if>
				<isset property="child.bad"/>
				<then>
					<echo message="@{child.dir.property}=${not.child.dir} is child of @{parent.dir.property}=${not.parent.dir}."/>
					<fail message="@{child.dir.property} cannt be be direct child of @{parent.dir.property}, please update the properties file and retry the build."/>
				</then>
				<else>
					<echo message="@{child.dir.property}=${not.child.dir} is not child of @{parent.dir.property}=${not.parent.dir}."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	check-valid-directory-name macro checks for the possible combinations of the directories and should be called before deleting any directories
	usage: <check-valid-directory-name directory.property="jboss.home" />
		directory.property is the property for the directory to be checked
	-->
	<macrodef name="check-valid-directory-name" description="Diagnose the host system before the installation">
		<attribute name="directory.property" />
		<sequential>
			<!-- Application.base.path check for bad directory -->
			<propertycopy name="directory.value" from="@{directory.property}" />
			<propertyregex property="has.spaces"
				regexp="\s+"
				input="${directory.value}"
				select="\1"
				/>
			<if>
				<isset property="has.spaces"/>
				<then>
					<fail message="@{directory.property} is using directory that space in the name, this is not supported by our current build process.  Please chose another diretory name without a space in it."/>
				</then>
			</if>

			<!-- Application.base.path check for bad directory -->
			<propertyregex property="directory.bad"
				regexp="^(\w:[\/\\])$"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\w:[\\\/]win.*)"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\w:[\\\/]WIN.*)"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\/)$"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\/usr)$"
				input="${directory.value}"
				select="\1"
				/>
			<!-- Relax this one for local installs
			<propertyregex property="directory.bad"
				regexp="^(\/usr\/local)$"
				input="${directory.value}"
				select="\1"
				/>
			-->
			<propertyregex property="directory.bad"
				regexp="^(\/opt)$"
				input="${directory.value}"
				select="\1"
				/>
			<if>
				<isset property="directory.bad"/>
				<then>
					<fail message="@{directory.property} is set to or includes '${directory.bad}, this is not allowed.  As part of the install proces the first thing we do is delete this directory.  Deleting the directory you specified may cause system issues, please chose another directory."/>
				</then>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	check-application-exists macro checks if the application exists. The property where the applications is installed should be priovided as input
	usage: <check-application-exists application.dir.property="jboss.home" />
		application.dir.property is the property for the installation directory of the application
	-->
	<macrodef name="check-application-exists" description="Diagnose the host system before the installation">
		<attribute name="application.dir.property" />
		<sequential>
			<!-- If jboss.home exists prompt to conntinue -->
			<propertycopy name="application.dir" from="@{application.dir.property}" />
			<available property="${application.dir.exists}" file="${application.dir}"/>
			<if>
				<and>
					<isset property="application.dir.exists"/>
					<not>
						<isset property="force.reinstall"/>
					</not>
				</and>
				<then>
					<input message="The @{application.dir.property} (${application.dir}) already exists.  Please be sure you have a recent backup of this directory.  This process will alter files in this path and any customizations you have could be lost.  Do you want to proceed?"
						validargs="y,n"
						addproperty="accept.application.dir.update" />
					<if>
						<equals arg1="${accept.application.dir.update}" arg2="n"/>
						<then>
							<fail message="User tereminated the build."/>
						</then>
					</if>
				</then>
				<else>
					<echo message="@{application.dir.property} ${application.dir} does not exist or the force.reinstall property is set."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	check-database-exists macro checks if the database exists. The root user name and password should be provided
	usage: <check-database-exists database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password} database.name="${database.name}" />
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database		
		database.name is the name of the database
	-->
	<macrodef name="check-database-exists" description="Checks if the database exists">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.name" default="${database.name}" />
		<sequential>
			<switch value="${database.type}">
				<case value="mysql">	
					<dbconfig property="database.exists" 
						driver="@{database.driver}" url="@{database.system.url}"  user="@{database.system.user}" password="@{database.system.password}">
						<validate />
						<checkdatabaseexists exactly="${database.name}" />
					</dbconfig>
					<echo message="Does @{database.name} exist = ${database.exists} "/>
					<if>
						<and>
							<equals arg1="${database.exists}" arg2="true"/>
							<not>
								<isset property="force.reinstall"/>
							</not>
						</and>
						<then>
							<input message="The database @{database.name} already exists.  Please be sure you have a recent backup of this database.  This process will alter the database if you need to return your database to the current state you need a good backup.  Please ensure you have a good backup before proceeding.  Do you want to proceed?"
								validargs="y,n"
								addproperty="accept.database.update" />
							<if>
								<equals arg1="${accept.database.update}" arg2="n"/>
								<then>
									<fail message="User tereminated the build."/>
								</then>
								<else>
									<property name="force.reinstall" value="true"/>
								</else>
							</if>
						</then>
						<else>
							<echo message="Database @{database.name} does not exist or the force.reinstall property is set."/>
						</else>
					</if>
				</case>
				<default>
					<echo message="Database is ${database.type}, warning prompt not displayed."/>
				</default>
			</switch>
		</sequential>
	</macrodef>

	<!-- 
	validate-post-install macro Diagnose the host system after the installation
	usage: <validate-post-install validation.post.http.list="${validation.post.http.list}" validation.post.socket.list="${validation.post.socket.list}" jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}"/>
		validation.post.http.list is the list of all comma seperated ports numbers 
		validation.post.socket.list is the list of all comma seperated sockets
		jboss.home is the location where Jboss is installed
		jboss.server.name is the name of the deployed Jboss server 
	-->
	<macrodef name="validate-post-install" description="Diagnose the host system after the installation">
 		<attribute name="validation.post.http.list" default="${validation.post.http.list}" />
 		<attribute name="validation.post.socket.list" default="${validation.post.socket.list}" />
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>

			<!-- Echo the properties for diagnostic purposes -->
			<echoproperties/>

			<!-- Give JBOSS another couple of seconds to come up -->
			<validate-ports-postinstall  
				validation.post.http.list="@{validation.post.http.list}"
				validation.post.socket.list="@{validation.post.socket.list}"
			/>
			<validate-jboss-logs-postinstall
				jboss.home="@{jboss.home}"
				jboss.server.name="@{jboss.server.name}"
			/>

			<!-- Send test message if smtp proeprties are set
			<if>
				<and>
					<isset property="mail.smtp.host"/>
					<isset property="mail.smtp.port"/>
					<isset property="validation.email.from"/>
					<isset property="validation.email.to"/>
				</and>
			<then>
				<if>
						<socket port="${mail.smtp.port}" server="${mail.smtp.host}" />
					<then>
						<echo message="Able to connect to smpt host on port."/>
					</then>
					<else>
						<echo message="Failed to connnect to ${mail.smtp.host}:${mail.smtp.port}"/>
					</else>
				</if>
				<echo message="Sending Test message- look for errors below"/>
				<mail mailhost="${mail.smtp.host}" mailport="${mail.smtp.port}" subject="Test Message" failonerror="false">
					<from address="${validation.email.from}"/>
					<to address="${validation.email.to}"/>
				<message>Attempting install of ${project.name} ${env.USER}@${env.HOSTNAME} at ${run.date}.</message>
				</mail>
			</then>
			</if>
			-->
			<echo message="******* INSTALLATION COMPLETED SUCESSFULLY *******"/>
			<echo message="${line.separator}To view your application goto ${application.url}."/>
		</sequential>
	</macrodef>

	<!-- 
	validate-ports-postinstall macro checks if the application listens on the specified port numbers and is part of postinstall checks
	usage: <validate-ports-postinstall validation.post.http.list="${validation.post.http.list}" validation.post.socket.list="${validation.post.socket.list}" hostname="${jboss.server.hostname}" />
		validation.post.http.list is the list of all comma seperated ports numbers 
		validation.post.socket.list is the list of all comma seperated sockets
		hostname is the deployed host ex. localhost
	-->
	<macrodef name="validate-ports-postinstall" description="Diagnose the host system after the installation">
		<attribute name="validation.post.http.list" default="${validation.post.http.list}" />
		<attribute name="validation.post.socket.list" default="${validation.post.socket.list}" />
		<attribute name="hostname" default="${jboss.server.hostname}" />
		<sequential>
			<!-- For each http port call validate:post:http -->
			<for list="${validation.post.http.list}" param="validate.port">
				<sequential>
					<echo message="Checking if @{validate.port} is running."/>
					<condition property="port.listening">
						<http url="http://@{hostname}:@{validate.port}" />
					</condition>
					<if>
						<isset property="port.listening"/>
						<then>
							<echo message="Port is @{validate.port} RUNNNING as expected."/>
						</then>
						<else>
							<echo message="Port is not responding or giving an HTTP error code @{hostname}:@{validate.port}. You may experience problems using the application."/>
						</else>
					</if>
				</sequential>
			</for>

			<!-- For each socket port call validate:post:socket -->
			<if>
			<isset property="validation.post.socket.list"/>
				<then>
					<for list="${validation.post.socket.list}" param="validate.port" >
						<sequential>
							<echo message="Checking if @{validate.port} is running."/>
							<condition property="port.listening">
								<socket server="@{hostname}" port="@{validate.port}" />
							</condition>
							<if>
								<isset property="port.listening"/>
								<then>
									<echo message="Port is @{validate.port} RUNNNING as expected."/>
								</then>
								<else>
									<echo message="Unable to reach @{hostname}:@{validate.port}. You may experience problems using the application."/>
								</else>
							</if>
						</sequential>
					</for>
				</then>	
			</if>
		</sequential>
	</macrodef>

	<!-- 
	validate-jboss-logs-postinstall macro is part of postinstall checks and parses the the jboss server.log and boot.log for any warning and errors after the installation.
	usage: <validate-jboss-logs-postinstall jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}" />
		jboss.home is the location where Jboss is installed
		jboss.server.name is the name of the deployed Jboss server 
	-->
	<macrodef name="validate-jboss-logs-postinstall" description="Diagnose the host system after the installation">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>
			<!-- Process jboss server.log for errors and warnings and display on screen -->
			<property name="server.log" value="@{jboss.home}/server/@{jboss.server.name}/log/server.log"/>
			<property name="boot.log" value="@{jboss.home}/server/@{jboss.server.name}/log/boot.log"/>
			<available property="server.log.exists" file="${server.log}"/>
			<available property="boot.log.exists" file="${boot.log}"/>
			<if>
				<isset property="server.log.exists"/>
				<then>
					<loadfile
						property="log.server.errors"
						srcFile="${server.log}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="^\w+.* ERROR "/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.server.errors"/>
						<then>
							<echo message="The following are ERRORS from the ${server.log}."/>
							<echo message="${log.server.errors}"/>
						</then>
					</if>
			
					<loadfile
						property="log.server.warnings"
						srcFile="${server.log}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="^\w+.* WARN "/>
							</linecontainsregexp>
	
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.server.warnings"/>
						<then>
							<echo message="${line.separator}The following are WARNINGS from the ${server.log}."/>
							<echo message="${log.server.warnings}"/>
						</then>
					</if>
				</then>
			</if>
	
			<!-- Process jboss boot.log for errors and warnings and display on screen -->
			<if>
				<isset property="boot.log.exists"/>
				<then>
					<loadfile
						property="log.boot.errors"
						srcFile="${boot.log}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="^\w+.* ERROR "/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.boot.errors"/>
						<then>
							<echo message="The following are ERRORS from the ${boot.log}."/>
							<echo message="${log.boot.errors}"/>
						</then>
					</if>
			
					<loadfile
						property="log.boot.warnings"
						srcFile="${boot.log}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="^\w+.* WARN "/>
							</linecontainsregexp>
			
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.boot.warnings"/>
						<then>
							<echo message="${line.separator}The following are WARNINGS from the ${boot.log}."/>
							<echo message="${log.boot.warnings}"/>
						</then>
					</if>
				</then>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	database-create macro create the mysql database and user and grant priledges to the user
	usage: <database-create database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password} database.name="${database.name}" database.url="${database.url}" database.password="${database.password}"/>
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database		
		database.name is the name of the database
		database.url is the url of the database where it is hosted
		database.user is the user of the database
		database.password is the password of the user for the database
	-->
	<macrodef name="database-create">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
		<attribute name="database.server" default="${database.server}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<sequential>
			<echo message="Entering database-create"/>
			<if>
				<isset property="force.reinstall"/>
				<then>
					<echo message="Creating ${database.type} database named ${database.name}."/>
					<switch value="${database.type}">
						<case value="mysql">
							<echo message="Database @{database.name} does not exist or the force.reinstall property is set."/>
							<property name="create.sql.dir" value="${bda-utils.resource.dir}/target" />
							<delete dir="${create.sql.dir}"/>
							<sql    
								driver="@{database.driver}"
								url="@{database.system.url}"
								userid="@{database.system.user}"
								password="@{database.system.password}"
								expandproperties="true"
								onerror="continue"
								>
								<classpath>
									<pathelement location="${database.driver.file}" />
								</classpath>
								<transaction>
									REVOKE ALL ON @{database.name}.* FROM '@{database.user}'@'@{database.server}';
									REVOKE ALL ON @{database.name}.* FROM '@{database.user}'@'%';
								</transaction>
							</sql>  
							<sql    
								driver="@{database.driver}"
								url="@{database.system.url}"
								userid="@{database.system.user}"
								password="@{database.system.password}"
								expandproperties="true"
								>
								<classpath>
									<pathelement location="${database.driver.file}" />
								</classpath>
								<transaction>
									DROP DATABASE IF EXISTS @{database.name};
									CREATE DATABASE @{database.name} DEFAULT CHARACTER SET latin1;
									GRANT ALL ON @{database.name}.* TO '@{database.user}'@'@{database.server}' IDENTIFIED BY '@{database.password}';
									GRANT ALL ON @{database.name}.* TO '@{database.user}'@'%' IDENTIFIED BY '@{database.password}';
								</transaction>
							</sql>  
						</case>
						<case value="postgresql">
							<sql    
								driver="@{database.driver}"
								url="@{database.system.url}"
								userid="@{database.system.user}"
								password="@{database.system.password}"
								expandproperties="true"
								onerror="continue"
								autocommit="true"
								>
								<classpath>
									<pathelement location="${database.driver.file}" />
								</classpath>
									drop database if exists ${database.name};
									drop user if exists ${database.user};
									create database ${database.name};
									create user ${database.user} with password '${database.password}';
									grant all on database ${database.name} to ${database.user};
							</sql>  
						</case>
					</switch>
				</then>
			</if>
			<database-create-control-table
				database.url="@{database.url}"
				database.user="@{database.user}"
				database.password="@{database.password}"
				/>
		</sequential>
	</macrodef>

	<!-- 
	database-create-control-table macro creates the build control table which stores the revision number of the build that was last executed
	usage: <database-create-control-table database.url="${database.url}" database.user="${database.user}" database.password="${database.password}"/>
		database.url is the url of the database where it is hosted
		database.user is the user of the database
		database.password is the password of the user for the database
	-->		
	<macrodef name="database-create-control-table">
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<sequential>
			<echo message="Please ignore errors about build_control table already exists."/>
			<sql    
				driver="${database.driver}"
				url="@{database.url}"
				userid="@{database.user}"
				password="@{database.password}"
				expandproperties="true"
				onerror="continue"
				>
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
				<transaction>
					CREATE TABLE build_control (
						revision_number int NOT NULL,
						build_date timestamp
						);
				</transaction>
			</sql>  
		</sequential>
	</macrodef>
	
	<!-- 
	validate-database macro validates the creadentials of the provided system user and the installed version of the database
	usage: <validate-database database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password}" database.version="${database.version}"/>
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database
		database.version is the version of the installed database
	-->
	<macrodef name="validate-database">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
		<sequential>
			<!-- Only validates connection for oracle -->
			<if>
				<not>
					<isset property="ignore.check.database"/>
				</not>
				<then>
					<echo message="Validating database connection..." />
					<switch value="${database.type}">
						<case value="mysql">
							<dbconfig property="db.connection.success" 
								driver="@{database.driver}" url="@{database.system.url}"  user="@{database.system.user}" password="@{database.system.password}">
								<validate />
								<checkversion atleast="@{database.version}" />
							</dbconfig>
							<antunit:assertPropertyEquals message="Database connection failed for @{database.system.url}. Verify that your database.system.user and database.system.password property values are valid in the *-install.properties file.  Your database version must be least @{database.version}" name="db.connection.success" value="true" />
							<echo message="Database Connection: PASSED" />
						</case>
						<case value="oracle">
							<dbconfig property="oracle.connection.success" 
								driver="@{database.driver}"
								url="@{database.url}"
								user="@{database.user}"
								password="@{database.password}">
									<validate />
							</dbconfig>
							<antunit:assertPropertyEquals
								message="Database connection failed for @{database.system.url}. Validate your database related properties in the *-install.properties file."
								name="oracle.connection.success"
							       	value="true" />
							<echo message="Database Connection: PASSED" />
						</case>
						<case value="postgresql">
							<dbconfig property="postgresql.connection.success" 
								driver="@{database.driver}"
								url="@{database.url}"
								user="@{database.user}"
								password="@{database.password}">
									<validate />
									</dbconfig>
							<antunit:assertPropertyEquals
								message="Database connection failed for @{database.system.url}. Validate your database related properties in the *-install.properties file."
								name="postgresql.connection.success"
							       	value="true" />
							<echo message="Database Connection: PASSED" />
						</case>
					</switch>
				</then>
				<else>
					<echo message="Skipped database checkes"/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	database-identify-scripts identifies the incremental sql scripts which should be executed and added them to the db-integrate target
	This macro is part of the incremental database upgrade and is called during the install time.
	usage: <database-identify-scripts database.sql.dir="${database.sql.dir}" sqlfiles.list.file="${sqlfiles.list.file}" build.properties.file="${build.properties.file}" />
		database.sql.dir is the directory that has the sql files needed to be executed.
		sqlfiles.list.file is the list of sql files with the revision number.By default the macro writes into dbfiles_list.txt
		build.properties.file is the file that stores the build revision number.By default the macro writes into build.properties
	-->	
	<macrodef name="database-identify-scripts">
		<attribute name="sqlfiles.list.file" default="dbfiles_list.txt" />
 		<attribute name="build.properties.file" default="build.properties" />
 		<attribute name="database.sql.dir" />
 		<attribute name="sql.delimiter" default=";" />
 		<attribute name="sql.delimitertype" default="normal" />

		<sequential>
			<loadfile
				property="dbfiles.list.property"
				srcFile="@{sqlfiles.list.file}">
			</loadfile>
			
			<property file="@{sqlfiles.list.file}" />			
			<property file="@{build.properties.file}" />
			
			<copy file="${template.dbintegrate.file}" tofile="${basedir}/db-integrate.xml" overwrite="true" />
			<switch value="${database.type}">
				<equals arg1="${database.type}" arg2="mysql" />
				<case value="mysql">
					<property name="sql.revision_number" value="select  ifnull(max(revision_number),0) as revision_number from build_control"/>
				</case>
				<case value="oracle">
					<property name="sql.revision_number" value="select max(nvl(revision_number,0)) as revision_number from build_control"/>
				</case>
				<case value="postgresql">
					<property name="sql.revision_number" value="select max(coalesce(revision_number, 0)) as revision_number from build_control"/>
				</case>
			</switch>

			<sql
				driver="${database.driver}"
				url="${database.url}"
				userid="${database.user}"
				password="${database.password}"
				print="yes"
				output="outputfile.txt"
				expandproperties="true"
			    >
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
					${sql.revision_number}
			</sql>
			<loadfile
				property="revision.list.property"
				srcFile="outputfile.txt">
			</loadfile>
			<for list="${revision.list.property}" delimiter="${line.separator}" param="last.revision.property" >
				<sequential>
					<if> 
						<equals arg1="@{last.revision.property}" arg2="revision_number" casesensitive="false"/>
						<elseif>
							<equals arg1="@{last.revision.property}" arg2="0 rows affected" />
						</elseif>
						<else>
						 	<property name="last.execute.property" value="@{last.revision.property}"/>
						</else>
					</if> 	
				
				</sequential>
			</for>
			
			<var name="counter" value="1"/>
			<for list="${dbfiles.list.property}" delimiter="${line.separator}" param="file.line.property" >
				<sequential>
					<propertyregex property="commit.revision.value"
						input="@{file.line.property}"
						regexp="(.*)=(.*)"
						select="\2"
						/>

					<propertyregex property="file.name.property"
						input="@{file.line.property}"
						regexp="(.*)=(.*)"
						select="\1"
						/>


					<elopeif>
						<bool>						
							<and>
								<isgreaterthan arg1="${last.execute.property}" arg2="${commit.revision.value}" />
								<not>
									<equals arg1="${last.execute.property}" arg2="null" casesensitive="false"/>
								</not>
							</and>
						</bool>	
						
						<echo>${commit.revision.value} is less than ${last.execute.property}, Skips the execution of ${file.name.property}</echo>

						<!-- if false, then tasks inside the "else" will execute -->
						<else>
							<if>
								<equals arg1="${last.execute.property}" arg2="${commit.revision.value}" />
								<then>
									<echo>${commit.revision.value} is equal to ${last.execute.property}, Skips the execution of ${file.name.property}</echo>
								</then>
								<else>
									<echo>${commit.revision.value} is greater than ${last.execute.property}</echo>
									<echo>execute the script ${file.name.property} </echo>
									<xmlconfig in="${basedir}/db-integrate.xml" verbose="false">
									<insert name="run-sql-script" type="element" path="//target[@name='database-integrate']" />
									<insert name="database.url" value="${database.url}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="database.user" value="${database.user}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="database.password" value="${database.password}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="sql.file" value="@{database.sql.dir}/${file.name.property}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="sql.delimiter" value="@{sql.delimiter}" type="attribute" path="//target/run-sql-script[${counter}]" />
									<insert name="sql.delimitertype" value="@{sql.delimitertype}" type="attribute" path="//target/run-sql-script[${counter}]" />
									</xmlconfig>
									<math result="counter" operand1="${counter}" operation="+" operand2="1" datatype="int"/>
									<echo>${counter}</echo>
								</else>
							</if>
						</else>
					</elopeif>
					

					<var name="commit.revision.value" unset="true"/>
					<var name="file.name.property" unset="true"/>
					
				</sequential>
			</for>
	
		</sequential>
	</macrodef>
	
	<!-- 
	database-build-filelist builds a file with the list of all sqlfiles and the lastCommitRevision for the file in the provided directory.
	It also generates a file with the revision number of the repository on which the build is performed
	This macro is part of the incremental database upgrade and is called during the build time.
	usage: <database-build-filelist incr.sql.dir="${incr.sql.dir}" sqlfiles.list.file="${sqlfiles.list.file}" build.properties.file="${build.properties.file}" />
		incr.sql.dir is the name of the directory where the sql files are stored
		sqlfiles.list.file is the list of sql files with the revision number.By default the macro writes into dbfiles_list.txt
		build.properties.file is the file that stores the build revision number.By default the macro writes into build.properties
	-->
	<macrodef name="database-build-filelist">
		<attribute name="incr.sql.dir"/>
		<attribute name="sqlfiles.list.file" default="dbfiles_list.txt" />
 		<attribute name="build.properties.file" default="build.properties" />
		<sequential>
			<delete file="@{sqlfiles.list.file}"/>
			<delete file="@{build.properties.file}"/>

			<for param="file">
				<path>
					<fileset dir="@{incr.sql.dir}" includes="*.sql"/>
				</path>
				<sequential>
					<echo message="file name is "/>
					<echo message="echo @{file}"/>

					<propertyregex property="file.name.property"
						input="@{file}"
						regexp=".*[\\\/]+(.*.sql)"
						select="\1"
						/>
					<echo message="${file.name.property}"/>

					<svn javahl="false">
						<status path="@{file}" lastChangedRevisionProperty="svn.revision" revisionProperty="build.svn.revision"/>
					</svn>
					<echo message="${svn.revision}"/>
					<echo file="@{sqlfiles.list.file}" append="true" message="${file.name.property}=${svn.revision}${line.separator}"/>
					<var name="file.name.property" unset="true"/>
				</sequential>
			</for>  
			<echo file="@{build.properties.file}" append="true">build.repository.revision=${build.svn.revision}</echo>
		</sequential>
	</macrodef>

	<!-- 
	database-update-version-table macro updates the build_control table in the database with the lastest build revision repository number.
	This macro is part of the incremental database upgrade and is called after the database scripts are executed 
	usage: <database-update-version-table />
		The database information is read from install.properties file and latest build revision repository number 
		is read from build.properties file
	-->
	<macrodef name="database-update-version-table">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<sequential>
			<switch value="${database.type}">
				<equals arg1="${database.type}" arg2="mysql" />
				<case value="mysql">
					<property name="insert.revision_number" value="insert into build_control values(${build.repository.revision},now())"/>
				</case>
				<case value="oracle">
					<property name="insert.revision_number" value="insert into build_control values(${build.repository.revision},sysdate)"/>
				</case>
				<case value="postgresql">
					<property name="insert.revision_number" value="insert into build_control values(${build.repository.revision},current_time)"/>
				</case>
			</switch>
			<sql    
				driver="${database.driver}"
				url="${database.url}"
				userid="${database.user}"
				password="${database.password}"
				expandproperties="true"
				>
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
				<transaction>
					${insert.revision_number}
				</transaction>
			</sql>  

			
		</sequential>
	</macrodef>

	<!-- 
	tomcat-stop macro stops the tomcat instance and can be used in both linux and windows platforms	
	usage: <tomcat-stop tomcat.home="${tomcat.home}"/>
		The tomcat.home must be set and passed when calling this macro		
	-->
	<macrodef name="tomcat-stop" description="Stops a local tomcat instance">
		<attribute name="tomcat.home" />
		<sequential>
			<echo message="Stopping Tomcat instance at @{tomcat.home}" />
			<exec executable="sh" osfamily="unix" dir="@{tomcat.home}/bin" spawn="true">
				<env key="NOPAUSE" value="true" />
				<arg line="shutdown.sh" />
			</exec>
			<exec osfamily="windows" executable="cmd" dir="@{tomcat.home}/bin" spawn="true" >
				<env key="NOPAUSE" value="true" />
				<arg line="/c shutdown.bat" />
			</exec>
			<sleep seconds="5" />
		</sequential>
	</macrodef>
	
	<!-- 
	tomcat-stop macro starts the tomcat instance and can be used in both linux and windows platforms	
	usage: <tomcat-start tomcat.home="${tomcat.home}"/>
		The tomcat.home must be set and passed when calling this macro		
	-->	
	<macrodef name="tomcat-start" description="Starts a local tomcat instance">
		<attribute name="tomcat.home" />
		<sequential>
			<echo message="Starting Tomcat instance at @{tomcat.home}" />
			<exec executable="sh" osfamily="unix" dir="@{tomcat.home}/bin" spawn="true">
				<env key="NOPAUSE" value="true" />
				<arg line="startup.sh" />
			</exec>
			<exec osfamily="windows" executable="cmd" dir="@{tomcat.home}/bin" spawn="true" >
				<env key="NOPAUSE" value="true" />
				<arg line="/c startup.bat" />
			</exec>
			<sleep seconds="5" />
		</sequential>
	</macrodef>
	
	<!-- 
	properties-exist macro checks if the value of the property is set in the list of properties seperated by ','
	usage: <properties-exist properties.list="${properties.list}"/>
		The properties.list must be set and passed when calling this macro		
	-->
	<macrodef name="properties-exist" description="Check if the value of the property is set">
		<attribute name="properties.list" />
		<sequential>
			<for list="@{properties.list}" param="prop.list.item" delimiter=",">
				<sequential>
					<echo message="checking for existance of property @{prop.list.item}"/>
					<if>
						<not>
							<isset property="@{prop.list.item}"/>
						</not>
						<then>
							<fail message="Property @{prop.list.item} is not set, it needs to be set, please set it to continue"/>
						</then>
					</if>
				</sequential>
			</for>
		</sequential>
	</macrodef>

	<!-- 
	compare-properties macro checks that there are same number of key for a given property files
	usage: <compare-properties property.template.file="${property.template.file} envpropertyfile="${envpropertyfile} "/>
		The property.template.file is the template file to compare with
		The envpropertyfile is the properties file to be compared to
	-->
	<macrodef name="compare-properties" description="validate the properties from the given files">
		<attribute name="property.template.file" default="${property.template.file}"/>
		<attribute name="envpropertyfile" default="${properties.file}"/>
		<sequential>		
			<echo message="Checking @{envpropertyfile} against template file @{property.template.file}"/>
			<if>
				<available file="@{property.template.file}"/>
				<then>
					<propertyvalidator keyFile="@{property.template.file}"
						compareFile="@{envpropertyfile}"
						match="atleast"
						/>
				</then>
				<else>
					<echo message="Template file @{property.template.file} not avaliable"/>
				</else>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	svn-co macro checks out from a subversion repository based on properties passed to macro, clean the destination directory, then check out the tag specified into the destination directory. 
	The macro assumes that all code required to build the application will be located under the software folder off the project root.  You will not be able to use this macro if you do not adhere to this structure.
	usage: <svn-co svn.project.base.url="${svn.project.base.url}" svn.project.name="${svn.project.name}" svn.tag="${svn.tag}" svn.co.base.dir="${svn.co.base.dir}"/>
		The svn.project.base.url is the URL of Subverion reposition to check out from
		The svn.project.name is the name of the project in the repositiory
		The svn.tag is the tag of the build ex. trunk
		The svn.co.base.dir is the local directory to the checkout
	-->	

	<macrodef name="svn-co" description="based on properties passed to macro, clean the destination directory, then check out the tag specified into the destination directory.">
		<attribute name="svn.checkout.url" />
		<attribute name="svn.checkout.dir"/>
		<attribute name="svn.checkout.user" default="anonymous"/>
		<attribute name="svn.checkout.pass" default=""/>
		<attribute name="delete" default="true"/>
		<sequential>		
			<if>
				<equals arg1="@{delete}" arg2="true" />
				<then>
					<echo message="Scorching temporary checkout directory @{svn.checkout.dir}."/>
					<delete dir="@{svn.checkout.dir}" failonerror="false"/>
					<mkdir dir="@{svn.checkout.dir}"/>
				</then>
			</if>
			<echo message="Checking out @{svn.checkout.url} to @{svn.checkout.dir}."/>
			<svn username="@{svn.checkout.user}" password="@{svn.checkout.pass}">
				<checkout url="@{svn.checkout.url}" revision="HEAD" destPath="@{svn.checkout.dir}" />
			</svn> 
		</sequential>
	</macrodef>

	<macrodef name="svn-add" description="">
		<attribute name="svn.add.dir"/>
		<sequential>		
			<echo message="Adding @{svn.add.dir} to svn."/>
			<svn failonerror="false">
				<add dir="@{svn.add.dir}" force="true"/>
			</svn> 
		</sequential>
	</macrodef>
	<macrodef name="svn-update" description="">
		<attribute name="svn.update.dir"/>
		<sequential>		
			<echo message="Adding @{svn.update.dir} to svn."/>
			<svn failonerror="false">
				<update dir="@{svn.update.dir}"/>
			</svn> 
		</sequential>
	</macrodef>

	<macrodef name="svn-commit" description="">
		<attribute name="svn.commit.dir"/>
		<attribute name="svn.commit.user" default="anonymous"/>
		<attribute name="svn.commit.pass" default=""/>
		<attribute name="svn.commit.message" default="Added by build process"/>
		<sequential>		
			<echo message="Commiting @{svn.commit.dir} to svn."/>
			<svn username="@{svn.commit.user}" password="@{svn.commit.pass}">
				<commit dir="@{svn.commit.dir}" message="@{svn.commit.message}"/>
			</svn> 
		</sequential>
	</macrodef>

	<macrodef name="report-grand" description="generates grand graphs of build.xml files">
		<attribute name="build.file.location" default="build.xml"/>
		<attribute name="output.file.dir" default="."/>
		<attribute name="output.file.name" default="build.xml"/>
		<attribute name="file.type" default="pdf"/>
		<sequential>		
			<property name="grand.output.file" value="${temp.dir}/grand.dot" />
			<grand output="${grand.output.file}" buildfile="@{build.file.location}"/>
			<exec executable="dot" >
				<arg line="-T@{file.type} -Gsize=11.69,8.27 -Grotate=90 -o @{output.file.dir}/@{output.file.name}.@{file.type} ${grand.output.file}"/>
			</exec>
		</sequential>
	</macrodef>
	
	<!-- 
	jboss-bindings macro configures the binding.xml and the jboss-service.xml which is used by jboss Binding Manager. 	
	usage: <jboss-bindings jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}" jboss.server.ports.name="${jboss.server.ports.name}" jboss.server.bindingfile.location="${jboss.server.bindingfile.location}"/>
		The jboss.home is the location where Jboss is installed
		The jboss.server.name is the name of the deployed Jboss server 
		The jboss.server.ports.name is the name of the configuration to be used from binding.xml	
		jboss.server.bindingfile.location is the location of the binding.xml
	-->		
	<macrodef name="jboss-bindings" description="configures the binding.xml and the jboss-service.xml">
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="jboss.server.ports.name" default="ports-01"/>
		<attribute name="jboss.server.bindingfile.location" default="${jboss.server.bindingfile.location}"/>
		<attribute name="jboss.server.binding.template.location" default="${bda-utils.resource.dir}/template-binding.xml"/>
		<attribute name="jboss.server.service.template.location" default="${bda-utils.resource.dir}/template-jboss-service.xml"/>
		<sequential>						
			<copy tofile="@{jboss.server.bindingfile.location}" file="@{jboss.server.binding.template.location}">
				<filterset>
					<filtersfile file="${properties.file}" />
					<filter token="jboss.server.ports.name" value="@{jboss.server.ports.name}"/>
					<filter token="jboss.server.bindingfile.location" value="@{jboss.server.bindingfile.location}"/>
				</filterset>
			</copy> 
	
			<copy file="@{jboss.server.service.template.location}" tofile="@{jboss.home}/server/@{jboss.server.name}/conf/jboss-service.xml" overwrite="true">
				<filterset>
					<filter token="jboss.server.ports.name" value="@{jboss.server.ports.name}"/>
					<filter token="jboss.server.bindingfile.location" value="@{jboss.server.bindingfile.location}"/>
				</filterset>
			</copy>

			<!-- Use tokens where possible
			<xmlconfig in="${jboss-service.file}" verbose="false">
				<update path="(//mbean)[@code='org.jboss.services.binding.ServiceBindingManager']/attribute[@name='ServerName']" value="@{jboss.server.ports.name}" />
				<update path="(//mbean)[@code='org.jboss.services.binding.ServiceBindingManager']/attribute[@name='StoreURL']" value="file://@{jboss.server.bindingfile.location}" />
			</xmlconfig>
			-->
		</sequential>
	</macrodef>

	<!-- 
	jboss-read-dbconfig macro reads the database information from the application ds.xml and makes connection to the database to check is the application and the database is installed
		usage: <jboss-read-dbconfig jboss.home="${jboss.home} jboss.server.name="${svn.project.name} jboss.ds-xml.file="name if the ds file"/>
			The jboss.home is the location where Jboss is installed
			The jboss.server.name is the name of the deployed Jboss server 
			The jboss.ds-xml.file is the name of the ds.xml file	
		-->
		<macrodef name="jboss-read-dbconfig" description="check if the application is installed">
			<attribute name="jboss.home" default="${jboss.home}"/>
			<attribute name="jboss.server.name" default="${jboss.server.name}"/>
			<attribute name="jboss.ds-xml.file"/>
			<attribute name="database.url.property.name" default="database.url" />
			<attribute name="database.name.property.name" default="database.name" />
			<attribute name="database.user.property.name" default="database.user" />
			<attribute name="database.password.property.name" default="database.password" />
			<sequential>
				<echo  message="Value of properites before reading existing *-ds.xml file: URL- ${database.url}  USER- ${database.user} PASS- ${database.password} NAME- ${database.name}"/>
				<xmlconfig in="@{jboss.home}/server/@{jboss.server.name}/deploy/@{jboss.ds-xml.file}" verbose="false">
					<read path="//datasources/local-tx-datasource/connection-url" property="read.database.url" />
					<read path="//datasources/local-tx-datasource/user-name" property="read.database.user" />
					<read path="//datasources/local-tx-datasource/password" property="read.database.password" />
				</xmlconfig>
				<dbconfig property="db.appuser.works" 
					driver="${read.database.driver}"
					url="${read.database.url}"
					user="${read.database.user}"
					password="${read.database.password}">
					<validate />
				</dbconfig>
				<propertyregex property="read.database.name"
					input="${read.database.url}"
					regexp=".*[\/\:](.*)"
					select="\1"
					/>
				
				<property name="@{database.url.property.name}" value="${read.database.url}" />
				<property name="@{database.user.property.name}" value="${read.database.user}" />
				<property name="@{database.password.property.name}" value="${read.database.password}" />
				<property name="@{database.name.property.name}" value="${read.database.name}" />

				<if>    
					<isset property="db.appuser.works"/>
					<then>  
						<echo message="Read application database configuration from ${jboss.home}/server/${jboss.server.name}/deploy/@{jboss.ds-xml.file}"/>
						<echo  message="Value after read of *-ds.xml: URL- ${database.url}  USER- ${database.user} PASS- ${database.password} NAME- ${database.name}"/>
					</then> 
					<else>  
						<fail  message="Failed to connect to database URL- ${database.url}  USER- ${database.user} PASS- ${database.password}"/>
					</else> 
				</if>   
		</sequential>
	</macrodef>
	
	<!-- 
	svn-getinfo macro gets the latest revision number in the repository for the give path and will set the lsd.revision property
		usage: <svn-getinfo />
		my.path is the checked out location of the project
	-->
	<macrodef name="svn-getinfo">		
		<attribute name="my.path" default="${basedir}"/>
		<sequential>			
			<svn javahl="false">
				<status path="@{my.path}" revisionProperty="svn.revision" urlProperty="svn.url"/>
			</svn>
			<property name="lsd.revision" value="${svn.revision}" />
			<echo> in macrodef - @{my.path} </echo>
		</sequential>
	</macrodef>

	<macrodef name="validate-pre-build">		
		<attribute name="wscore.download.url" default="http://gforge.nci.nih.gov/svnroot/commonlibrary/trunk/techstack-2006/os-independent/ws-core-enum-4.0.3.zip"/>
		<attribute name="application.base.path" default="${application.base.path}"/>
		<sequential>			
			<check-wscore-exists
				wscore.download.url="@{wscore.download.url}"
				application.base.path="@{application.base.path}"
				/>
		</sequential>
	</macrodef>

	<macrodef name="check-wscore-exists">		
		<attribute name="wscore.download.url" default="http://gforge.nci.nih.gov/svnroot/commonlibrary/trunk/techstack-2006/os-independent/ws-core-enum-4.0.3.zip"/>
		<attribute name="application.base.path" default="${application.base.path}"/>
		<sequential>			
			<basename property="wscore.file.name" file="@{wscore.download.url}"/>
			<property name="wscore.dest.file" value="temp/${wscore.file.name}"/>
			<propertyregex property="wscore.relative.dir"
				input="@{wscore.download.url}"
				regexp=".*(ws-core-enum[\d\-\.]+)\.zip"
				select="\1"
				/>
			<echo message="Checking for existence of GLOBUS_LOCATION envrironment variable."/>
			<echo message="wscore.relative.dir = ${wscore.relative.dir}"/>
			<mkdir dir="temp"/>
			<if>
				<not>
					<isset property="env.GLOBUS_LOCATION"/>
				</not>
				<then>
					<echo message="GLOBUS_LOCATION not set, downloading and installing @{wscore.download.url}"/>
					<if>
						<not>
							<available file="@{wscore.dest.file}"/>
						</not>
						<then>
							<get src="@{wscore.download.url}"
								dest="${wscore.dest.file}"/>
							<get src="@{wscore.download.url}.MD5"
								dest="${wscore.dest.file}.MD5"/>
							<checksum file="${wscore.dest.file}" verifyProperty="wscore.cksum.ok"/>
							<if>    
								<equals arg1="${wscore.cksum.ok}" arg2="true"/>
								<then>  
									<echo message="Downloaded wscore sucessfully"/>
								</then> 
								<else>  
									<fail message="Failed to download wscore file sucessfully."/>
								</else> 
							</if>   
							<unzip dest="@{application.base.path}" src="${wscore.dest.file}"/>
							<property name="env.GLOBUS_LOCATION" value="@{application.base.path}/${wscore.relative.dir}"/>
							<echo message="Completed install of wscore files into @{application.base.path}/${wscore.relative.dir} "/>

						</then>
					</if>
					<osfamily property="os.family"/>
					<echo message="os.family=${os.family}"/>
					<switch value="${os.family}">
						<case value="unix">
							<echo message="Now you need configure the environment variable GLOBUS_LOCATION."/>
							<echo message="For bash shell you can edit the $HOME/.bash_profile and add 'export GLOBUS_LOCATION=${application.base.path}/${wscore.relative.dir}'"/>
							<echo message="For other shells refer to you operating system documentation (you can check your shell by 'echo $SHELL')"/>

						</case>
						<case value="windows">
							<echo message="Now you need configure the environment variable GLOBUS_LOCATION."/>
							<echo message="Right click on MyComputer, select Proeprties, select Advanced tab, click on Environment Variables, click on New under System Variables,  and set GLOBUS_LOCATION to ${application.base.path}/${wscore.relative.dir}"/>
						</case>
					</switch>
					<fail message="Set GLOBUS_LOCATION and build again."/>
				</then>
				<else>
					<echo message="GLOBUS_LOCATION is set to ${env.GLOBUS_LOCATION} nothing needs to be done."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	generate-uml macro will generate the UML diagram from the checked in code. It will first create a javadoc HTML report and uses Graphviz to generate the UML graph
	Pre-Requisites: Graphviz should be present in the Path, 	
		usage: <generate-uml />
		uml.dir is the directory where the UML diagram are generated.
		src.java.dir is the source of class files. 
		uml.source.path is the classpath for the files
	-->
	<macrodef name="generate-uml">		
		<attribute name="uml.dir" />
		<attribute name="src.java.dir" />
		<attribute name="uml.source.path" />
		<attribute name="UMLGraph.jar" default="umlgraph-4.8.jar" />
		<sequential>				
			<mkdir dir="@{uml.dir}"/>			
			<javadoc sourcepath="@{src.java.dir}" destdir="@{uml.dir}" classpathref="@{uml.source.path}" access="private">				
				<doclet name="gr.spinellis.umlgraph.doclet.UmlGraphDoc" path="${bda-utils.dir}\@{UMLGraph.jar}">
					<param name="-attributes" />
					<param name="-enumerations" />
					<param name="-enumconstants" />
					<param name="-operations" />
					<param name="-qualify" />
					<param name="-types" />
					<param name="-visibility" />
				</doclet>
			</javadoc>		
			<apply executable="dot" dest="@{uml.dir}" parallel="false">
				<arg value="-Tpng"/>
				<arg value="-o"/>
				<targetfile/>
				<srcfile/>
				<fileset dir="@{uml.dir}" includes="*.dot"/>
				<mapper type="glob" from="*.dot" to="*.png"/>
			</apply>		
		</sequential>
	</macrodef>
	
	<!-- 
	generate-erd macro will generate an ERD from the Database	
		usage: <generate-erd />
		report.dir is the directory where the ERD is generated.
	-->	
	<macrodef name="generate-erd">		
		<attribute name="report.dir" default="${target.dir}/reports/schema-spy" />
		<attribute name="database.driver.jar" default="mysql-connector-java-5.0.5-bin.jar" />
		<attribute name="schemaspy.jar" default="schemaSpy_3.1.1.jar" />
		<attribute name="database.server" default="${database.server}" />
		<attribute name="database.port" default="${database.port}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.type" default="${database.type}" />
		<sequential>
			<java jar="${bda-utils.dir}/@{schemaspy.jar}"
			output="${report.dir}/schemaspy-out.log"
			error="${report.dir}/schemaspy-error.log"
			fork="true">
				<arg line="-t @{database.type}"/>
				<arg line="-host @{database.server}"/>
				<arg line="-port @{database.port}"/>
				<arg line="-db @{database.name}"/>
				<arg line="-u @{database.user}"/>
				<arg line="-p @{database.password}"/>
				<arg line="-cp ${bda-utils.dir}\@{database.driver.class}"/>
				<arg line="-o @{report.dir}"/>
			</java>
		</sequential>
	</macrodef>
	<macrodef name="pre-xmlconfig">		
		<attribute name="search.pattern" default="^&lt;\!DOCTYPE.*" />
		<attribute name="replace.pattern" default="&lt;\!DOCTYPE server &gt;" />
		<attribute name="file.location" />
		<attribute name="old-value.property.name" />
		<sequential>
			<loadfile
				property="@{old-value.property.name}"
				srcFile="@{file.location}">
				<filterchain>
					<linecontainsregexp>
						<regexp pattern="@{search.pattern}"/>
					</linecontainsregexp>
				</filterchain>
			</loadfile>
			<replaceregexp file="@{file.location}" byline="true"
				match="@{search.pattern}"
				replace="@{replace.pattern}"/>
		</sequential>
	</macrodef>
	<macrodef name="post-xmlconfig">		
		<attribute name="search.pattern" default="^&lt;\!DOCTYPE.*" />
		<attribute name="file.location" />
		<attribute name="old-value.property.value" />
		<sequential>
			<echo message="Restoreing old value '@{old-value.property.value}' to @{file.location}"/>
			<replaceregexp file="@{file.location}" byline="true"
				match="@{search.pattern}"
				replace="@{old-value.property.value}"/>
		</sequential>
	</macrodef>
	
	
	<!-- 
	fusebox-metrics macro will generate graphical representation of the static analysis for the project
		usage: <fusebox-matrix fusebox.config.file="${bda-utils.dir}/resource/fusemetrics_config.xml" fusebox.template.file="${bda-utils.dir}/resource/dashboard.tmpl" fusebox.output.dir="${basedir}/target/output" fusebox.persist.dir="${basedir}/target/persist" fusebox.search.dir="${basedir}/reports"/>
		fusebox.config.file is the location of the config file.
		fusebox.project.name is the name of the project and the macro configures it into the config file.
		fusebox.search.dir is the location of the resulted XML files from the static analysis.
		fusebox.output.file is the location of the output directory.		
		fusebox.persist.dir is the locations of the persisted directory and the data is appended after each build
		fusebox.template.file is the name of the file that renders data from the persistent file
	-->	
	<macrodef name="fusebox-metrics" description="generates the fusebox metrics">
		<attribute name="fusebox.config.file" default="${bda-utils.resource.dir}/fusemetrics_config.xml" />
		<attribute name="fusebox.project.name" default="Project" />
		<attribute name="fusebox.search.dir" default="reports" />
		<attribute name="fusebox.output.dir" default="output" />
		<attribute name="fusebox.persist.dir" default="persist" />
		<attribute name="fusebox.template.file" default="${bda-utils.resource.dir}/dashboard.tmpl" />

		<sequential>
			<if>								
				<equals arg1="@{fusebox.config.file}" arg2="fusemetrics_config.xml"/>
				<then>				
					<property name= "fusebox.arg.value" value="fusemetrics_config.xml" />				
				</then>
				<else>
					<property name= "fusebox.arg.value" value="@{fusebox.config.file}" />					
				</else>
			</if>
			<if>								
				<equals arg1="@{fusebox.config.file}" arg2="fusemetrics_config.xml"/>
				<then>				
					<property name= "fusebox.arg.value" value="fusemetrics_config.xml" />				
				</then>
				<else>
					<property name= "fusebox.arg.value" value="@{fusebox.config.file}" />					
				</else>
			</if>

			<mkdir dir="@{fusebox.output.dir}"/>
			<mkdir dir="@{fusebox.persist.dir}"/>

			<xmlconfig in="@{fusebox.config.file}" verbose="false">			
				<update path="//config/@project" value="@{fusebox.project.name}" />
				<update path="//config/@search" value="@{fusebox.search.dir}" />
				<update path="//config/@output" value="@{fusebox.output.dir}" />
				<update path="//config/@persist" value="@{fusebox.persist.dir}" />
				<update path="//config/@template" value="@{fusebox.template.file}" />
				<update path="//config/@html" value="@{fusebox.output.dir}/dashboard.html" />
			</xmlconfig>


			<java classname="com.stelligent.fusemetrics.FuseMetrics" >
			<arg value="-c"/>
			<arg value="${fusebox.arg.value}"/>
			<arg value="-d"/>	
			 <classpath>
				   <pathelement location="${bda-utils.dir}/fusemetrics-1.0.jar"/>
				   <pathelement location="${bda-utils.dir}/xom-1.1.jar"/>
				   <pathelement location="${bda-utils.dir}/xercesImpl-2.6.2.jar"/>
				   <pathelement location="${bda-utils.dir}/jfreechart-swt-1.0.9.jar"/>
				   <pathelement location="${bda-utils.dir}/jfreechart-1.0.9.jar"/>
				   <pathelement location="${bda-utils.dir}/swtgraphics2d-1.0.9.jar"/>
				   <pathelement location="${bda-utils.dir}/jcommon-1.0.12.jar"/>
				   <pathelement location="${bda-utils.dir}/itext-2.0.6.jar"/>
				   <pathelement location="${bda-utils.dir}/groovy-all-1.6.jar"/>
			 </classpath>
			</java>
		</sequential>	
	</macrodef>

	<!-- 
	diffrevision macro will generate a file will names of the java files that were checked in from the last revision number till the HEAD or the current revision number
		usage: <diffrevision envpropertyfile="project.properties" differential.file.name="diff_list.txt" />
		old.revision.number is the old revision number when the static analysis is done
		differential.file.name is the name of the file to which the differential list is written.
	-->	
	<macrodef name="diffrevision">
		<attribute name="old.revision.number" />
		<attribute name="differential.file.name" default="diff_list.txt" />
		<sequential>
			<svn javahl="false">
				<status path="${basedir}"  revisionProperty="build.svn.revision" urlProperty="svn.source.url"/>
			</svn>

			<svn javahl="false">
				<diff oldUrl="${svn.source.url}" oldTargetRevision="@{old.revision.number}" newTargetRevision="${build.svn.revision}" outFile="${basedir}/patch.txt"/> 
			</svn>
			<loadfile
				property="diff.file.list"
				srcFile="${basedir}/patch.txt">
				<filterchain>
					<linecontainsregexp>
						<regexp pattern="Index: .*\.java"/>
					</linecontainsregexp>
				</filterchain>
			</loadfile>
			<if>
				<isset property="diff.file.list"/>
				<then>				
					<echo file="@{differential.file.name}" append="false" message="${diff.file.list}${line.separator}"/>
				</then>
			</if>
			<replaceregexp file="@{differential.file.name}" byline="true" match="^Index: (.*)" replace="\1"/>			
			<delete file="${basedir}/patch.txt"/>

		</sequential>
	</macrodef>

	<macrodef name="util-dot-on-dir">

		<attribute name="dot-file.dir" />
		<attribute name="report.type" default="pdf" />
		<sequential>
			<exec osfamily="unix" executable="ls" outputproperty="file.list" dir="@{dot-file.dir}">
				<arg value="-1"/>
			</exec>
			<exec osfamily="windows" executable="dir" outputproperty="file.list" dir="@{dot-file.dir}">
				<arg line="/c dir /b"/>
			</exec>
	
			<for list="${file.list}" delimiter="${line.separator}" param="file.name">
				<sequential>
					<if>
						<contains string="@{file.name}" substring="dot"/>
						<then>
							<propertyregex property="base.file.name"
								input="@{file.name}"
								regexp="(.*)\.dot"
								select="\1"
								override="true"
								/>
							<echo message="Running graphviz on ${base.file.name}"/>
							<exec executable="dot" dir="@{dot-file.dir}">
								<arg value="-T@{report.type}"/>
								<arg value="-Gsize=11.69,8.27"/>
								<!--
								<arg value="-Grotate=90"/>
								-->
								<arg value="-o"/>
								<arg value="${base.file.name}.@{report.type}"/>
								<arg value="@{file.name}"/>
							</exec> 
						</then>
					</if>
				</sequential>
			</for>
		</sequential>
	</macrodef>
	<macrodef name="database-clean">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
		<attribute name="database.server" default="${database.server}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="database.re-create" default="${database.re-create}" />
		<attribute name="database.drop-schema" default="${database.drop-schema}" />
		<sequential>
			<if>
				<and>
					<equals arg1="@{database.re-create}" arg2="true"/>
					<equals arg1="@{database.drop-schema}" arg2="true"/>
				</and>
				<then>
					<fail message="You cannot set both database.re-create and database.drop-schema at the same time.  database.re-create is used in local installs.  database.drop-schema is used in remote installs.  Either one can be set for external (Cancer Center) installs."/>
				</then>
			</if>
			<if>
				<equals arg1="@{database.re-create}" arg2="true"/>
				<then>
					<switch value="${database.type}">
						<case value="postgresql">
							<database-create/>
						</case>
						<case value="mysql">
							<database-create/>
						</case>
						<default>
							<echo message="Re-creation (drop and re-create) of ${database.type} databases is not supported, nothing done."/>
						</default>
					</switch>
				</then>
				<else>
					<echo message="Database.recreate flag not set, database not re-created."/>
				</else>
			</if>
			<if>
				<equals arg1="@{database.drop-schema}" arg2="true"/>
				<then>
					<echo message="Dropping database objects"/>
					<dropAllDatabaseObjects
						driver="@{database.driver}"
						url="@{database.url}"
						username="@{database.user}"
						password="@{database.password}"
						promptOnNonLocalDatabase="@{prompt.user.if.not.local.database}"
						classpathref="bda-utils.classpath"
						defaultSchemaName="@{database.schema}"
						/>
					<!-- Sequences don't seem to drop in first run second run cleans them up -->
					<dropAllDatabaseObjects
						driver="@{database.driver}"
						url="@{database.url}"
						username="@{database.user}"
						password="@{database.password}"
						promptOnNonLocalDatabase="@{prompt.user.if.not.local.database}"
						classpathref="bda-utils.classpath"
						defaultSchemaName="@{database.schema}"
						/>
					<sleep seconds="5"/>
				</then>
				<else>
					<echo message="Database.drop-schema flag not set, database schema not dropped."/>
				</else>
			</if>

		</sequential>
	</macrodef>
	<macrodef name="database-install">
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="sql.delimiter" default=";" />
		<attribute name="sql.delimitertype" default="normal" />
		<attribute name="onerror" default="abort" />
		<attribute name="db-install.dir" default="${db-install.dir.dest}" />
		<attribute name="db.install.create.file.list" />
		<sequential>
			<for list="@{db.install.create.file.list}" param="db.install.oracle.file">
				<sequential>
					<run-sql-script database.url="@{database.url}"
						database.user="@{database.user}" 
						database.password="@{database.password}" 
						sql.delimiter="@{sql.delimiter}" 
						sql.delimitertype="@{sql.delimitertype}"
						sql.file="@{db-install.dir}/${database.type}/@{db.install.oracle.file}"
						onerror="@{onerror}"/>
				</sequential>
			</for>
		</sequential>
	</macrodef>
	<macrodef name="database-upgrade">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="database.changelog.file" default="${db-upgrade.dir.dest}/db-upgrade.xml" />
		<sequential>
			<updateDatabase
				driver="@{database.driver}"
				url="@{database.url}"
				username="@{database.user}"
				password="@{database.password}"
				classpathref="jdbc.driver.classpath"
				defaultSchemaName="@{database.schema}"
				changeLogFile="@{database.changelog.file}"
				/>
		</sequential>
	</macrodef>
	<macrodef name="database-genchangelog">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="database.changelog.file" default="generated-change-log.xml" />
		<sequential>
			<generateChangeLog
				driver="@{database.driver}"
				url="@{database.url}"
				username="@{database.user}"
				password="@{database.password}"
				classpathref="jdbc.driver.classpath"
				defaultSchemaName="@{database.schema}"
				outputFile="@{database.changelog.file}"
				/>
		</sequential>
	</macrodef>
	<macrodef name="database-tag">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<sequential>
			<if>
				<isset property="database.release.version"/>
				<then>
					<tagDatabase
						driver="@{database.driver}"
						url="@{database.url}"
						username="@{database.user}"
						password="@{database.password}"
						classpathref="jdbc.driver.classpath"
						defaultSchemaName="@{database.schema}"
						tag="${database.release.version}"
						>
					</tagDatabase>
				</then>
				<else>
					<fail message="Variable database.release.version must be set to call upgrade:database:tag target."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	<macrodef name="database-rollback">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="database.changelog.file" default="${db-upgrade.dir.dest}/db-upgrade.xml" />
		<sequential>
			<if>
				<isset property="database.rollback.version"/>
				<then>
					<echo message="Rolling datbase back to version ${database.rollback.version}."/>
					<rollbackDatabase
						driver="@{database.driver}"
						url="@{database.url}"
						username="@{database.user}"
						password="@{database.password}"
						classpathref="jdbc.driver.classpath"
						defaultSchemaName="@{database.schema}"
						changeLogFile="@{database.changelog.file}"
						rollbackTag="${database.rollback.version}"
						>
					</rollbackDatabase>
				</then>
				<else>
					<fail message="Variable database.rollback.version must be set to call upgrade:database:rollback target."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	<macrodef name="database-diff">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="compare1.database.url" default="${compare1.database.url}" />
		<attribute name="compare1.database.user" default="${compare1.database.user}" />
		<attribute name="compare1.database.password" default="${compare1.database.password}" />
		<attribute name="compare1.database.schema" default="${compare1.database.schema}" />
		<attribute name="compare2.database.url" default="${compare2.database.url}" />
		<attribute name="compare2.database.user" default="${compare2.database.user}" />
		<attribute name="compare2.database.password" default="${compare2.database.password}" />
		<attribute name="compare2.database.schema" default="${compare2.database.schema}" />
		<attribute name="output.file.txt" default="generated-diff-log.txt"/>
		<attribute name="output.file.xml" default="generated-diff-log.xml"/>
		<sequential>
			<echo message="Generating diff report @{compare1.database.url} to @{compare2.database.url}."/>
			<diffDatabase
				driver="@{database.driver}"
				outputFile="@{output.file.txt}"
				classpathref="jdbc.driver.classpath"

				baseUrl="@{compare1.database.url}"
				baseUsername="@{compare1.database.user}"
				basePassword="@{compare1.database.password}"
				baseDefaultSchemaName="@{compare1.database.schema}"

				url="@{compare2.database.url}"
				username="@{compare2.database.user}"
				password="@{compare2.database.password}"
				defaultSchemaName="@{compare2.database.schema}"

				/>
			<diffDatabaseToChangeLog
				driver="@{database.driver}"
				outputFile="@{output.file.xml}"
				classpathref="jdbc.driver.classpath"

				baseUrl="@{compare1.database.url}"
				baseUsername="@{compare1.database.user}"
				basePassword="@{compare1.database.password}"
				baseDefaultSchemaName="@{compare1.database.schema}"

				url="@{compare2.database.url}"
				username="@{compare2.database.user}"
				password="@{compare2.database.password}"
				defaultSchemaName="@{compare2.database.schema}"

				/>
		</sequential>
	</macrodef>
	<macrodef name="database-doc">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="output.dir" default="${temp.dir}/dbDoc" />
		<attribute name="database.changelog.file" default="${db-upgrade.dir.dest}/db-upgrade.xml" />
		<sequential>
			<mkdir dir="@{output.dir}"/>
			<dbDoc
				driver="@{database.driver}"
				url="@{database.url}"
				username="@{database.user}"
				password="@{database.password}"
				classpathref="jdbc.driver.classpath"
				defaultSchemaName="@{database.schema}"
				outputDirectory="@{output.dir}"
				changeLogFile="@{database.changelog.file}"
				/>
		</sequential>
	</macrodef>
	<macrodef name="ivy-module-add2repo">
		<attribute name="ivy-repo.base.url" default="http://gforge.nci.nih.gov/svnroot/commonlibrary/trunk/ivy-repo"/>
		<attribute name="ivy-repo.base.dir"/>
		<attribute name="ivy.add.org" />
		<attribute name="ivy.add.module" />
		<attribute name="ivy.add.version" />
		<attribute name="ivy.add.module.src.dir" />
		<attribute name="ivy.add.module.src.file.list" />
		<attribute name="ivy.add.xml.src.location" />

		<sequential>
			<property name="ivy.org.dir" value="@{ivy-repo.base.dir}/@{ivy.add.org}"/>
			<property name="ivy.module.dir" value="@{ivy-repo.base.dir}/@{ivy.add.org}/@{ivy.add.module}"/>
			<property name="ivy.version.dir" value="@{ivy-repo.base.dir}/@{ivy.add.org}/@{ivy.add.module}/@{ivy.add.version}"/>
			<available file="${ivy.org.dir}" property="org.dir.exists" />
			<available file="${ivy.module.dir}" property="module.dir.exists" />

			<check-svnuser/>
			<!-- Conditionally checkout or update -->
			<if>
				<available file="@{ivy-repo.base.dir}"/>
				<then>
					<echo message="Found @{ivy-repo.base.dir}, doing svn update."/>
					<svn-update
						svn.update.dir="@{ivy-repo.base.dir}"
						/>
				</then>
				<else>
					<svn-co
						svn.checkout.url="@{ivy-repo.base.url}"
						svn.checkout.dir="@{ivy-repo.base.dir}"
						delete="false"
						/>
				</else>
			</if>
			<!-- Copy artifacts to directory -->
			<copy todir="${ivy.version.dir}" file="@{ivy.add.xml.src.location}"/>

			<for list="@{ivy.add.module.src.file.list}" param="ivy.add.module.src.file" delimiter=",">
				<sequential>
					<copy todir="${ivy.version.dir}" file="@{ivy.add.module.src.dir}/@{ivy.add.module.src.file}"/>
				</sequential>
			</for>
			<!-- Add and commit to svn, only the directory level that does not exist -->
			<if>
				<not>
					<isset property="org.dir.exists"/>
				</not>
				<then>
					<echo message="Adding org @{ivy.add.org}."/>
					<svn-add
						svn.add.dir="${ivy.org.dir}"
						/>
					<svn-commit
						svn.commit.dir="${ivy.org.dir}"
						svn.commit.user="${svn.user.name}"
						svn.commit.pass="${svn.user.pass}"
						svn.commit.message="Files added by build process as part of ivy deploy process"
						/>
				</then>
				<elseif>
					<not>
						<isset property="module.dir.exists"/>
					</not>
					<then>
						<echo message="Adding module @{ivy.add.org}/@{ivy.add.module}."/>
						<svn-add
							svn.add.dir="${ivy.module.dir}"
							/>
						<svn-commit
							svn.commit.dir="${ivy.module.dir}"
							svn.commit.user="${svn.user.name}"
							svn.commit.pass="${svn.user.pass}"
							svn.commit.message="Files added by build process as part of ivy deploy process"
							/>
					</then>
				</elseif>
				<else>
					<echo message="Adding version @{ivy.add.org}/@{ivy.add.module}/@{ivy.add.version}."/>
					<svn-add
						svn.add.dir="${ivy.version.dir}"
						/>
					<svn-commit
						svn.commit.dir="${ivy.version.dir}"
						svn.commit.user="${svn.user.name}"
						svn.commit.pass="${svn.user.pass}"
						svn.commit.message="Files added by build process as part of ivy deploy process"
						/>
				</else>
			</if>
		</sequential>

	</macrodef>

	<macrodef name="check-svnuser">
		<sequential>
			<property name="prop.list" value="svn.user.name,svn.user.pass"/>
			<for list="${prop.list}" param="prop.list.item" delimiter=",">
				<sequential>
					<echo message="Checking for existence of @{prop.list.item}"/>
					<if>
						<not>
							<isset property="@{prop.list.item}"/>
						</not>
						<then>
							<fail message="svn.user.name svn.user.pass must be set to add files to ivy so add them to a properties file (like local.properties) or pass them in on the command line."/>
						</then>
					</if>
				</sequential>
			</for>
		</sequential>
	</macrodef>

</project>
