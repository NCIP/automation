<project name="bda-utils" xmlns:antunit="antlib:org.apache.ant.antunit">
<!--
$Id$
$HeadURL$
-->

 	<!-- Properties -->
	<property name="software.dir" value="${basedir}"/>
	<property name="temp.dir" value="${software.dir}/target/temp"/>
	<property name="bda-utils.dir" value="${software.dir}/bda-utils"/>
	<property name="bda-utils.resource.dir" value="${bda-utils.dir}/resource"/>	
 	<property name="antunit.jar" value="antunit-1.0.jar"/>
	<property name="template.dbintegrate.file" value="${bda-utils.resource.dir}/template-db-integrate.xml"/>

	<!-- Supported versions --> 
	<property name="jboss.version.min" value="4.0.4"/>
	<property name="jboss.version.max" value="4.0.5"/>
	<property name="tomcat.version.min" value="5.0.0"/>
	<property name="tomcat.version.max" value="5.5.999"/>
	<!-- PATHS -->
	<path id="macrodef.classpath">
		<fileset dir="${bda-utils.dir}">
			<include name="**/*.jar" />
		</fileset>
	</path>

	<!-- Taskdefs -->
	<typedef resource="net/ggtools/grand/antlib.xml" classpathref="macrodef.classpath" />
	<taskdef name="dbconfig" classname="com.dbconfig.anttask.DbConfig" classpathref="macrodef.classpath" />
	<taskdef name="svn" classpathref="macrodef.classpath" classname="org.tigris.subversion.svnant.SvnTask" />
	<taskdef resource="net/sf/antcontrib/antcontrib.properties" classpathref="macrodef.classpath"/>
	<taskdef uri="antlib:org.apache.ant.antunit" resource="org/apache/ant/antunit/antlib.xml" classpathref="macrodef.classpath"/>
	<taskdef name="elopeif" classname="ise.antelope.tasks.IfTask" classpathref="macrodef.classpath"/>
	<taskdef name="for" classname="net.sf.antcontrib.logic.ForTask" classpathref="macrodef.classpath"/>
	<taskdef name="propertyvalidator" classname="gov.nih.nci.bda.PropertyValidator" classpathref="macrodef.classpath"/>
	<taskdef resource="liquibasetasks.properties" classpathref="macrodef.classpath"/>
	<taskdef name="groovy" classname="org.codehaus.groovy.ant.Groovy" classpathref="macrodef.classpath"/>
	<taskdef name="xmltask" classname="com.oopsconsultancy.xmltask.ant.XmlTask" classpathref="macrodef.classpath"/>

	<xmlcatalog id="installer.catalog">
		<!--
		<dtd 
			publicId="-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
			location="./resources/web-app_2_3.dtd"/>
		-->
	</xmlcatalog>

 	<tstamp>
 		<format property="run.date" pattern="yyMMddHHmm"/>
 	</tstamp>

	<!-- init tasks -->
	<mkdir dir="${temp.dir}"/>
	<property name="database.type" value="mysql"/>
	<switch value="${database.type}">
		<case value="oracle">
			<property name="database.dialect" value="org.hibernate.dialect.OracleDialect"/>
			<property name="is.oracle" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/ojdbc14-10.2.0.3.0.jar "/>
			<property name="database.driver" value="oracle.jdbc.driver.OracleDriver"/>
			<property name="database.schema" value="${database.name}"/>
		</case> 
		<case value="mysql">
			<property name="database.dialect" value="org.hibernate.dialect.MySQLDialect"/>
			<property name="is.mysql" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/mysql-connector-java-5.0.5.jar"/>
			<property name="database.driver" value="com.mysql.jdbc.Driver"/>
			<property name="database.schema" value="${database.name}"/>
		</case> 
		<case value="postgresql">
			<property name="database.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
			<property name="is.postgresql" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/postgresql-jdbc3-8.3-603.jar"/>
			<property name="database.driver" value="org.postgresql.Driver"/>
			<property name="database.schema" value="public"/>
			<!-- 
				driver = org.postgresql.Driver
				url = jdbc:postgresql://localhost/mydatabase
			-->
		</case> 
		<case value="hsqldb">
			<property name="database.dialect" value=""/>
			<property name="is.mysql" value="true"/>
			<property name="database.driver.file" value="${bda-utils.dir}/hsqldb-1.8.0.7.jar"/>
		</case> 
		<default>  
			<fail message="Invalid or unsupported database type ${database.type}"/>
		</default> 
	</switch>
	<path id="jdbc.driver.classpath">
		<pathelement location="${database.driver.file}"/>
	</path>

	
	<!-- run-junit-tests macro runs the unit test cases  
	usage: <run-junit-tests test.src.dir="${test.src.dir}" xml.output.dir="${target.dir}/junit" instrumented.classes="${instrumented.classes.dir}" classpath="${caarray-client.test.classes.dir};${test.data.files.dir};${test.classes.dir};${commons-lang.jar};${commons-io.jar};${caarray-client.test.files.dir};${caarray-client.classes.dir};${caarray-client.resources.dir};${junit.jar};${nci-commons-core.jar}" />
	-->
	<macrodef name="run-junit-tests">
		<attribute name="test.src.dir" />
		<attribute name="xml.output.dir" />
		<attribute name="classpath" default="" />
		<attribute name="instrumented.classes" default="" />

		<sequential>
			<mkdir dir="@{xml.output.dir}" />
			<junit printsummary="on" failureproperty="junit.failure" fork="true" forkmode="once" maxmemory="256m">
				<sysproperty key="net.sourceforge.cobertura.datafile" file="${cobertura.file}" />
				<sysproperty key="server.hostname" value="${jboss.server.hostname}" />
				<sysproperty key="server.port" value="${jboss.server.port}" />
				<sysproperty key="server.jndi.port" value="${jboss.server.jndi.port}" />
				<sysproperty key="selenium.server.port" value="${selenium.server.port}" />

				<classpath>
					<pathelement path="@{instrumented.classes}" />
					<pathelement path="@{classpath}" />
					<path refid="cobertura.classpath" />
				</classpath>
				<formatter type="xml" />
				<batchtest todir="@{xml.output.dir}">
					<fileset dir="@{test.src.dir}">
						<include name="**/*Test.java" />
						<exclude name="**/Abstract*Test.java" />
					</fileset>
				</batchtest>
			</junit>
		</sequential>
	</macrodef>

	<!-- run-sql-script macro executes the sql scripts for a database 
	usage: <run-sql-script database.url="${database.url}" database.user="${database.user}" database.password="${database.password}" sql.file="${sql.dir}/create_table.sql" /> 
	-->
	<macrodef name="run-sql-script" description="By default this will use the database.url, to use drop database &amp; user use the database.system.url property">
		<attribute name="sql.file" />
		<attribute name="sql.delimiter" default=";" />
		<attribute name="sql.delimitertype" default="normal" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="onerror" default="abort" />
		<sequential>
			<sql driver="${database.driver}" url="@{database.url}" userid="@{database.user}" password="@{database.password}" src="@{sql.file}" onerror="@{onerror}" autocommit="true" delimiter="@{sql.delimiter}" delimitertype="@{sql.delimitertype}" keepformat="true">
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
			</sql>
		</sequential>
	</macrodef>

	<!-- remote-ssh macro is a remote SSH procedure. It will use SSH connection defaults as defined in the environment property file to initiate SSH connections and execure remote unix commands. remoteSshCommand is a mandatory attribute to this macrodef.
	usage: <remote-ssh remotesshcommand="mv ${jboss.temp.dir}/caarray.ear ${jboss.home}/deploy/" /> 
	-->
	<macrodef name="remote-ssh" description="This is a remote SSH procedure. It will use SSH connection defaults as defined in the environment property file to initiate SSH connections and execure remote unix commands. remoteSshCommand is a mandatory attribute to this macrodef.">
		<attribute name="remoteSshCommand" />
		<attribute name="remoteSshPort" default="${ssh.port}" />
		<attribute name="remoteSshHost" default="${ssh.server.hostname}" />
		<attribute name="remoteSshUser" default="${ssh.server.username}" />
		<attribute name="remoteSshKeyfile" default="${ssh.key.file}" />
		<attribute name="remoteSshSleep" default="5" />
		<sequential>
			<sshexec port="@{remotesshport}" host="@{remotesshhost}" username="@{remoteSshUser}" keyfile="@{remoteSshKeyfile}" trust="true" passphrase="" verbose="true" command="@{remotesshcommand}" />
			<sleep seconds="@{remoteSshSleep}" />
			<echo message="Performed @{remoteSshCommand} command on @{remoteSshHost}:@{remoteSshPort} using SSH..." />
		</sequential>
	</macrodef>

	<!-- remote-scp macro copies files in a secure manner using SCP. 
	remoteScpToDir and remoteScpFileToCopy are required attributes to this macrodef
	usage: <remote-scp remoteScpFileToCopy="${caarray.ear}" 
	remoteScpToDir="${ssh.server.username}@${ssh.server.hostname}:${jboss.temp.dir}" />
	-->
	<macrodef name="remote-scp" description="This task copies files in a secure manner using SCP. 
	remoteScpToDir and remoteScpFileToCopy are required attributes to this macrodef.">
		<attribute name="remoteScpFileToCopy" />
		<attribute name="remoteScpToDir" />
		<attribute name="remoteScpKeyFile" default="${ssh.key.file}" />
		<attribute name="remoteScpPassphrase" default="" />
		<attribute name="remoteScpTrust" default="true" />
		<attribute name="remoteScpVerbose" default="true" />
		<attribute name="remoteScpSleep" default="5"  />
		<sequential>
			<scp file="@{remoteScpFileToCopy}" keyfile="@{remoteScpKeyFile}" passphrase="@{remoteScpPassphrase}" trust="@{remoteScpTrust}" verbose="@{remoteScpVerbose}" todir="@{remoteScpToDir}" />
			<sleep seconds="@{remoteScpSleep}" />
			<echo message="Copied @{remoteScpFileToCopy} to @{remoteScpToDir} using SCP..." />
		</sequential>
	</macrodef>

	<!-- 
	jboss-stop-jboss macro will stop the jboss instance
	usage: 	<jboss-start-jboss jboss.home="${jboss.home}"/>
		jboss.home is the location where Jboss is installed
		jboss.server.hostname is the host name where the application server is installed
		jboss.server.jndi.port is the JNDI port on which the server listens
	-->
	<macrodef name="jboss-stop-jboss">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<attribute name="jboss.server.jndi.port" default="${jboss.server.jndi.port}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<attribute name="jboss.web.user" default="admin" />
		<attribute name="jboss.web.password" default="admin" />
		<sequential>
			<available file="@{jboss.home}/server/@{jboss.server.name}/bin" property="jboss.bin.exists"/>
			<if>
				<isset property="jboss.bin.exists"/>
				<then>
					<echo message="Shutting down jboss with stop_jboss"/>
					<exec executable="@{jboss.home}/server/@{jboss.server.name}/bin/stop_jboss" osfamily="unix"/>
				</then>
				<else>
					<echo message="Shutting down jboss with shutdown.jar"/>

					<java classname="org.jboss.Shutdown" fork="true" spawn="false">
						<arg line="-s @{jboss.server.hostname}:@{jboss.server.jndi.port} -u @{jboss.web.user} -p @{jboss.web.password} -S" />
						<classpath>
							<pathelement location="@{jboss.home}/bin/shutdown.jar" />
						</classpath>
					</java>
				</else>
			</if>
			<sleep seconds="15" />
		</sequential>
	</macrodef>

	<!-- 
	jboss-check-if-jboss-is-running macro checks if the jboss server is up and listening
	usage: 	<jboss-check-if-jboss-is-running jboss.server.port="${jboss.server.port}" jboss.server.hostname="${jboss.server.hostname}" jboss.server.jndi.port="${jboss.server.jndi.port}"/>
		jboss.server.port is the http port number of which the web container listens
		jboss.server.hostname is the host name where the application server is installed		
	-->
	<macrodef name="jboss-check-if-jboss-is-running" description="Checks if a local JBoss instance is running">
		<attribute name="jboss.server.port" default="${jboss.server.port}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<sequential>
			<condition property="jboss.running">
				<socket port="@{jboss.server.port}" server="@{jboss.server.hostname}" />
			</condition>
		</sequential>
	</macrodef>

	<!-- 
	jboss-start-jboss macro will start the jboss instance
	usage: 	<jboss-start-jboss jboss.home="${jboss.home}"/>
		jboss.home is the location where Jboss is installed		
	-->
	<macrodef name="jboss-start-jboss" description="Starts a local JBoss instance">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>
			<available file="@{jboss.home}/server/@{jboss.server.name}/bin" property="jboss.bin.exists"/>
			<if>
				<isset property="jboss.bin.exists"/>
				<then>
					<echo message="Starting JBoss instance at @{jboss.home} with start_jboss" />
					<exec executable="@{jboss.home}/server/@{jboss.server.name}/bin/start_jboss" osfamily="unix" />
				</then>
				<else>
					<echo message="Starting JBoss instance at @{jboss.home} with run.sh" />
					<exec osfamily="unix" executable="chmod" spawn="true">
						<arg value="+x" />
						<arg file="@{jboss.home}/bin/run.sh" />
						<arg file="@{jboss.home}/bin/shutdown.sh" />
					</exec>
		
					<exec executable="sh" osfamily="unix" dir="@{jboss.home}/bin" spawn="true">
						<env key="NOPAUSE" value="true" />
						<arg line="run.sh" />
					</exec>

					<exec osfamily="windows" executable="${bda-utils.dir}/resource/psexec.exe" dir="@{jboss.home}/bin" spawn="true" >
						<env key="NOPAUSE" value="true" />
						<arg line="-d -i -w @{jboss.home}/bin @{jboss.home}/bin/run.bat" />
					</exec>
					<sleep seconds="15" />
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	jboss-update-shutdown macro updates the shutdown.jar with the host and jndi port information
	usage: 	<jboss-update-runconf jboss.home="${jboss.home}" jboss.server.hostname="${jboss.server.hostname}" jboss.server.jndi.port="${jboss.server.jndi.port}"/>
		jboss.home is the location where Jboss is installed
		jboss.server.hostname is the host name where the application server is installed
		jboss.server.jndi.port is the JNDI port on which the server listens
	-->
	<macrodef name="jboss-update-shutdown" description="Update the shutdown.jar ">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}" />
		<attribute name="jboss.server.jndi.port" default="${jboss.server.jndi.port}" />
		<sequential>
			<delete dir="${temp.dir}/shutdown"/>
			<unzip src="@{jboss.home}/bin/shutdown.jar" dest="${temp.dir}/shutdown" />
			<replaceregexp file="${temp.dir}/shutdown/jndi.properties" byline="true"
				match="^(java.naming.provider.url)=(.*)"
				replace="\1=jnp://@{jboss.server.hostname}:@{jboss.server.jndi.port}"/>
			
			<jar jarfile="${temp.dir}/shutdown/shutdown.jar" compress="false" manifest="${temp.dir}/shutdown/META-INF/MANIFEST.MF">
				<fileset dir="${temp.dir}/shutdown">
					<include name="*/**" />
				</fileset>
			</jar>
			<copy file="${temp.dir}/shutdown/shutdown.jar" todir="@{jboss.home}/bin" overwrite="true"/>
		</sequential>
	</macrodef>
	
	<!-- 
	jboss-update-runconf macro updates the configuration of run.conf and sets the desired JAVA_OPTS
	usage: 	<jboss-update-runconf jboss.home="${jboss.home}" jboss.java.opts="${jboss.java.opts}"/>
		jboss.home is the location where Jboss is installed
		jboss.java.opts are the desired java options for the application server
	-->
	<macrodef name="jboss-update-runconf">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.java.opts" default="${jboss.java.opts}" />
		<sequential>
			<replaceregexp file="${jboss.home}/bin/run.conf" byline="true"
				match="^(\s+JAVA_OPTS)=(.*)"
				replace="\1='@{jboss.java.opts}'"/>
		</sequential>
	</macrodef>

	<!-- 
	validate-pre-install macro is a wrapper for all the pre-install validations and would vaildate for the environment, properties and directory structure of the host before application installation
	usage: 	<validate-pre-install />
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database		
		database.name is the name of the database
		database.url is the url of the database where it is hosted
		database.user is the user of the database
		database.password is the password of the user for the database
		validate-ports-preinstall is the list of comma seperated port numbers		
		ant.check.version is the version of ant. By default the ant version should be greater than 1.7.0
		java.check.version.major is the major version of java. By default the major version should be greater than 1.5
		java.check.version.minor is the minor version of java. By default the minor version should be greater than 1.5.0_10
		The property.template.file is the template file to compare with
		The envpropertyfile is the properties file to be compared to
	-->
	<!-- System Diagnostics  -->
	<macrodef name="validate-pre-install" description="Diagnose the host system before the installation">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
 		<attribute name="validation.pre.port.list" default="${validation.pre.port.list}" />
		<attribute name="ant.check.version" default="1.7.0" />
		<attribute name="java.check.version.major" default="1.5" />
		<attribute name="java.check.version.minor" default="1.5.0_10" />
		<attribute name="property.template.file" default="${properties.template.file}"/>
		<attribute name="envpropertyfile" default="${properties.file}"/>
		<attribute name="jboss.ssl.enable" default="${jboss.ssl.enable}"/>
		<attribute name="jboss.ssl.keystore.file" default="${jboss.ssl.keystore.file}"/>
		<attribute name="jboss.ssl.keystore.dir" default="${jboss.ssl.keystore.dir}"/>
		<attribute name="jboss.ssl.keystore.pass" default="${jboss.ssl.keystore.pass}"/>
		<attribute name="jboss.ssl.keystore.alias" default="${jboss.ssl.keystore.alias}"/>
		<attribute name="jboss.ssl.fullyqualified.hostname" default="${jboss.ssl.fullyqualified.hostname}"/>
		<attribute name="tomcat.ssl.enable" default="${tomcat.ssl.enable}"/>
		<attribute name="tomcat.ssl.keystore.file" default="${tomcat.ssl.keystore.file}"/>
		<attribute name="tomcat.ssl.keystore.dir" default="${tomcat.ssl.keystore.dir}"/>
		<attribute name="tomcat.ssl.keystore.pass" default="${tomcat.ssl.keystore.pass}"/>
		<attribute name="tomcat.ssl.keystore.alias" default="${tomcat.ssl.keystore.alias}"/>
		<attribute name="tomcat.ssl.fullyqualified.hostname" default="${tomcat.ssl.fullyqualified.hostname}"/>
		<attribute name="jboss.binaries.relative.dir" default="${jboss.binaries.relative.dir}"/>
		<attribute name="tomcat.binaries.relative.dir" default="${tomcat.binaries.relative.dir}"/>
		<sequential>
			<validate-environment
				ant.check.version="@{ant.check.version}"
				java.check.version.major="@{java.check.version.major}"
				java.check.version.minor="@{java.check.version.minor}"
				/>
			<validate-database
				database.driver="@{database.driver}"
				database.system.url="@{database.system.url}"
				database.system.user="@{database.system.user}"
				database.system.password="@{database.system.password}"
				database.url="@{database.url}"
				database.user="@{database.user}"
				database.password="@{database.password}"
				database.version="@{database.version}"
				database.name="@{database.name}"
				/>
			<validate-properties/>
			<compare-properties
				property.template.file="@{property.template.file}"
				envpropertyfile="@{envpropertyfile}"
				/>
			<check-absolute-directory
				directory.property="application.base.path"
				/>

			<check-direct-child-directory
				parent.dir.property="application.base.path"
				child.dir.property="jboss.home"
				/>
			<check-not-child-directory
				parent.dir.property="application.base.path"
				child.dir.property="basedir"
				/>
			<check-valid-directory-name
				directory.property="application.base.path"
				/>
			<check-application-exists
				application.dir.property="jboss.home"
				/>
			<check-database-exists
				database.driver="@{database.driver}"
				database.url="@{database.url}"
				database.user="@{database.user}"
				database.password="@{database.password}"
				database.name="@{database.name}"
				/>
			<verify-keystore
				appserver.ssl.enable="@{jboss.ssl.enable}"
				appserver.ssl.keystore.file="@{jboss.ssl.keystore.file}"
				appserver.ssl.keystore.pass="@{jboss.ssl.keystore.pass}"
				appserver.ssl.keystore.alias="@{jboss.ssl.keystore.alias}"
				appserver.ssl.fullyqualified.hostname="@{jboss.ssl.fullyqualified.hostname}"
				appserver.ssl.keystore.dir="@{jboss.ssl.keystore.dir}"
				/>
			<verify-keystore
				appserver.ssl.enable="@{tomcat.ssl.enable}"
				appserver.ssl.keystore.file="@{tomcat.ssl.keystore.file}"
				appserver.ssl.keystore.pass="@{tomcat.ssl.keystore.pass}"
				appserver.ssl.keystore.alias="@{tomcat.ssl.keystore.alias}"
				appserver.ssl.fullyqualified.hostname="@{tomcat.ssl.fullyqualified.hostname}"
				appserver.ssl.keystore.dir="@{tomcat.ssl.keystore.dir}"
				/>
			<validate-appserver-versions
				jboss.binaries.relative.dir="@{jboss.binaries.relative.dir}"
				tomcat.binaries.relative.dir="@{tomcat.binaries.relative.dir}"
				/>
		</sequential>
	</macrodef>

	<!-- 
	validate-environment macro validates host environment i.e the version of the installed ant, jdk.
	usage: 	<validate-environment ant.check.version="1.7.0" java.check.version.major="1.5" java.check.version.minor="1.5.0_10"/>
		ant.check.version is the version of ant. By default the ant version should be greater than 1.7.0
		java.check.version.major is the major version of java. By default the major version should be greater than 1.5
		java.check.version.minor is the minor version of java. By default the minor version should be greater than 1.5.0_10	
	-->
	<macrodef name="validate-environment" description="Diagnose the host system before the installation">
		<attribute name="ant.check.version" default="1.7.0" />
		<attribute name="java.check.version.major" default="1.5" />
		<attribute name="java.check.version.minor" default="1.5.0_10" />
		<sequential>
			<!-- Echo the properties for diagnostic purposes -->
			<echoproperties/>
			<!-- Validate Ant version is 1.7.x -->
			<echo message="Validating Ant version..." />
			<condition property="ant.version.success">
				<antversion atleast="@{ant.check.version}" />
			</condition>
			<antunit:assertPropertyEquals name="ant.version.success" value="true" />
			<echo message="Ant Version: PASSED" />

 			<echo message="Validating Java version..."/>
 			<condition property="java.major.version.good">
				<equals arg1="${ant.java.version}" arg2="@{java.check.version.major}" />
 			</condition>
 			<antunit:assertTrue message="${line.separator}${line.separator}    Your Java SDK version must be 1.5 (1.5.0_10 recommended). The version you have installed is ${java.version}. Please install the correct version of the Java SDK and update your System PATH to point to directory where you installed it. ${line.separator}">
 				<isset property="java.major.version.good"/>
 			</antunit:assertTrue>
			<if>
				<equals arg1="${java.version}" arg2="@{java.check.version.minor}" />
				<then>
					<echo message="Java version check: PASSED" />
				</then>
				<else>
					<echo message="Java version check: WARNING, version is not 1.5.0_10" />
				</else>
			</if>
 			<echo message="Java version check: PASSED" /> 

			<!-- Checks if user running build is root, if so it fails -->
			<if>
				<equals arg1="${user.name}" arg2="root"/>
				<then>
					<fail message="Cannot run build as root."/>
				</then>
				<else>
					<echo message="Not running as root."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	validate-properties macro validates the property values in the property file. The checks include if an REPLACE are left and fails the build,compares database system user and databases users are the same,Checks that hostnames are reachable.
	usage: 	<validate-properties />
		properties.file property should be set before calling this macro		
	-->
	<macrodef name="validate-properties" description="Diagnose the host system before the installation">
		<sequential>
			<!-- Validate properties, checks if an REPLACE are left and fails the build -->
			<if>
				<isset property="properties.file"/>
				<then>
					<echo message="Validating properties file  ${properties.file}..."/>
					<loadfile
						property="fail.properties"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="REPLACE"/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="fail.properties"/>
						<then>
							<echo message="Property file validation: FAILED 'replace' found in file"/>
							<echo message="${fail.properties}"/>
							<fail message="Some properties still have 'REPLACE' in them. These properties require valid values. Please update ${properties.file} and run the installer again. " />
						</then>
					</if>
				</then>
				<else>
					<echo message="Warning: properties.file property is not set"/>
				</else>	
			</if>
			<if>
				<isset property="properties.file"/>
				<then>
					<loadfile
						property="warn.properties"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern="replace"/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="warn.properties"/>
						<then>
							<echo message="Some properties still have 'replace' in them, this may cause issues."/> 
							<echo message="${warn.properties}"/>
						</then>
					</if>
				</then>
				<else>
					<echo message="Properties file validation: PASSED"/>
				</else>	
			</if>
			
			<!-- Validate database properties, compares database.system.user to other *databases.*.user  -->
			<if>
				<and>
					<isset property="properties.file"/>
					<isset property="database.system.user"/>
				</and>
				<then>
					<loadfile
						property="all.match.property"
						srcFile="${properties.file}">
						<filterchain>
							<linecontainsregexp>
								<regexp pattern=".*database.*user=${database.system.user}\r*\n"/> 
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="all.match.property"/>
						<then>
							<for list="${all.match.property}" delimiter="${line.separator}" param="matches.line">
								<sequential>
									<echo message="Evaluating line in properties file = @{matches.line}"/>
									<property name="match.tmp" value="@{matches.line}"/>
									<propertyregex property="is.system.user"
										input="${match.tmp}"
										regexp="database.system.user.*"
										select="true"
										/>
									<if>
										<isset property="is.system.user"/>
										<else>
											<fail message="${line.separator}    The above line in the properties file uses the same user as the database.system.user. This will cause problems creating the database. Please change the mentioned property value to something other than ${database.system.user} and run the install again."/>
										</else>
									</if>
								</sequential>
							</for>
						</then>
						<else> 
							<echo message="No other users match database.system.user = ${database.system.user}"/>
						</else>
					</if>
				</then>
			</if>
			<!-- Checks that hostnames are reachable, does not fail build, just prints message -->
			<if>
				<isset property="properties.file"/>
				<then>
					<propertyselector property="hostname.property.list"
						delimiter=","
						match="^(.*hostname)$"
						select="\1"              
						casesensitive="true" /> 

					<if>
						<isset property="hostname.property.list"/>
						<then>
							<for list="${hostname.property.list}"  param="hostname.property" >
								<sequential>
		 							<propertycopy name="hostname.value" from="@{hostname.property}" />
									<echo message="Attempting to connnect to ${hostname.value}...."/>
									<var name="hostname.has.value" value="false"/>
									<propertyregex property="hostname.has.value"
										input="@{hostname.value}"
										regexp="\S+"
										select="true"
										/>
									<if>
										<equals arg1="${hostname.has.value}" arg2="true"/>
										<then>
											<if>
												<isreachable host="${hostname.value}" timeout="5"/>
												<then>
													<echo message="${hostname.value} reached. (@{hostname.property})"/>
												</then>
												<else>
													<echo message="Could not reach host from property @{hostname.property} with value of ${hostname.value}"/>
												</else>
											</if>
										</then>
									</if>
								</sequential>
							</for>
						</then>
					</if>
				</then>
			</if>
		</sequential>
	</macrodef>
			
	<!-- 
	validate-ports-preinstall macro validates whether the host listens on provided list of comma seperated ports 
	usage: 	<validate-ports-preinstall validate-ports-preinstall="${validate-ports-preinstall}" hostname="${jboss.server.hostname}" />
		validate-ports-preinstall is the list of comma seperated port numbers
		hostname is the host name of the machine e.x.localhost
	-->
	<macrodef name="validate-ports-preinstall" description="Diagnose the host system before the installation">
		<attribute name="validation.pre.port.list" default="${validation.pre.port.list}" />
		<attribute name="hostname" default="${jboss.server.hostname}" />
		<sequential>
			<!-- Validate ports are not listening -->
			<if>
				<and>
					<isset property="validation.pre.port.list"/>
					<not>
						<isset property="jboss.port.configuration"/>
					</not>
				</and>
				<then>
 					<echo message="Validationg Ports Are not in use..."/>
 					<for list="@{validation.pre.port.list}" param="validate.port">
						<sequential>
				 			<echo message="Checking if @{validate.port} is running."/>
							<if>
				 				<socket server="@{hostname}" port="@{validate.port}" />
								<then>
									<fail message="${line.separator}${line.separator}    Port is listening at @{hostname}:@{validate.port}.${line.separator}Verify the JBoss server is not running at @{hostname}:@{validate.port}. If it is not, there may be a different process or application using this port (@{validate.port}).  You can either change the port this application uses by updating your *-install.properties file or change your other application to resolve this issue and continue installing."/>
 								</then>
								<else>
									<echo message="Ports check: PASSED" /> 
								</else>
							</if>
						</sequential>
					</for>
				</then>
			</if>
		</sequential>
	</macrodef>
 			
	<!-- 
	check-direct-child-directory macro checks the child directory is the child of the parent directory
	usage: 	<check-direct-child-directory parent.dir.property="application.base.path" child.dir.property="jboss.home" />
		parent.dir.property is the property for the parent directory
		child.dir.property is the property for the child directory
	-->
	<macrodef name="check-direct-child-directory" description="Diagnose the host system before the installation">
		<attribute name="parent.dir.property" />
		<attribute name="child.dir.property" />
		<sequential>
			<!-- Application.base.path compare to Jboss.home -->
			<propertycopy name="child.dir" from="@{child.dir.property}" />
			<propertycopy name="parent.dir" from="@{parent.dir.property}" />
			<propertyregex property="child.good"
				input="${child.dir}"
				regexp="${parent.dir}[\\/][\d\w\.\-\_]+"
				select="true"
				/>
			<if>
				<isset property="child.good"/>
				<then>
					<echo message="@{child.dir.property}=${child.dir} is direct child of @{parent.dir.property}=${parent.dir}."/>
				</then>
				<else>
					<echo message="@{child.dir.property}=${child.dir} is not a direct child of @{parent.dir.property}=${parent.dir}."/>
					<fail message="@{child.dir.property} needs to be direct child of @{parent.dir.property}, please update the properties file and retry the build."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	check-not-child-directory macro checks the parent and child directories do not have the same name
	usage: 	<check-not-child-directory parent.dir.property="application.base.path" child.dir.property="basedir" />
		parent.dir.property is the property for the parent directory
		child.dir.property is the property for the child directory
	-->
	<macrodef name="check-not-child-directory" description="Diagnose the host system before the installation">
		<attribute name="parent.dir.property" />
		<attribute name="child.dir.property" />
		<sequential>
			<!-- Application.base.path compare basedir -->
			<propertycopy name="not.child.dir" from="@{child.dir.property}" />
			<propertycopy name="not.parent.dir" from="@{parent.dir.property}" />
			<propertyregex property="child.bad"
				input="${not.child.dir}"
				regexp="${not.parent.dir}"
				select="true"
				/>
			<if>
				<isset property="child.bad"/>
				<then>
					<echo message="@{child.dir.property}=${not.child.dir} is child of @{parent.dir.property}=${not.parent.dir}."/>
					<fail message="@{child.dir.property} cannt be be direct child of @{parent.dir.property}, please update the properties file and retry the build."/>
				</then>
				<else>
					<echo message="@{child.dir.property}=${not.child.dir} is not child of @{parent.dir.property}=${not.parent.dir}."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	check-valid-directory-name macro checks for the possible combinations of the directories and should be called before deleting any directories
	usage: <check-valid-directory-name directory.property="jboss.home" />
		directory.property is the property for the directory to be checked
	-->
	<macrodef name="check-valid-directory-name" description="Diagnose the host system before the installation">
		<attribute name="directory.property" />
		<sequential>
			<!-- Application.base.path check for bad directory -->
			<propertycopy name="directory.value" from="@{directory.property}" />
			<propertyregex property="has.spaces"
				regexp="\s+"
				input="${directory.value}"
				select="\1"
				/>
			<if>
				<isset property="has.spaces"/>
				<then>
					<fail message="@{directory.property} is using directory that space in the name, this is not supported by our current build process.  Please chose another diretory name without a space in it."/>
				</then>
			</if>

			<!-- Application.base.path check for bad directory -->
			<propertyregex property="directory.bad"
				regexp="^(\w:[\/\\])$"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\w:[\\\/]win.*)"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\w:[\\\/]WIN.*)"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\/)$"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="directory.bad"
				regexp="^(\/usr)$"
				input="${directory.value}"
				select="\1"
				/>
			<!-- Relax this one for local installs
			<propertyregex property="directory.bad"
				regexp="^(\/usr\/local)$"
				input="${directory.value}"
				select="\1"
				/>
			-->
			<propertyregex property="directory.bad"
				regexp="^(\/opt)$"
				input="${directory.value}"
				select="\1"
				/>
			<if>
				<isset property="directory.bad"/>
				<then>
					<fail message="@{directory.property} is set to or includes '${directory.bad}, this is not allowed.  As part of the install proces the first thing we do is delete this directory.  Deleting the directory you specified may cause system issues, please chose another directory."/>
				</then>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	check-application-exists macro checks if the application exists. The property where the applications is installed should be priovided as input
	usage: <check-application-exists application.dir.property="jboss.home" />
		application.dir.property is the property for the installation directory of the application
	-->
	<macrodef name="check-application-exists" description="Diagnose the host system before the installation">
		<attribute name="application.dir.property" />
		<sequential>
			<!-- If jboss.home exists prompt to conntinue -->
			<propertycopy name="application.dir" from="@{application.dir.property}" />
			<available property="${application.dir.exists}" file="${application.dir}"/>
			<if>
				<and>
					<isset property="application.dir.exists"/>
					<not>
						<isset property="force.reinstall"/>
					</not>
				</and>
				<then>
					<input message="The @{application.dir.property} (${application.dir}) already exists.  Please be sure you have a recent backup of this directory.  This process will alter files in this path and any customizations you have could be lost.  Do you want to proceed?"
						validargs="y,n"
						addproperty="accept.application.dir.update" />
					<if>
						<equals arg1="${accept.application.dir.update}" arg2="n"/>
						<then>
							<fail message="User tereminated the build."/>
						</then>
					</if>
				</then>
				<else>
					<echo message="@{application.dir.property} ${application.dir} does not exist or the force.reinstall property is set."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	check-database-exists macro checks if the database exists. The root user name and password should be provided
	usage: <check-database-exists database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password} database.name="${database.name}" />
		database.driver is the jdbc driver to connect to database
		database.url is the installed host of the database
		database.user is the user for the database
		database.password is the password for the database		
		database.name is the name of the database
	-->
	<macrodef name="check-database-exists" description="Checks if the database exists">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.name" default="${database.name}" />
		<sequential>
			<switch value="${database.type}">
				<case value="mysql">	
					<dbconfig property="database.exists" 
						driver="@{database.driver}" url="@{database.url}"  user="@{database.user}" password="@{database.password}">
						<validate />
					</dbconfig>
					<echo message="Does @{database.name} exist = ${database.exists} "/>
					<if>
						<and>
							<equals arg1="${database.exists}" arg2="true"/>
							<not>
								<isset property="force.reinstall"/>
							</not>
						</and>
						<then>
							<input message="The database @{database.name} already exists.  Please be sure you have a recent backup of this database.  This process will alter the database if you need to return your database to the current state you need a good backup.  Please ensure you have a good backup before proceeding.  Do you want to proceed?"
								validargs="y,n"
								addproperty="accept.database.update" />
							<if>
								<equals arg1="${accept.database.update}" arg2="n"/>
								<then>
									<fail message="User tereminated the build."/>
								</then>
								<else>
									<property name="force.reinstall" value="true"/>
								</else>
							</if>
						</then>
						<else>
							<echo message="Database @{database.name} does not exist or the force.reinstall property is set."/>
							<property name="force.reinstall" value="true"/>
						</else>
					</if>
				</case>
				<default>
					<echo message="Database is ${database.type}, warning prompt not displayed."/>
					<property name="force.reinstall" value="true"/>
				</default>
			</switch>
		</sequential>
	</macrodef>

	<!-- 
	validate-post-install macro Diagnose the host system after the installation
	usage: <validate-post-install validation.post.http.list="${validation.post.http.list}" validation.post.socket.list="${validation.post.socket.list}" jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}"/>
		validation.post.http.list is the list of all comma seperated ports numbers 
		validation.post.socket.list is the list of all comma seperated sockets
		jboss.home is the location where Jboss is installed
		jboss.server.name is the name of the deployed Jboss server 
	-->
	<macrodef name="validate-post-install" description="Diagnose the host system after the installation">
 		<attribute name="validation.post.http.list" default="${validation.post.http.list}" />
 		<attribute name="validation.post.socket.list" default="${validation.post.socket.list}" />
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<attribute name="application.url" default="${application.url}" />
		<attribute name="propertyfile.backup.location" default="${jboss.home}" />		
		<sequential>

			<!-- Echo the properties for diagnostic purposes -->
			<echoproperties/>

			<!-- Give JBOSS another couple of seconds to come up -->
			<waitfor maxwait="90" maxwaitunit="second" checkevery="5" checkeveryunit="second">
				<http url="${application.url}"/>
			</waitfor>

			<if>
				<and>
					<isset property="validation.post.port.list"/>
					<not>
						<isset property="jboss.port.configuration"/>
					</not>
				</and>
				<then>
					<validate-ports-postinstall  
						validation.post.http.list="@{validation.post.http.list}"
						validation.post.socket.list="@{validation.post.socket.list}"
						/>
				</then>
			</if>
			<validate-jboss-logs-postinstall
				jboss.home="@{jboss.home}"
				jboss.server.name="@{jboss.server.name}"
			/>

			<!-- Send test message if smtp proeprties are set
			<if>
				<and>
					<isset property="mail.smtp.host"/>
					<isset property="mail.smtp.port"/>
					<isset property="validation.email.from"/>
					<isset property="validation.email.to"/>
				</and>
			<then>
				<if>
						<socket port="${mail.smtp.port}" server="${mail.smtp.host}" />
					<then>
						<echo message="Able to connect to smpt host on port."/>
					</then>
					<else>
						<echo message="Failed to connnect to ${mail.smtp.host}:${mail.smtp.port}"/>
					</else>
				</if>
				<echo message="Sending Test message- look for errors below"/>
				<mail mailhost="${mail.smtp.host}" mailport="${mail.smtp.port}" subject="Test Message" failonerror="false">
					<from address="${validation.email.from}"/>
					<to address="${validation.email.to}"/>
				<message>Attempting install of ${project.name} ${env.USER}@${env.HOSTNAME} at ${run.date}.</message>
				</mail>
			</then>
			</if>
			-->
			<echo message="******* INSTALLATION COMPLETED SUCESSFULLY *******"/>
			<echo message="${line.separator}To view your application goto ${application.url}."/>
			<tstamp>
				<format property="run.date" pattern="yyMMddHHmm"/>
			</tstamp>
			<basename file="${properties.file}" property="properties.file.name"/>
			<property name="backup.properties.file" value="${properties.file.name}-${run.date}"/>
			<copy tofile="@{propertyfile.backup.location}/${backup.properties.file}" file="${properties.file}"/>

		</sequential>
	</macrodef>

	<!-- 
	validate-ports-postinstall macro checks if the application listens on the specified port numbers and is part of postinstall checks
	usage: <validate-ports-postinstall validation.post.http.list="${validation.post.http.list}" validation.post.socket.list="${validation.post.socket.list}" hostname="${jboss.server.hostname}" />
		validation.post.http.list is the list of all comma seperated ports numbers 
		validation.post.socket.list is the list of all comma seperated sockets
		hostname is the deployed host ex. localhost
	-->
	<macrodef name="validate-ports-postinstall" description="Diagnose the host system after the installation">
		<attribute name="validation.post.http.list" default="${validation.post.http.list}" />
		<attribute name="validation.post.socket.list" default="${validation.post.socket.list}" />
		<attribute name="hostname" default="${jboss.server.hostname}" />
		<sequential>
			<!-- For each http port call validate:post:http -->
			<for list="${validation.post.http.list}" param="validate.port">
				<sequential>
					<echo message="Checking if @{validate.port} is running."/>
					<if>
						<http url="http://@{hostname}:@{validate.port}" />
						<then>
							<echo message="Port is @{validate.port} RUNNNING as expected."/>
						</then>
						<else>
							<echo message="Port is not responding or giving an HTTP error code @{hostname}:@{validate.port}. You may experience problems using the application."/>
						</else>
					</if>
				</sequential>
			</for>

			<!-- For each socket port call validate:post:socket -->
			<if>
			<isset property="validation.post.socket.list"/>
				<then>
					<for list="${validation.post.socket.list}" param="validate.port" >
						<sequential>
							<echo message="Checking if @{validate.port} is running."/>
							<if>
								<socket server="@{hostname}" port="@{validate.port}" />
								<then>
									<echo message="Port is @{validate.port} RUNNNING as expected."/>
								</then>
								<else>
									<echo message="Unable to reach @{hostname}:@{validate.port}. You may experience problems using the application."/>
								</else>
							</if>
						</sequential>
					</for>
				</then>	
			</if>
		</sequential>
	</macrodef>

	<!-- 
	validate-jboss-logs-postinstall macro is part of postinstall checks and parses the the jboss server.log and boot.log for any warning and errors after the installation.
	usage: <validate-jboss-logs-postinstall jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}" />
		jboss.home is the location where Jboss is installed
		jboss.server.name is the name of the deployed Jboss server 
	-->
	<macrodef name="validate-jboss-logs-postinstall" description="Diagnose the host system after the installation">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.server.name" default="${jboss.server.name}" />
		<sequential>
			<!-- Process jboss server.log for errors and warnings and display on screen -->
			<property name="server.log" value="@{jboss.home}/server/@{jboss.server.name}/log/server.log"/>
			<property name="boot.log" value="@{jboss.home}/server/@{jboss.server.name}/log/boot.log"/>
			<available property="server.log.exists" file="${server.log}"/>
			<available property="boot.log.exists" file="${boot.log}"/>
			<if>
				<isset property="server.log.exists"/>
				<then>
					<loadfile
						property="log.server.errors"
						srcFile="${server.log}">
						<filterchain>
							<filterreader classname="org.apache.tools.ant.filters.TailFilter">
								<param name="lines" value="10000"/>
							</filterreader>
							<linecontainsregexp>
								<regexp pattern="^\w+.* ERROR "/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.server.errors"/>
						<then>
							<echo message="The following are ERRORS from the ${server.log}."/>
							<echo message="${log.server.errors}"/>
						</then>
					</if>
			
					<loadfile
						property="log.server.warnings"
						srcFile="${server.log}">
						<filterchain>
							<filterreader classname="org.apache.tools.ant.filters.TailFilter">
								<param name="lines" value="10000"/>
							</filterreader>
							<linecontainsregexp>
								<regexp pattern="^\w+.* WARN "/>
							</linecontainsregexp>
	
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.server.warnings"/>
						<then>
							<echo message="${line.separator}The following are WARNINGS from the ${server.log}."/>
							<echo message="${log.server.warnings}"/>
						</then>
					</if>
				</then>
			</if>
	
			<!-- Process jboss boot.log for errors and warnings and display on screen -->
			<if>
				<isset property="boot.log.exists"/>
				<then>
					<loadfile
						property="log.boot.errors"
						srcFile="${boot.log}">
						<filterchain>
							<filterreader classname="org.apache.tools.ant.filters.TailFilter">
								<param name="lines" value="10000"/>
							</filterreader>
							<linecontainsregexp>
								<regexp pattern="^\w+.* ERROR "/>
							</linecontainsregexp>
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.boot.errors"/>
						<then>
							<echo message="The following are ERRORS from the ${boot.log}."/>
							<echo message="${log.boot.errors}"/>
						</then>
					</if>
			
					<loadfile
						property="log.boot.warnings"
						srcFile="${boot.log}">
						<filterchain>
							<filterreader classname="org.apache.tools.ant.filters.TailFilter">
								<param name="lines" value="10000"/>
							</filterreader>
							<linecontainsregexp>
								<regexp pattern="^\w+.* WARN "/>
							</linecontainsregexp>
			
						</filterchain>
					</loadfile>
					<if>
						<isset property="log.boot.warnings"/>
						<then>
							<echo message="${line.separator}The following are WARNINGS from the ${boot.log}."/>
							<echo message="${log.boot.warnings}"/>
						</then>
					</if>
				</then>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	database-create macro create the mysql database and user and grant priledges to the user
	usage: <database-create database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password} database.name="${database.name}" database.url="${database.url}" database.password="${database.password}"/>
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database		
		database.name is the name of the database
		database.url is the url of the database where it is hosted
		database.user is the user of the database
		database.password is the password of the user for the database
	-->
	<macrodef name="database-create">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
		<attribute name="database.server" default="${database.server}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<sequential>
			<echo message="Entering database-create"/>
			<if>
				<isset property="force.reinstall"/>
				<then>
					<echo message="Creating ${database.type} database named ${database.name}."/>
					<switch value="${database.type}">
						<case value="mysql">
							<echo message="Database @{database.name} does not exist or the force.reinstall property is set."/>
							<property name="create.sql.dir" value="${bda-utils.resource.dir}/target" />
							<delete dir="${create.sql.dir}"/>
							<sql    
								driver="@{database.driver}"
								url="@{database.system.url}"
								userid="@{database.system.user}"
								password="@{database.system.password}"
								expandproperties="true"
								onerror="continue"
								>
								<classpath>
									<pathelement location="${database.driver.file}" />
								</classpath>
								<transaction>
									REVOKE ALL ON @{database.name}.* FROM '@{database.user}'@'@{database.server}';
									REVOKE ALL ON @{database.name}.* FROM '@{database.user}'@'%';
								</transaction>
							</sql>  
							<sql    
								driver="@{database.driver}"
								url="@{database.system.url}"
								userid="@{database.system.user}"
								password="@{database.system.password}"
								expandproperties="true"
								>
								<classpath>
									<pathelement location="${database.driver.file}" />
								</classpath>
								<transaction>
									DROP DATABASE IF EXISTS @{database.name};
									CREATE DATABASE @{database.name} DEFAULT CHARACTER SET latin1;
									GRANT ALL ON @{database.name}.* TO '@{database.user}'@'@{database.server}' IDENTIFIED BY '@{database.password}';
									GRANT ALL ON @{database.name}.* TO '@{database.user}'@'%' IDENTIFIED BY '@{database.password}';
								</transaction>
							</sql>  
						</case>
						<case value="postgresql">
							<sql    
								driver="@{database.driver}"
								url="@{database.system.url}"
								userid="@{database.system.user}"
								password="@{database.system.password}"
								expandproperties="true"
								onerror="continue"
								autocommit="true"
								>
								<classpath>
									<pathelement location="${database.driver.file}" />
								</classpath>
									drop database if exists ${database.name};
									drop user if exists ${database.user};
									create database ${database.name};
									create user ${database.user} with password '${database.password}';
									grant all on database ${database.name} to ${database.user};
							</sql>  
						</case>
					</switch>
				</then>
			</if>
		</sequential>
	</macrodef>

	
	<!-- 
	validate-database macro validates the creadentials of the provided system user and the installed version of the database
	usage: <validate-database database.driver="${database.driver}" database.system.url="${database.system.url}" database.system.user="${database.system.user}" database.system.password="${database.system.password}" database.version="${database.version}"/>
		database.driver is the jdbc driver to connect to database
		database.system.url is the installed host of the database
		database.system.user is the system user for the database
		database.system.password is the system password for the database
		database.version is the version of the installed database
	-->
	<macrodef name="validate-database">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
		<sequential>
			<!-- Only validates connection for oracle -->
			<if>
				<not>
					<isset property="ignore.check.database"/>
				</not>
				<then>
					<echo message="Validating database connection..." />
					<switch value="${database.type}">
						<case value="mysql">
							<if>
								<isset property="database.re-create"/> 
								<then>
									<dbconfig property="db.connection.success" 
										driver="@{database.driver}" url="@{database.system.url}"  user="@{database.system.user}" password="@{database.system.password}">
										<validate />
										<!--<checkversion atleast="@{database.version}" />-->
									</dbconfig>
									<antunit:assertPropertyEquals message="Database connection failed for @{database.url}. Verify that your database.user and database.password property values are valid in the *-install.properties file.  Your database version must be least @{database.version}" name="db.connection.success" value="true" />
									<echo message="Database Connection: PASSED" />
								</then>
								<else>
									<dbconfig property="db.connection.success" 
										driver="@{database.driver}" url="@{database.url}"  user="@{database.user}" password="@{database.password}">
										<validate />
										<!--<checkversion atleast="@{database.version}" />-->
									</dbconfig>
									<antunit:assertPropertyEquals message="Database connection failed for @{database.url}. Verify that your database.user and database.password property values are valid in the *-install.properties file.  Your database version must be least @{database.version}" name="db.connection.success" value="true" />
									<echo message="Database Connection: PASSED" />
								</else>
							</if>
						</case>
						<case value="oracle">
							<dbconfig property="oracle.connection.success" 
								driver="@{database.driver}"
								url="@{database.url}"
								user="@{database.user}"
								password="@{database.password}">
									<validate />
							</dbconfig>
							<antunit:assertPropertyEquals
								message="Database connection failed for @{database.system.url}. Validate your database related properties in the *-install.properties file."
								name="oracle.connection.success"
							       	value="true" />
							<echo message="Database Connection: PASSED" />
						</case>
						<case value="postgresql">
							<dbconfig property="postgresql.connection.success" 
								driver="@{database.driver}"
								url="@{database.url}"
								user="@{database.user}"
								password="@{database.password}">
									<validate />
									</dbconfig>
							<antunit:assertPropertyEquals
								message="Database connection failed for @{database.system.url}. Validate your database related properties in the *-install.properties file."
								name="postgresql.connection.success"
							       	value="true" />
							<echo message="Database Connection: PASSED" />
						</case>
					</switch>
				</then>
				<else>
					<echo message="Skipped database checkes"/>
				</else>
			</if>
		</sequential>
	</macrodef>


	<!-- 
	tomcat-stop macro stops the tomcat instance and can be used in both linux and windows platforms	
	usage: <tomcat-stop tomcat.home="${tomcat.home}"/>
		The tomcat.home must be set and passed when calling this macro		
	-->
	<macrodef name="tomcat-stop" description="Stops a local tomcat instance">
		<attribute name="tomcat.home" />
		<sequential>
			<echo message="Stopping Tomcat instance at @{tomcat.home}" />
			<exec executable="sh" osfamily="unix" dir="@{tomcat.home}/bin" spawn="true">
				<env key="NOPAUSE" value="true" />
				<arg line="shutdown.sh" />
			</exec>
			<exec osfamily="windows" executable="cmd" dir="@{tomcat.home}/bin" spawn="true" >
				<env key="NOPAUSE" value="true" />
				<arg line="/c shutdown.bat" />
			</exec>
			<sleep seconds="5" />
		</sequential>
	</macrodef>
	
	<!-- 
	tomcat-stop macro starts the tomcat instance and can be used in both linux and windows platforms	
	usage: <tomcat-start tomcat.home="${tomcat.home}"/>
		The tomcat.home must be set and passed when calling this macro		
	-->	
	<macrodef name="tomcat-start" description="Starts a local tomcat instance">
		<attribute name="tomcat.home" />
		<sequential>
			<echo message="Starting Tomcat instance at @{tomcat.home}" />
			<exec executable="sh" osfamily="unix" dir="@{tomcat.home}/bin" spawn="true">
				<env key="NOPAUSE" value="true" />
				<arg line="startup.sh" />
			</exec>
			<exec osfamily="windows" executable="${bda-utils.dir}/resource/psexec.exe" dir="@{tomcat.home}/bin" spawn="true" >
				<env key="NOPAUSE" value="true" />
				<arg line="-d -i -w @{tomcat.home}/bin @{tomcat.home}/bin/startup.bat" />
			</exec>
			<sleep seconds="5" />
		</sequential>
	</macrodef>
	
	<!-- 
	properties-exist macro checks if the value of the property is set in the list of properties seperated by ','
	usage: <properties-exist properties.list="${properties.list}"/>
		The properties.list must be set and passed when calling this macro		
	-->
	<macrodef name="properties-exist" description="Check if the value of the property is set">
		<attribute name="properties.list" />
		<sequential>
			<for list="@{properties.list}" param="prop.list.item" delimiter=",">
				<sequential>
					<echo message="checking for existance of property @{prop.list.item}"/>
					<if>
						<not>
							<isset property="@{prop.list.item}"/>
						</not>
						<then>
							<fail message="Property @{prop.list.item} is not set, it needs to be set, please set it to continue"/>
						</then>
					</if>
				</sequential>
			</for>
		</sequential>
	</macrodef>

	<!-- 
	compare-properties macro checks that there are same number of key for a given property files
	usage: <compare-properties property.template.file="${property.template.file} envpropertyfile="${envpropertyfile} "/>
		The property.template.file is the template file to compare with
		The envpropertyfile is the properties file to be compared to
	-->
	<macrodef name="compare-properties" description="validate the properties from the given files">
		<attribute name="property.template.file" default="${property.template.file}"/>
		<attribute name="envpropertyfile" default="${properties.file}"/>
		<sequential>		
			<echo message="Checking @{envpropertyfile} against template file @{property.template.file}"/>
			<if>
				<available file="@{property.template.file}"/>
				<then>
					<propertyvalidator keyFile="@{property.template.file}"
						compareFile="@{envpropertyfile}"
						match="atleast"
						/>
				</then>
				<else>
					<echo message="Template file @{property.template.file} not avaliable"/>
				</else>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	svn-co macro checks out from a subversion repository based on properties passed to macro, clean the destination directory, then check out the tag specified into the destination directory. 
	The macro assumes that all code required to build the application will be located under the software folder off the project root.  You will not be able to use this macro if you do not adhere to this structure.
	usage: <svn-co svn.project.base.url="${svn.project.base.url}" svn.project.name="${svn.project.name}" svn.tag="${svn.tag}" svn.co.base.dir="${svn.co.base.dir}"/>
		The svn.project.base.url is the URL of Subverion reposition to check out from
		The svn.project.name is the name of the project in the repositiory
		The svn.tag is the tag of the build ex. trunk
		The svn.co.base.dir is the local directory to the checkout
	-->	

	<macrodef name="svn-co" description="based on properties passed to macro, clean the destination directory, then check out the tag specified into the destination directory.">
		<attribute name="svn.checkout.url" />
		<attribute name="svn.checkout.dir"/>
		<attribute name="svn.checkout.user" default="anonymous"/>
		<attribute name="svn.checkout.pass" default=""/>
		<attribute name="delete" default="true"/>
		<sequential>		
			<if>
				<equals arg1="@{delete}" arg2="true" />
				<then>
					<echo message="Scorching temporary checkout directory @{svn.checkout.dir}."/>
					<delete dir="@{svn.checkout.dir}" failonerror="false"/>
					<mkdir dir="@{svn.checkout.dir}"/>
				</then>
			</if>
			<echo message="Checking out @{svn.checkout.url} to @{svn.checkout.dir}."/>
			<svn username="@{svn.checkout.user}" password="@{svn.checkout.pass}">
				<!-- <checkout url="@{svn.checkout.url}" revision="HEAD" destPath="@{svn.checkout.dir}" />-->
				<checkout url="@{svn.checkout.url}"  destPath="@{svn.checkout.dir}" />
			</svn> 
		</sequential>
	</macrodef>

	<macrodef name="svn-add" description="">
		<attribute name="svn.add.dir"/>
		<sequential>		
			<echo message="Adding @{svn.add.dir} to svn."/>
			<svn failonerror="false">
				<add dir="@{svn.add.dir}" force="true"/>
			</svn> 
		</sequential>
	</macrodef>
	<macrodef name="svn-update" description="">
		<attribute name="svn.update.dir"/>
		<sequential>		
			<echo message="Adding @{svn.update.dir} to svn."/>
			<svn failonerror="false">
				<update dir="@{svn.update.dir}"/>
			</svn> 
		</sequential>
	</macrodef>

	<macrodef name="svn-commit" description="">
		<attribute name="svn.commit.dir"/>
		<attribute name="svn.commit.user" default="anonymous"/>
		<attribute name="svn.commit.pass" default=""/>
		<attribute name="svn.commit.message" default="Added by build process"/>
		<sequential>		
			<echo message="Commiting @{svn.commit.dir} to svn."/>
			<svn username="@{svn.commit.user}" password="@{svn.commit.pass}">
				<commit dir="@{svn.commit.dir}" message="@{svn.commit.message}"/>
			</svn> 
		</sequential>
	</macrodef>

	<macrodef name="report-grand" description="generates grand graphs of build.xml files">
		<attribute name="build.file.location" default="build.xml"/>
		<attribute name="output.file.dir" default="."/>
		<attribute name="output.file.name" default="build.xml"/>
		<attribute name="file.type" default="pdf"/>
		<sequential>		
			<property name="grand.output.file" value="${temp.dir}/grand.dot" />
			<grand output="${grand.output.file}" buildfile="@{build.file.location}"/>
			<exec executable="dot" >
				<arg line="-T@{file.type} -Gsize=11.69,8.27 -o @{output.file.dir}/@{output.file.name}.@{file.type} ${grand.output.file}"/>
			</exec>
		</sequential>
	</macrodef>
	
	<!-- 
	jboss-bindings macro configures the binding.xml and the jboss-service.xml which is used by jboss Binding Manager. 	
	usage: <jboss-bindings jboss.home="${jboss.home}" jboss.server.name="${jboss.server.name}" jboss.server.ports.name="${jboss.server.ports.name}" jboss.server.bindingfile.location="${jboss.server.bindingfile.location}"/>
		The jboss.home is the location where Jboss is installed
		The jboss.server.name is the name of the deployed Jboss server 
		The jboss.server.ports.name is the name of the configuration to be used from binding.xml	
		jboss.server.bindingfile.location is the location of the binding.xml
	-->		
	<macrodef name="jboss-bindings" description="configures the binding.xml and the jboss-service.xml">
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="jboss.server.ports.name" default="ports-01"/>
		<attribute name="jboss.server.bindingfile.location" default="${jboss.home}/server/${jboss.server.name}/conf/bindings.xml"/>
		<attribute name="jboss.server.binding.template.location" default="${bda-utils.resource.dir}/template-binding.xml"/>
		<attribute name="jboss.server.service.template.location" default="${bda-utils.resource.dir}/template-jboss-service.xml"/>
		<sequential>						
			<echo message="Bindings file location @{jboss.server.bindingfile.location}"/>
			<copy tofile="@{jboss.server.bindingfile.location}" file="@{jboss.server.binding.template.location}" overwrite="true">
				<filterset>
					<filtersfile file="${properties.file}" />
					<filter token="jboss.server.ports.name" value="@{jboss.server.ports.name}"/>
					<filter token="jboss.server.bindingfile.location" value="@{jboss.server.bindingfile.location}"/>
				</filterset>
			</copy> 
	
			<xmltask source="@{jboss.home}/server/@{jboss.server.name}/conf/jboss-service.xml" dest="@{jboss.home}/server/@{jboss.server.name}/conf/jboss-service.xml">
				<xmlcatalog refid="installer.catalog"/>
				<remove path="/server/mbean[@code='org.jboss.services.binding.ServiceBindingManager']"/>
				<insert path="/server/mbean[@code='org.jboss.util.property.jmx.SystemPropertyClassValue']"
					position="after">
					<![CDATA[
					<mbean code="org.jboss.services.binding.ServiceBindingManager"
						name="jboss.system:service=ServiceBindingManager">
						<attribute name="ServerName">@{jboss.server.ports.name}</attribute>
						<attribute name="StoreURL">file:@{jboss.server.bindingfile.location}</attribute>
						<attribute name="StoreFactoryClassName">
							org.jboss.services.binding.XMLServicesStoreFactory
						</attribute>
					</mbean>
					]]>
				</insert>
			</xmltask>
		</sequential>
	</macrodef>

	<!-- 
	jboss-read-dbconfig macro reads the database information from the application ds.xml and makes connection to the database to check is the application and the database is installed
		usage: <jboss-read-dbconfig jboss.home="${jboss.home} jboss.server.name="${svn.project.name} jboss.ds-xml.file="name if the ds file"/>
			The jboss.home is the location where Jboss is installed
			The jboss.server.name is the name of the deployed Jboss server 
			The jboss.ds-xml.file is the name of the ds.xml file	
	-->
	<macrodef name="jboss-read-dbconfig" description="check if the application is installed">
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="jboss.ds-xml.file"/>
		<attribute name="database.url.property.name" default="database.url" />
		<attribute name="database.name.property.name" default="database.name" />
		<attribute name="database.user.property.name" default="database.user" />
		<attribute name="database.password.property.name" default="database.password" />
		<attribute name="database.server.property.name" default="database.server" />
		<attribute name="database.port.property.name" default="database.port" />
		<sequential>
			<property name="db.property.list" value="@{database.url.property.name},@{database.name.property.name},@{database.user.property.name},@{database.password.property.name},@{database.server.property.name},@{database.port.property.name}"/>
			<echo message="Checking required database properties: ${db.property.list}"/>
			<for list="${db.property.list}" param="prop.list.item" delimiter=",">
				<sequential>
					<echo message="checking for existance of property @{prop.list.item}"/>
					<if>
						<not>
							<isset property="@{prop.list.item}"/>
						</not>
						<then>
							<property name="read.ds.flag" value="true"/>	
						</then>
					</if>
				</sequential>
			</for>
			<available file="@{jboss.home}/server/@{jboss.server.name}/deploy/@{jboss.ds-xml.file}" property="ds.exists"/>
			<if>
				<isset property="read.ds.flag"/>
				<then>
					<if>
						<not>
							<isset property="ds.exists" />
						</not>
						<then>
							<fail message="Some or all required database properties are not set and @{jboss.home}/server/@{jboss.server.name}/deploy/@{jboss.ds-xml.file} is not found.   Ensure arguments passed to this macro are correct or set required database properties in your property file."/>
						</then>
						<else>
						<!--
							<xmlconfig in="@{jboss.home}/server/@{jboss.server.name}/deploy/@{jboss.ds-xml.file}" verbose="false">
								<read path="//datasources/local-tx-datasource/connection-url" property="read.database.url" />
								<read path="//datasources/local-tx-datasource/user-name" property="read.database.user" />
								<read path="//datasources/local-tx-datasource/password" property="read.database.password" />
							</xmlconfig>
						-->
							<xmltask source="@{jboss.home}/server/@{jboss.server.name}/deploy/@{jboss.ds-xml.file}" dest="@{jboss.home}/server/@{jboss.server.name}/deploy/@{jboss.ds-xml.file}">
								<copy path="//datasources/local-tx-datasource/connection-url/text()" property="read.database.url" />
								<copy path="//datasources/local-tx-datasource/user-name/text()" property="read.database.user" />
								<copy path="//datasources/local-tx-datasource/password/text()" property="read.database.password" />
							</xmltask>
						
							<dbconfig property="db.appuser.works" 
										driver="${read.database.driver}"
								url="${read.database.url}"
								user="${read.database.user}"
								password="${read.database.password}">
								<validate />
							</dbconfig>
							<propertyregex property="read.database.name"
								input="${read.database.url}"
								regexp=".*[\/](.*)"
								select="\1"
								/>
							<propertyregex property="read.database.server"
								input="${read.database.url}"
								regexp=".*\/\/(.*):.*"
								select="\1"
								/>
							<propertyregex property="read.database.port"
								input="${read.database.url}"
								regexp=".*:(.*)\/.*"
								select="\1"
								/>
				
							<property name="@{database.url.property.name}" value="${read.database.url}" />
							<property name="@{database.user.property.name}" value="${read.database.user}" />
							<property name="@{database.password.property.name}" value="${read.database.password}" />
							<property name="@{database.name.property.name}" value="${read.database.name}" />
							<property name="@{database.server.property.name}" value="${read.database.server}" />
							<property name="@{database.port.property.name}" value="${read.database.port}" />
							<if>    
								<isset property="db.appuser.works"/>
								<then>  
									<echo message="Read application database configuration from ${jboss.home}/server/${jboss.server.name}/deploy/@{jboss.ds-xml.file}"/>
									<echo  message="Value after read of *-ds.xml: URL- ${database.url}  USER- ${database.user} PASS- ${database.password} NAME- ${database.name} SERVER- ${database.server} PORT- ${database.port}"/>
								</then> 
								<else>  
									<fail  message="Failed to connect to database URL- ${database.url}  USER- ${database.user} PASS- ${database.password} NAME- ${database.name} SERVER- ${database.server} PORT- ${database.port}"/>
								</else>
							</if>
						</else> 
					</if>   
				</then>
			</if>
		</sequential>
	</macrodef>
	
	<!-- 
	svn-getinfo macro gets the latest revision number in the repository for the give path and will set the lsd.revision property
		usage: <svn-getinfo />
		my.path is the checked out location of the project
	-->
	<macrodef name="svn-getinfo">		
		<attribute name="my.path" default="${basedir}"/>
		<sequential>			
			<svn javahl="false">
				<status path="@{my.path}" revisionProperty="svn.revision" urlProperty="svn.url"/>
			</svn>
			<property name="lsd.revision" value="${svn.revision}" />
			<echo> in macrodef - @{my.path} </echo>
		</sequential>
	</macrodef>

	<macrodef name="validate-pre-build">		
		<attribute name="application.base.path" default="${application.base.path}"/>
		<attribute name="require.build.wscore" default="${require.build.wscore}"/>
		<attribute name="wscore.download.url" default="http://gforge.nci.nih.gov/svnroot/commonlibrary/trunk/techstack-2006/os-independent/ws-core-enum-4.0.3.zip"/>
		<sequential>			
			<if>
				<equals arg1="@{require.build.wscore}" arg2="true"/>
				<then>
					<check-wscore-exists
						wscore.download.url="@{wscore.download.url}"
						application.base.path="@{application.base.path}"
						/>
				</then>
			</if>
		</sequential>
	</macrodef>

	<macrodef name="check-wscore-exists">		
		<attribute name="wscore.download.url" default="http://gforge.nci.nih.gov/svnroot/commonlibrary/trunk/techstack-2006/os-independent/ws-core-enum-4.0.3.zip"/>
		<attribute name="application.base.path" default="${application.base.path}"/>
		<sequential>			
			<basename property="wscore.file.name" file="@{wscore.download.url}"/>
			<property name="wscore.dest.file" value="temp/${wscore.file.name}"/>
			<propertyregex property="wscore.relative.dir"
				input="@{wscore.download.url}"
				regexp=".*(ws-core-enum[\d\-\.]+)\.zip"
				select="\1"
				/>
			<echo message="Checking for existence of GLOBUS_LOCATION envrironment variable."/>
			<echo message="wscore.relative.dir = ${wscore.relative.dir}"/>
			<mkdir dir="temp"/>
			<if>
				<not>
					<isset property="env.GLOBUS_LOCATION"/>
				</not>
				<then>
					<echo message="GLOBUS_LOCATION not set, downloading and installing @{wscore.download.url}"/>
					<if>
						<not>
							<available file="@{wscore.dest.file}"/>
						</not>
						<then>
							<get src="@{wscore.download.url}"
								dest="${wscore.dest.file}"/>
							<get src="@{wscore.download.url}.MD5"
								dest="${wscore.dest.file}.MD5"/>
							<checksum file="${wscore.dest.file}" verifyProperty="wscore.cksum.ok"/>
							<if>    
								<equals arg1="${wscore.cksum.ok}" arg2="true"/>
								<then>  
									<echo message="Downloaded wscore sucessfully"/>
								</then> 
								<else>  
									<fail message="Failed to download wscore file sucessfully."/>
								</else> 
							</if>   
							<unzip dest="@{application.base.path}" src="${wscore.dest.file}"/>
							<property name="env.GLOBUS_LOCATION" value="@{application.base.path}/${wscore.relative.dir}"/>
							<echo message="Completed install of wscore files into @{application.base.path}/${wscore.relative.dir} "/>

						</then>
					</if>
					<!-- no longer needed
					<osfamily property="os.family"/>
					<echo message="os.family=${os.family}"/>
					<switch value="${os.family}">
						<case value="unix">
							<echo message="Now you need configure the environment variable GLOBUS_LOCATION."/>
							<echo message="For bash shell you can edit the $HOME/.bash_profile and add 'export GLOBUS_LOCATION=${application.base.path}/${wscore.relative.dir}'"/>
							<echo message="For other shells refer to you operating system documentation (you can check your shell by 'echo $SHELL')"/>

						</case>
						<case value="windows">
							<echo message="Now you need configure the environment variable GLOBUS_LOCATION."/>
							<echo message="Right click on MyComputer, select Proeprties, select Advanced tab, click on Environment Variables, click on New under System Variables,  and set GLOBUS_LOCATION to ${application.base.path}/${wscore.relative.dir}"/>
						</case>
					</switch>
					<fail message="Set GLOBUS_LOCATION and build again."/>
					-->
				</then>
				<else>
					<echo message="GLOBUS_LOCATION is set to ${env.GLOBUS_LOCATION} nothing needs to be done."/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!-- 
	generate-uml macro will generate the UML diagram from the checked in code. It will first create a javadoc HTML report and uses Graphviz to generate the UML graph
	Pre-Requisites: Graphviz should be present in the Path, 	
		usage: <generate-uml />
		uml.dir is the directory where the UML diagram are generated.
		src.java.dir is the source of class files. 
		uml.source.path is the classpath for the files
	-->
	<macrodef name="generate-uml">		
		<attribute name="uml.dir" />
		<attribute name="src.java.dir" />
		<attribute name="uml.source.path" />
		<attribute name="UMLGraph.jar" default="umlgraph-4.8.jar" />
		<sequential>				
			<mkdir dir="@{uml.dir}"/>			
			<javadoc sourcepath="@{src.java.dir}" destdir="@{uml.dir}" classpathref="@{uml.source.path}" access="private">				
				<doclet name="gr.spinellis.umlgraph.doclet.UmlGraphDoc" path="${bda-utils.dir}\@{UMLGraph.jar}">
					<param name="-attributes" />
					<param name="-enumerations" />
					<param name="-enumconstants" />
					<param name="-operations" />
					<param name="-qualify" />
					<param name="-types" />
					<param name="-visibility" />
				</doclet>
			</javadoc>		
			<apply executable="dot" dest="@{uml.dir}" parallel="false">
				<arg value="-Tpng"/>
				<arg value="-o"/>
				<targetfile/>
				<srcfile/>
				<fileset dir="@{uml.dir}" includes="*.dot"/>
				<mapper type="glob" from="*.dot" to="*.png"/>
			</apply>		
		</sequential>
	</macrodef>
	
	<!-- 
	generate-erd macro will generate an ERD from the Database	
		usage: <generate-erd />
		report.dir is the directory where the ERD is generated.
	-->	
	<macrodef name="generate-erd">		
		<attribute name="report.dir" default="${target.dir}/reports/schema-spy" />
		<attribute name="database.driver.jar" default="mysql-connector-java-5.0.5.jar" />
		<attribute name="schemaspy.jar" default="schemaspy_3.1.1.jar" />
		<attribute name="database.server" default="${database.server}" />
		<attribute name="database.port" default="${database.port}" />
		<attribute name="database.name" default="${database.name}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.type" default="${database.type}" />
		<sequential>
			<java jar="${bda-utils.dir}/@{schemaspy.jar}"
			output="@{report.dir}/schemaspy-out.log"
			error="@{report.dir}/schemaspy-error.log"
			fork="true">
				<arg line="-t @{database.type}"/>
				<arg line="-host @{database.server}"/>
				<arg line="-port @{database.port}"/>
				<arg line="-db @{database.name}"/>
				<arg line="-u @{database.user}"/>
				<arg line="-p @{database.password}"/>
				<arg line="-cp ${bda-utils.dir}/@{database.driver.jar}"/>
				<arg line="-o @{report.dir}"/>
			</java>
		</sequential>
	</macrodef>
	<macrodef name="pre-xmlconfig">		
		<attribute name="search.pattern" default="^&lt;\!DOCTYPE.*" />
		<attribute name="replace.pattern" default="&lt;\!DOCTYPE server &gt;" />
		<attribute name="file.location" />
		<attribute name="old-value.property.name" />
		<sequential>
			<loadfile
				property="@{old-value.property.name}"
				srcFile="@{file.location}">
				<filterchain>
					<linecontainsregexp>
						<regexp pattern="@{search.pattern}"/>
					</linecontainsregexp>
				</filterchain>
			</loadfile>
			<replaceregexp file="@{file.location}" byline="true"
				match="@{search.pattern}"
				replace="@{replace.pattern}"/>
		</sequential>
	</macrodef>
	<macrodef name="post-xmlconfig">		
		<attribute name="search.pattern" default="^&lt;\!DOCTYPE.*" />
		<attribute name="file.location" />
		<attribute name="old-value.property.value" />
		<sequential>
			<echo message="Restoreing old value '@{old-value.property.value}' to @{file.location}"/>
			<replaceregexp file="@{file.location}" byline="true"
				match="@{search.pattern}"
				replace="@{old-value.property.value}"/>
		</sequential>
	</macrodef>
	
	
	<!-- 
	fusebox-metrics macro will generate graphical representation of the static analysis for the project
		usage: <fusebox-matrix fusebox.config.file="${bda-utils.dir}/resource/fusemetrics_config.xml" fusebox.template.file="${bda-utils.dir}/resource/dashboard.tmpl" fusebox.output.dir="${basedir}/target/output" fusebox.persist.dir="${basedir}/target/persist" fusebox.search.dir="${basedir}/reports"/>
		fusebox.config.file is the location of the config file.
		fusebox.project.name is the name of the project and the macro configures it into the config file.
		fusebox.search.dir is the location of the resulted XML files from the static analysis.
		fusebox.output.file is the location of the output directory.		
		fusebox.persist.dir is the locations of the persisted directory and the data is appended after each build
		fusebox.template.file is the name of the file that renders data from the persistent file
	-->	
	<macrodef name="fusebox-metrics" description="generates the fusebox metrics">
		<attribute name="fusebox.config.file" default="${bda-utils.resource.dir}/fusemetrics_config.xml" />
		<attribute name="fusebox.project.name" default="Project" />
		<attribute name="fusebox.search.dir" default="reports" />
		<attribute name="fusebox.output.dir" default="output" />
		<attribute name="fusebox.persist.dir" default="persist" />
		<attribute name="fusebox.template.file" default="${bda-utils.resource.dir}/dashboard.tmpl" />

		<sequential>
			<if>								
				<equals arg1="@{fusebox.config.file}" arg2="fusemetrics_config.xml"/>
				<then>				
					<property name= "fusebox.arg.value" value="fusemetrics_config.xml" />				
				</then>
				<else>
					<property name= "fusebox.arg.value" value="@{fusebox.config.file}" />					
				</else>
			</if>
			<if>								
				<equals arg1="@{fusebox.config.file}" arg2="fusemetrics_config.xml"/>
				<then>				
					<property name= "fusebox.arg.value" value="fusemetrics_config.xml" />				
				</then>
				<else>
					<property name= "fusebox.arg.value" value="@{fusebox.config.file}" />					
				</else>
			</if>

			<mkdir dir="@{fusebox.output.dir}"/>
			<mkdir dir="@{fusebox.persist.dir}"/>

<!--
			<xmlconfig in="@{fusebox.config.file}" verbose="false">			
				<update path="//config/@project" value="@{fusebox.project.name}" />
				<update path="//config/@search" value="@{fusebox.search.dir}" />
				<update path="//config/@output" value="@{fusebox.output.dir}" />
				<update path="//config/@persist" value="@{fusebox.persist.dir}" />
				<update path="//config/@template" value="@{fusebox.template.file}" />
				<update path="//config/@html" value="@{fusebox.output.dir}/dashboard.html" />
			</xmlconfig>
-->
			<xmltask source="@{fusebox.config.file}" dest="@{fusebox.config.file}">
				<replace path="//config/@project" withtext="@{fusebox.project.name}" />
				<replace path="//config/@search" withtext="@{fusebox.search.dir}" />
				<replace path="//config/@output" withtext="@{fusebox.output.dir}" />
				<replace path="//config/@persist" withtext="@{fusebox.persist.dir}" />
				<replace path="//config/@template" withtext="@{fusebox.template.file}" />
				<replace path="//config/@html" withtext="@{fusebox.output.dir}/dashboard.html" />
			</xmltask>


			<java classname="com.stelligent.fusemetrics.FuseMetrics" >
			<arg value="-c"/>
			<arg value="${fusebox.arg.value}"/>
			<arg value="-d"/>	
			 <classpath>
				   <pathelement location="${bda-utils.dir}/fusemetrics-1.0.jar"/>
				   <pathelement location="${bda-utils.dir}/xom-1.1.jar"/>
				   <pathelement location="${bda-utils.dir}/xercesImpl-2.6.2.jar"/>
				   <pathelement location="${bda-utils.dir}/jfreechart-swt-1.0.9.jar"/>
				   <pathelement location="${bda-utils.dir}/jfreechart-1.0.9.jar"/>
				   <pathelement location="${bda-utils.dir}/swtgraphics2d-1.0.9.jar"/>
				   <pathelement location="${bda-utils.dir}/jcommon-1.0.12.jar"/>
				   <pathelement location="${bda-utils.dir}/itext-2.0.6.jar"/>
				   <pathelement location="${bda-utils.dir}/groovy-all-1.6.jar"/>
			 </classpath>
			</java>
		</sequential>	
	</macrodef>

	<!-- 
	diffrevision macro will generate a file will names of the java files that were checked in from the last revision number till the HEAD or the current revision number
		usage: <diffrevision envpropertyfile="project.properties" differential.file.name="diff_list.txt" />
		old.revision.number is the old revision number when the static analysis is done
		differential.file.name is the name of the file to which the differential list is written.
	-->	
	<macrodef name="diffrevision">
		<attribute name="old.revision.number" />
		<attribute name="differential.file.name" default="diff_list.txt" />
		<sequential>
			<svn javahl="false">
				<status path="${basedir}"  revisionProperty="build.svn.revision" urlProperty="svn.source.url"/>
			</svn>

			<svn javahl="false">
				<diff oldUrl="${svn.source.url}" oldTargetRevision="@{old.revision.number}" newTargetRevision="${build.svn.revision}" outFile="${basedir}/patch.txt"/> 
			</svn>
			<loadfile
				property="diff.file.list"
				srcFile="${basedir}/patch.txt">
				<filterchain>
					<linecontainsregexp>
						<regexp pattern="Index: .*\.java"/>
					</linecontainsregexp>
				</filterchain>
			</loadfile>
			<if>
				<isset property="diff.file.list"/>
				<then>				
					<echo file="@{differential.file.name}" append="false" message="${diff.file.list}${line.separator}"/>
				</then>
			</if>
			<replaceregexp file="@{differential.file.name}" byline="true" match="^Index: (.*)" replace="\1"/>			
			<delete file="${basedir}/patch.txt"/>

		</sequential>
	</macrodef>

	<macrodef name="util-dot-on-dir">

		<attribute name="dot-file.dir" />
		<attribute name="report.type" default="pdf" />
		<sequential>
			<exec osfamily="unix" executable="ls" outputproperty="file.list" dir="@{dot-file.dir}">
				<arg value="-1"/>
			</exec>
			<exec osfamily="windows" executable="dir" outputproperty="file.list" dir="@{dot-file.dir}">
				<arg line="/c dir /b"/>
			</exec>
	
			<for list="${file.list}" delimiter="${line.separator}" param="file.name">
				<sequential>
					<if>
						<contains string="@{file.name}" substring="dot"/>
						<then>
							<propertyregex property="base.file.name"
								input="@{file.name}"
								regexp="(.*)\.dot"
								select="\1"
								override="true"
								/>
							<echo message="Running graphviz on ${base.file.name}"/>
							<exec executable="dot" dir="@{dot-file.dir}">
								<arg value="-T@{report.type}"/>
								<arg value="-Gsize=11.69,8.27"/>
								<!--
								<arg value="-Grotate=90"/>
								-->
								<arg value="-o"/>
								<arg value="${base.file.name}.@{report.type}"/>
								<arg value="@{file.name}"/>
							</exec> 
						</then>
					</if>
				</sequential>
			</for>
		</sequential>
	</macrodef>
	<macrodef name="database-clean">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.system.url" default="${database.system.url}" />
		<attribute name="database.system.user" default="${database.system.user}" />
		<attribute name="database.system.password" default="${database.system.password}" />
		<attribute name="database.version" default="5.0.27" />
		<attribute name="database.name" default="${database.name}" />
		<attribute name="database.server" default="${database.server}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="database.re-create" default="${database.re-create}" />
		<attribute name="database.drop-schema" default="${database.drop-schema}" />
		<sequential>
			<if>
				<and>
					<equals arg1="@{database.re-create}" arg2="true"/>
					<equals arg1="@{database.drop-schema}" arg2="true"/>
				</and>
				<then>
					<fail message="You cannot set both database.re-create and database.drop-schema at the same time.  database.re-create is used in local installs.  database.drop-schema is used in remote installs.  Either one can be set for external (Cancer Center) installs."/>
				</then>
			</if>
			<if>
				<not>
					<or>
						<equals arg1="@{database.re-create}" arg2="true"/>
						<equals arg1="@{database.drop-schema}" arg2="true"/>
					</or>
				</not>
				<then>
					<fail message="Either database.re-create or database.drop-schema must be set to call the database install target.  Please set one in the properties file and build again, or if you don't want databases targets to run you can set exclude.database in the properties file."/>
				</then>
			</if>
			<if>
				<equals arg1="@{database.re-create}" arg2="true"/>
				<then>
					<switch value="${database.type}">
						<case value="postgresql">
							<database-create/>
						</case>
						<case value="mysql">
							<database-create/>
						</case>
						<default>
							<echo message="Re-creation (drop and re-create) of ${database.type} databases is not supported, nothing done."/>
						</default>
					</switch>
				</then>
				<else>
					<echo message="Database.recreate flag not set, database not re-created."/>
				</else>
			</if>
			<if>
				<equals arg1="@{database.drop-schema}" arg2="true"/>
				<then>
					<echo message="Dropping database objects"/>
					<dropAllDatabaseObjects
						driver="@{database.driver}"
						url="@{database.url}"
						username="@{database.user}"
						password="@{database.password}"
						promptOnNonLocalDatabase="@{prompt.user.if.not.local.database}"
						classpathref="bda-utils.classpath"
						defaultSchemaName="@{database.schema}"
						/>
					<!-- Sequences don't seem to drop in first run second run cleans them up -->
					<dropAllDatabaseObjects
						driver="@{database.driver}"
						url="@{database.url}"
						username="@{database.user}"
						password="@{database.password}"
						promptOnNonLocalDatabase="@{prompt.user.if.not.local.database}"
						classpathref="bda-utils.classpath"
						defaultSchemaName="@{database.schema}"
						/>
					<sleep seconds="5"/>
				</then>
				<else>
					<echo message="Database.drop-schema flag not set, database schema not dropped."/>
				</else>
			</if>

		</sequential>
	</macrodef>
	<macrodef name="database-install">
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="sql.delimiter" default=";" />
		<attribute name="sql.delimitertype" default="normal" />
		<attribute name="onerror" default="abort" />
		<attribute name="db-install.dir" default="${db-install.dir.dest}" />
		<attribute name="db.install.create.file.list" />
		<sequential>
			<for list="@{db.install.create.file.list}" param="db.install.file">
				<sequential>
					<run-sql-script database.url="@{database.url}"
						database.user="@{database.user}" 
						database.password="@{database.password}" 
						sql.delimiter="@{sql.delimiter}" 
						sql.delimitertype="@{sql.delimitertype}"
						sql.file="@{db-install.dir}/${database.type}/@{db.install.file}"
						onerror="@{onerror}"/>
				</sequential>
			</for>
		</sequential>
	</macrodef>
	<macrodef name="database-upgrade">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="database.changelog.file" default="${os.temp.dir}/${project.name}/db-upgrade.xml" />
		<sequential>
			<database-upgrade-fix
				database.driver="@{database.driver}"
				database.url="@{database.url}"
				database.user="@{database.user}"
				database.password="@{database.password}"
				database.driver.file="@{database.driver.file}"
				database.changelog.file="@{database.changelog.file}"
				/>
			<updateDatabase
				driver="@{database.driver}"
				url="@{database.url}"
				username="@{database.user}"
				password="@{database.password}"
				classpathref="jdbc.driver.classpath"
				defaultSchemaName="@{database.schema}"
				changeLogFile="@{database.changelog.file}"
				/>
		</sequential>
	</macrodef>
	<macrodef name="database-genchangelog">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="database.changelog.file" default="generated-change-log.xml" />
		<sequential>
			<generateChangeLog
				driver="@{database.driver}"
				url="@{database.url}"
				username="@{database.user}"
				password="@{database.password}"
				classpathref="jdbc.driver.classpath"
				defaultSchemaName="@{database.schema}"
				outputFile="@{database.changelog.file}"
				/>
		</sequential>
	</macrodef>
	<macrodef name="database-tag">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<sequential>
			<if>
				<isset property="database.release.version"/>
				<then>
					<tagDatabase
						driver="@{database.driver}"
						url="@{database.url}"
						username="@{database.user}"
						password="@{database.password}"
						classpathref="jdbc.driver.classpath"
						defaultSchemaName="@{database.schema}"
						tag="${database.release.version}"
						>
					</tagDatabase>
				</then>
				<else>
					<fail message="Variable database.release.version must be set to call upgrade:database:tag target."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	<macrodef name="database-rollback">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="database.changelog.file" default="${db-upgrade.dir.dest}/db-upgrade.xml" />
		<sequential>
			<if>
				<isset property="database.rollback.version"/>
				<then>
					<echo message="Rolling datbase back to version ${database.rollback.version}."/>
					<rollbackDatabase
						driver="@{database.driver}"
						url="@{database.url}"
						username="@{database.user}"
						password="@{database.password}"
						classpathref="jdbc.driver.classpath"
						defaultSchemaName="@{database.schema}"
						changeLogFile="@{database.changelog.file}"
						rollbackTag="${database.rollback.version}"
						>
					</rollbackDatabase>
				</then>
				<else>
					<fail message="Variable database.rollback.version must be set to call upgrade:database:rollback target."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	<macrodef name="database-diff">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="compare1.database.url" default="${compare1.database.url}" />
		<attribute name="compare1.database.user" default="${compare1.database.user}" />
		<attribute name="compare1.database.password" default="${compare1.database.password}" />
		<attribute name="compare1.database.schema" default="${compare1.database.schema}" />
		<attribute name="compare2.database.url" default="${compare2.database.url}" />
		<attribute name="compare2.database.user" default="${compare2.database.user}" />
		<attribute name="compare2.database.password" default="${compare2.database.password}" />
		<attribute name="compare2.database.schema" default="${compare2.database.schema}" />
		<attribute name="output.file.txt" default="generated-diff-log.txt"/>
		<attribute name="output.file.xml" default="generated-diff-log.xml"/>
		<sequential>
			<echo message="Generating diff report @{compare1.database.url} to @{compare2.database.url}."/>
			<diffDatabase
				driver="@{database.driver}"
				outputFile="@{output.file.txt}"
				classpathref="jdbc.driver.classpath"

				baseUrl="@{compare1.database.url}"
				baseUsername="@{compare1.database.user}"
				basePassword="@{compare1.database.password}"
				baseDefaultSchemaName="@{compare1.database.schema}"

				url="@{compare2.database.url}"
				username="@{compare2.database.user}"
				password="@{compare2.database.password}"
				defaultSchemaName="@{compare2.database.schema}"

				/>
			<diffDatabaseToChangeLog
				driver="@{database.driver}"
				outputFile="@{output.file.xml}"
				classpathref="jdbc.driver.classpath"

				baseUrl="@{compare1.database.url}"
				baseUsername="@{compare1.database.user}"
				basePassword="@{compare1.database.password}"
				baseDefaultSchemaName="@{compare1.database.schema}"

				url="@{compare2.database.url}"
				username="@{compare2.database.user}"
				password="@{compare2.database.password}"
				defaultSchemaName="@{compare2.database.schema}"

				/>
		</sequential>
	</macrodef>
	<macrodef name="database-doc">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.schema" default="${database.schema}" />
		<attribute name="output.dir" default="${temp.dir}/dbDoc" />
		<attribute name="database.changelog.file" default="${db-upgrade.dir.dest}/db-upgrade.xml" />
		<sequential>
			<mkdir dir="@{output.dir}"/>
			<dbDoc
				driver="@{database.driver}"
				url="@{database.url}"
				username="@{database.user}"
				password="@{database.password}"
				classpathref="jdbc.driver.classpath"
				defaultSchemaName="@{database.schema}"
				outputDirectory="@{output.dir}"
				changeLogFile="@{database.changelog.file}"
				/>
		</sequential>
	</macrodef>
	<macrodef name="ivy-module-add2repo">
		<attribute name="ivy-repo.base.url" default="http://gforge.nci.nih.gov/svnroot/commonlibrary/trunk/ivy-repo"/>
		<attribute name="ivy-repo.base.dir"/>
		<attribute name="ivy.add.org" />
		<attribute name="ivy.add.module" />
		<attribute name="ivy.add.version" />
		<attribute name="ivy.add.module.src.dir" />
		<attribute name="ivy.add.module.src.file.list" />
		<attribute name="ivy.add.xml.src.location" />

		<sequential>
			<property name="ivy.org.dir" value="@{ivy-repo.base.dir}/@{ivy.add.org}"/>
			<property name="ivy.module.dir" value="@{ivy-repo.base.dir}/@{ivy.add.org}/@{ivy.add.module}"/>
			<property name="ivy.version.dir" value="@{ivy-repo.base.dir}/@{ivy.add.org}/@{ivy.add.module}/@{ivy.add.version}"/>
			<available file="${ivy.org.dir}" property="org.dir.exists" />
			<available file="${ivy.module.dir}" property="module.dir.exists" />

			<check-svnuser/>
			<!-- Conditionally checkout or update -->
			<if>
				<available file="@{ivy-repo.base.dir}"/>
				<then>
					<echo message="Found @{ivy-repo.base.dir}, doing svn update."/>
					<svn-update
						svn.update.dir="@{ivy-repo.base.dir}"
						/>
				</then>
				<else>
					<svn-co
						svn.checkout.url="@{ivy-repo.base.url}"
						svn.checkout.dir="@{ivy-repo.base.dir}"
						delete="false"
						/>
				</else>
			</if>
			<!-- Copy artifacts to directory -->
			<copy todir="${ivy.version.dir}" file="@{ivy.add.xml.src.location}"/>

			<for list="@{ivy.add.module.src.file.list}" param="ivy.add.module.src.file" delimiter=",">
				<sequential>
					<copy todir="${ivy.version.dir}" file="@{ivy.add.module.src.dir}/@{ivy.add.module.src.file}"/>
				</sequential>
			</for>
			<!-- Add and commit to svn, only the directory level that does not exist -->
			<if>
				<not>
					<isset property="org.dir.exists"/>
				</not>
				<then>
					<echo message="Adding org @{ivy.add.org}."/>
					<svn-add
						svn.add.dir="${ivy.org.dir}"
						/>
					<svn-commit
						svn.commit.dir="${ivy.org.dir}"
						svn.commit.user="${svn.user.name}"
						svn.commit.pass="${svn.user.pass}"
						svn.commit.message="Files added by build process as part of ivy deploy process"
						/>
				</then>
				<elseif>
					<not>
						<isset property="module.dir.exists"/>
					</not>
					<then>
						<echo message="Adding module @{ivy.add.org}/@{ivy.add.module}."/>
						<svn-add
							svn.add.dir="${ivy.module.dir}"
							/>
						<svn-commit
							svn.commit.dir="${ivy.module.dir}"
							svn.commit.user="${svn.user.name}"
							svn.commit.pass="${svn.user.pass}"
							svn.commit.message="Files added by build process as part of ivy deploy process"
							/>
					</then>
				</elseif>
				<else>
					<echo message="Adding version @{ivy.add.org}/@{ivy.add.module}/@{ivy.add.version}."/>
					<svn-add
						svn.add.dir="${ivy.version.dir}"
						/>
					<svn-commit
						svn.commit.dir="${ivy.version.dir}"
						svn.commit.user="${svn.user.name}"
						svn.commit.pass="${svn.user.pass}"
						svn.commit.message="Files added by build process as part of ivy deploy process"
						/>
				</else>
			</if>
		</sequential>

	</macrodef>

	<macrodef name="check-svnuser">
		<sequential>
			<property name="prop.list" value="svn.user.name,svn.user.pass"/>
			<for list="${prop.list}" param="prop.list.item" delimiter=",">
				<sequential>
					<echo message="Checking for existence of @{prop.list.item}"/>
					<if>
						<not>
							<isset property="@{prop.list.item}"/>
						</not>
						<then>
							<fail message="svn.user.name svn.user.pass must be set to add files to ivy so add them to a properties file (like local.properties) or pass them in on the command line."/>
						</then>
					</if>
				</sequential>
			</for>
		</sequential>
	</macrodef>
	<macrodef name="grid-appserver-configure">
		<attribute name="appserver.conf.dir" default="${jboss.home}/server/${jboss.server.name}/conf"/>
		<attribute name="appserver.webapp.dir" default="${jboss.home}/server/${jboss.server.name}/deploy"/>
		<attribute name="appserver.server-xml.file" default="${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml"/>
		<attribute name="appserver.server-xml.service.name" default="jboss.web"/>
		<attribute name="appserver.port.http" default="${jboss.server.port}"/>
		<attribute name="appserver.port.ssl" default="${jboss.ssl.port}"/>
		<attribute name="appserver.hostname" default="${jboss.server.hostname}"/>
		<attribute name="search.host" default="localhost"/>
		<attribute name="search.port" default="8080"/>
		<attribute name="grid.application.name" default="${grid.application.name}"/>
		<attribute name="grid.application.relative.dir" default="${grid.dir.dest}"/>
		<attribute name="grid.index.url" default="${grid.index.url}"/>
		<attribute name="grid.poc.science.affiliation" default="${grid.poc.science.affiliation}"/>
		<attribute name="grid.poc.science.name.last" default="${grid.poc.science.name.last}"/>
		<attribute name="grid.poc.science.name.first" default="${grid.poc.science.name.first}" />
		<attribute name="grid.poc.science.phone" default="${grid.poc.science.phone}"/>
		<attribute name="grid.poc.science.role" default="${grid.poc.science.role}" />
		<attribute name="grid.poc.science.email" default="${grid.poc.science.email}" />
		<attribute name="grid.poc.tech.researchCenter.displayname" default="${grid.poc.tech.researchCenter.displayname}"/>
		<attribute name="grid.poc.tech.researchCenter.shortname" default="${grid.poc.tech.researchCenter.shortname}"/>
		<attribute name="grid.poc.tech.addr.country" default="${grid.poc.tech.addr.country}"/>
		<attribute name="grid.poc.tech.addr.locality" default="${grid.poc.tech.addr.locality}"/>
		<attribute name="grid.poc.tech.addr.postalCode" default="${grid.poc.tech.addr.postalCode}"/>
		<attribute name="grid.poc.tech.addr.stateProvince" default="${grid.poc.tech.addr.stateProvince}"/>
		<attribute name="grid.poc.tech.addr.street1" default="${grid.poc.tech.addr.street1}"/>
		<attribute name="grid.poc.tech.addr.street2" default="${grid.poc.tech.addr.street2}"/>
		<attribute name="grid.poc.tech.affiliation" default="${grid.poc.tech.affiliation}"/>
		<attribute name="grid.poc.tech.name.last" default="${grid.poc.tech.name.last}"/>
		<attribute name="grid.poc.tech.name.first" default="${grid.poc.tech.name.first}"/>
		<attribute name="grid.poc.tech.phone" default="${grid.poc.tech.phone}"/>
		<attribute name="grid.poc.tech.email" default="${grid.poc.tech.email}"/>
		<attribute name="grid.poc.tech.role" default="${grid.poc.tech.role}"/>
		<attribute name="grid.external.secure.host" default="${grid.external.secure.host}"/>
		<attribute name="grid.external.secure.port" default="${grid.external.secure.port}"/>
		<attribute name="grid.secure.enable" default="${grid.secure.enable}"/>
		<attribute name="grid.secure.dir" default="${grid.secure.dir}"/>
		<attribute name="grid.secure.port" default="${grid.secure.port}"/>
		<attribute name="grid.secure.key.file" default="${grid.secure.key.file}"/>
		<attribute name="grid.secure.cert.file" default="${grid.secure.cert.file}"/>
		<attribute name="grid.secdesc.file" default="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/globus_wsrf_core/global_security_descriptor.xml"/>
		<sequential>
			<switch value="@{grid.secure.enable}">
				<case value="true">
					<property name="scheme" value="https"/>
					<property name="appserver.default.web.port" value="@{grid.secure.port}"/>
				</case>
				<case value="false">
					<property name="scheme" value="http"/>
					<property name="appserver.default.web.port" value="@{appserver.port.http}"/>
				</case>
				<default>
					<fail message="grid.secure.enable must be true or false"/>
				</default>
			</switch>

			<!-- Fix all wsdl files that refer to statically defined host and port -->
			<echo message="Cleaning up hostname:port refereces in **/*.wsdl"/>
			<replace dir="@{appserver.webapp.dir}/@{grid.application.relative.dir}" token="http://@{search.host}:@{search.port}" value="${scheme}://@{appserver.hostname}:${appserver.default.web.port}">
				<include name="**/*.wsdl" />
			</replace>

			<!-- Fix default jndi-config -->
			<echo message="Fixing grid jndi-config"/>
			<replace file="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/globus_resolution_service/jndi-config.xml" token="http://@{search.host}:@{search.port}" value="${scheme}://@{appserver.hostname}:${appserver.default.web.port}"/>

			<!-- fix web.xml -->
			<echo message="Updating grid web.xml"/>
			<update-grid-web-xml-protocol
				appserver.webapp.dir="@{appserver.webapp.dir}"
				grid.application.relative.dir="@{grid.application.relative.dir}"
				web-xml.location="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/web.xml"
				scheme="${scheme}"
				port="${appserver.default.web.port}"
				/>

			<!-- Secure Grid configuraiotns -->
			<if>
				<equals arg1="@{grid.secure.enable}" arg2="true"/>
				<then>
					<echo message="grid.secure.enable=true, configuring secure grid services @{grid.secdesc.file}"/>
					<grid-secure-configure-secdesc
						appserver.conf.dir="@{appserver.conf.dir}"
						appserver.webapp.dir="@{appserver.application.dir}"
						grid.application.relative.dir="@{grid.application.relative.dir}"
						grid.secdesc.file="@{grid.secdesc.file}"
						grid.secure.cert.file="@{grid.secure.cert.file}"
						grid.secure.key.file="@{grid.secure.key.file}"
						/>
				</then>
				<else>
					<echo message="grid.secure.enable=false, skipping configuring secure grid services"/>
				</else>

			</if>

			<!-- Fix service specific jndi-config -->
			<echo message="Fixing second grid jnid-config"/>
			<replaceregexp file="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/cagrid_@{grid.application.name}/jndi-config.xml" 
				match="(\s+.value.)http://.*\:\d+(\/.*)" 
				replace="\1${scheme}://@{appserver.hostname}:${appserver.default.web.port}\2" 
				flags="g" byline="true"/>
			<!-- Configure grid service to advertise the external URL if server is protected by a NAT -->
			<grid-configure-server-config
				appserver.webapp.dir="@{appserver.webapp.dir}"
				grid.application.relative.dir="@{grid.application.relative.dir}"
				grid.external.secure.host="@{grid.external.secure.host}"
				grid.secure.enable="@{grid.secure.enable}"
				/>
					
			<!-- POC stuff -->
			<echo message="Updateing POC info @{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/cagrid_@{grid.application.name}/serviceMetadata.xml"/>
			<!--
			<xmltask source="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/cagrid_@{grid.application.name}/serviceMetadata.xml" dest="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/cagrid_@{grid.application.name}/serviceMetadata.xml">
				<remove path="/:ServiceMetadata/:serviceDescription/:Service/:pointOfContactCollection/:PointOfContact" />
				<insert path="/:ServiceMetadata/:serviceDescription/:Service/:pointOfContactCollection">
					<![CDATA[
						<ns3:PointOfContact affiliation="@{grid.poc.science.affiliation}" email="@{grid.poc.science.email}" firstName="@{grid.poc.science.name.first}" lastName="@{grid.poc.science.name.last}" phoneNumber="@{grid.poc.science.phone}" role="@{grid.poc.science.role}" "/>
					]]>
				</insert>
			</xmltask>
			-->
			<property name="poc.science.string" value=" affiliation=&quot;@{grid.poc.science.affiliation}&quot; email=&quot;@{grid.poc.science.email}&quot; firstName=&quot;@{grid.poc.science.name.first}&quot; lastName=&quot;@{grid.poc.science.name.last}&quot; phoneNumber=&quot;@{grid.poc.science.phone}&quot; role=&quot;@{grid.poc.science.role}&quot; "/>

			<replaceregexp file="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/cagrid_@{grid.application.name}/serviceMetadata.xml"
				match="^(\s+&lt;ns3:PointOfContact).*(xmlns:ns3.*&gt;)"
				replace="\1${poc.science.string}\2"
				flags="g" byline="true"/>
			<!-- Research Center info -->
			<property name="poc.tech.string" value="${line.separator}
&lt;ns9:ResearchCenter displayName=&quot;@{grid.poc.tech.researchCenter.displayname}&quot; shortName=&quot;@{grid.poc.tech.researchCenter.shortname}&quot; xmlns:ns9=&quot;gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common&quot;&gt;${line.separator}
&lt;ns9:Address country=&quot;@{grid.poc.tech.addr.country}&quot; locality=&quot;@{grid.poc.tech.addr.locality}&quot; postalCode=&quot;@{grid.poc.tech.addr.postalCode}&quot; stateProvince=&quot;@{grid.poc.tech.addr.stateProvince}&quot; street1=&quot;@{grid.poc.tech.addr.street1}&quot; street2=&quot;@{grid.poc.tech.addr.street2}&quot;/&gt;${line.separator}
&lt;ns9:pointOfContactCollection&gt;${line.separator}
&lt;ns9:PointOfContact affiliation=&quot;@{grid.poc.tech.affiliation}&quot; email=&quot;@{grid.poc.tech.email}&quot; firstName=&quot;@{grid.poc.tech.name.first}&quot; lastName=&quot;@{grid.poc.tech.name.last}&quot; phoneNumber=&quot;@{grid.poc.tech.phone}&quot; role=&quot;@{grid.poc.tech.role}&quot;/&gt;${line.separator}
&lt;/ns9:pointOfContactCollection&gt;${line.separator}
&lt;/ns9:ResearchCenter&gt;${line.separator}
"/>
			<replaceregexp file="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/cagrid_@{grid.application.name}/serviceMetadata.xml"
				match="&lt;ns1:hostingResearchCenter&gt;.*&lt;\/ns1:hostingResearchCenter&gt;"
				replace="&lt;ns1:hostingResearchCenter&gt;${poc.tech.string}&lt;\/ns1:hostingResearchCenter&gt;"
				flags="sg"/>

			<echo message="Updating poll interval grid registration.xml"/>
			<replaceregexp 
				match="(&lt;agg:PollIntervalMillis&gt;).*(&lt;\/agg:PollIntervalMillis&gt;)"
				replace="\13600000\2"
				flags="sg">
				<fileset dir="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc">
					<include name="**/*_registration.xml"/>
				</fileset>
			</replaceregexp>
			<!-- Change pointer to index service based on property -->
			<echo message="Updating grid.index.url - @{grid.index.url}"/>
			<replaceregexp 
				match="(&lt;wsa:Address&gt;).*(&lt;\/wsa:Address&gt;)"
				replace="\1@{grid.index.url}\2"
				flags="sg">
				<fileset dir="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc">
					<include name="**/*_registration.xml"/>
				</fileset>
			</replaceregexp>

		</sequential>
	</macrodef>
	<macrodef name="check-absolute-directory" description="Diagnose the host system before the installation">
		<attribute name="directory.property" />
		<sequential>
			<!-- Application.base.path check for bad directory -->
			<propertycopy name="directory.value" from="@{directory.property}" />
			<propertyregex property="is.absolute.dir"
				regexp="^(\w:\/)"
				input="${directory.value}"
				select="\1"
				/>
			<propertyregex property="is.absolute.dir"
				regexp="^(\/)"
				input="${directory.value}"
				select="\1"
				/>
			<if>
				<isset property="is.absolute.dir"/>
				<then>
					<echo message="@{directory.property} is an absolute path."/>
				</then>
				<else>
					<fail message="@{directory.property} needs to be an absolute path, please correct this and build again."/>
				</else>
			</if>
		</sequential>
	</macrodef>
	<macrodef name="obfuscate-properties-file" description="Diagnose the host system before the installation">
		<attribute name="properties.file"/>
		<attribute name="required.property.list"/>
		<attribute name="optional.property.list" default=""/>
		<attribute name="delete.property.list" default=""/>
		<sequential>
			<for list="@{required.property.list}" param="property.name" delimiter=",">
				<sequential>
					<replaceregexp file="@{properties.file}"
						match="^(@{property.name})=.*"
						replace="\1=REPLACE_VALUE"
						flags="g" byline="true"/>
				</sequential>
			</for>
			<for list="@{optional.property.list}" param="property.name" delimiter=",">
				<sequential>
					<replaceregexp file="@{properties.file}"
						match="^(@{property.name})=.*"
						replace="\1=replace_value"
						flags="g" byline="true"/>
				</sequential>
			</for>
			<for list="@{delete.property.list}" param="property.name" delimiter=",">
				<sequential>
					<replaceregexp file="@{properties.file}"
						match="^@{property.name}=.*"
						replace=""
						flags="g" byline="true"/>
				</sequential>
			</for>
		</sequential>
	</macrodef>
	<macrodef name="secure-jboss-console" description="Diagnose the host system before the installation">
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="jboss.web.user" default="${jboss.web.user}"/>
		<attribute name="jboss.web.password" default="${jboss.web.password}"/>
		<sequential>
			<property name="jmx-console.web-xml.file" value="@{jboss.home}/server/@{jboss.server.name}/deploy/jmx-console.war/WEB-INF/web.xml"/>
			<echo message="Updating ${jmx-console.web-xml.file}"/>
			<xmltask source="${jmx-console.web-xml.file}"
				dest="${jmx-console.web-xml.file}">
				<remove path="/web-app/security-constraint"/>
				<insert path="/web-app">
					<![CDATA[
					<security-constraint>
						<web-resource-collection>
							<web-resource-name>HtmlAdaptor</web-resource-name>
							<description>An example security config that only allows users with the
								role JBossAdmin to access the HTML JMX console web application
							</description>
							<url-pattern>/*</url-pattern>
							<http-method>GET</http-method>
							<http-method>POST</http-method>
						</web-resource-collection>
						<auth-constraint>
							<role-name>JBossAdmin</role-name>
						</auth-constraint>
					</security-constraint>

					]]>
				</insert>
				<remove path="/web-app/login-config"/>
				<insert path="/web-app">
					<![CDATA[
					<login-config>
						<auth-method>BASIC</auth-method>
						<realm-name>JBoss JMX Console</realm-name>
					</login-config>
					]]>
				</insert>
				<remove path="/web-app/security-role"/>
				<insert path="/web-app">
					<![CDATA[
					<security-role>
						<role-name>JBossAdmin</role-name>
					</security-role>
					]]>
				</insert>
			</xmltask>

			<property name="jmx-console.jboss-web-xml.file" value="@{jboss.home}/server/@{jboss.server.name}/deploy/jmx-console.war/WEB-INF/jboss-web.xml"/>
			<echo message="Updating ${jmx-console.jboss-web-xml.file}"/>
			<xmltask source="${jmx-console.jboss-web-xml.file}"
				dest="${jmx-console.jboss-web-xml.file}">
				<remove path="/jboss-web/security-domain"/>
				<insert path="/jboss-web">
					<![CDATA[
					<security-domain>java:/jaas/jmx-console</security-domain>
					]]>
				</insert>
			</xmltask>

			<property name="jmx-console.password.file" value="@{jboss.home}/server/@{jboss.server.name}/conf/props/jmx-console-users.properties"/>
			<echo message="Updating ${jmx-console.password.file}"/>

			<replaceregexp file="${jmx-console.password.file}"
				match="^(admin)=.*"
				replace="@{jboss.web.user}=@{jboss.web.password}"
				flags="g" byline="true"/>

			<property name="web-console.web-xml.file" value="@{jboss.home}/server/@{jboss.server.name}/deploy/management/console-mgr.sar/web-console.war/WEB-INF/web.xml"/>
			<echo message="Updating ${web-console.web-xml.file}"/>
			<xmltask source="${web-console.web-xml.file}"
				dest="${web-console.web-xml.file}">
				<remove path="/web-app/security-constraint"/>
				<insert path="/web-app">
					<![CDATA[
					<security-constraint>
						<web-resource-collection>
							<web-resource-name>HtmlAdaptor</web-resource-name>
							<description>An example security config that only allows users with the
								role JBossAdmin to access the HTML JMX console web application
							</description>
							<url-pattern>/*</url-pattern>
							<http-method>GET</http-method>
							<http-method>POST</http-method>
						</web-resource-collection>
						<auth-constraint>
							<role-name>JBossAdmin</role-name>
						</auth-constraint>
					</security-constraint>

					]]>
				</insert>
				<remove path="/web-app/login-config"/>
				<insert path="/web-app">
					<![CDATA[
					<login-config>
						<auth-method>BASIC</auth-method>
						<realm-name>JBoss Web Console</realm-name>
					</login-config>
					]]>
				</insert>
				<remove path="/web-app/security-role"/>
				<insert path="/web-app">
					<![CDATA[
					<security-role>
						<role-name>JBossAdmin</role-name>
					</security-role>
					]]>
				</insert>
			</xmltask>

			<property name="web-console.jboss-web-xml.file" value="@{jboss.home}/server/@{jboss.server.name}/deploy/management/console-mgr.sar/web-console.war/WEB-INF/jboss-web.xml"/>
			<echo message="Updating ${web-console.jboss-web-xml.file}"/>

			<xmltask source="${web-console.jboss-web-xml.file}"
				dest="${web-console.jboss-web-xml.file}">
				<remove path="/jboss-web/security-domain"/>
				<insert path="/jboss-web">
					<![CDATA[
					<security-domain>java:/jaas/web-console</security-domain>
					]]>
				</insert>
			</xmltask>

			<property name="web-console.classes.dir" value="@{jboss.home}/server/@{jboss.server.name}/deploy/management/console-mgr.sar/web-console.war/WEB-INF/classes"/>
			<property name="jboss.props.dir" value="@{jboss.home}/server/@{jboss.server.name}/conf/props"/>
			<copy todir="${jboss.props.dir}">
				<fileset dir="${web-console.classes.dir}">
					<include name="web-console-*.properties"/>
				</fileset>
			</copy>

			<property name="web-console.password.file" value="@{jboss.home}/server/@{jboss.server.name}/conf/props/web-console-users.properties"/>
			<echo message="Updating ${web-console.password.file}"/>

			<replaceregexp file="${web-console.password.file}"
				match="^(admin)=.*"
				replace="@{jboss.web.user}=@{jboss.web.password}"
				flags="g" byline="true"/>

			<property name="login-config.xml" value="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml"/>
			<echo message="Updating ${login-config.xml}"/>

			<replaceregexp file="${login-config.xml}"
				match="web-console-"
				replace="props\/web-console-"
				flags="g" byline="true"/>
		</sequential>
	</macrodef>
	<macrodef name="gui-installer-prep">
		<attribute name="bda-utils.dir" default="${bda-download.dir}" />
		<attribute name="gui-installer.dir" default="${gui-installer.dir}" />
		<attribute name="target.dir" default="${target.dir}"/>
		<attribute name="download.dir" default="${download.dir}" />
		<attribute name="dist.dir" default="${dist.dir}"/>
		<attribute name="izpack.binary.name" default="izpack-4.0.1" />
		<attribute name="izpack.binary.file" default="izpack-4.0.1.zip" />
		<attribute name="izpack.binary.uri" default="http://gforge.nci.nih.gov/svnroot/commonlibrary/trunk/techstack-2008/os-independent" />
		<attribute name="izpack-custom.svn.url" default="http://gforge.nci.nih.gov/svnroot/automation/trunk/software/bda-installer/src-custom"/>
		<attribute name="izpack-custom.svn.dir" default="${target.dir}/izpack-custom"/>
		<attribute name="product.name" default="caArray-installer" />
		<attribute name="product.version" default="2.1.0" />
		<sequential>
			<tstamp>
				<format property="JAR_STAMP" pattern="MMddyyyyhhmmss" unit="millisecond" />
			</tstamp>
		
			<!-- Cleanup target area -->
			<delete dir="@{target.dir}/@{izpack.binary.name}" />
			
			<!-- Extract izpack -->
			<get src="@{izpack.binary.uri}/@{izpack.binary.file}" dest="@{download.dir}/@{izpack.binary.file}" usetimestamp="true"/>
			<unzip dest="@{target.dir}" src="@{download.dir}/@{izpack.binary.file}" />

			<!-- Check out izpack custom code and copy into extracted izpack dist -->
			<osfamily property="os.family"/>
			<switch value="${os.family}">
				<case value="windows">
					<echo message="Retreiving izpack custom code from svn task."/>
					<svn-co
						svn.checkout.url="@{izpack-custom.svn.url}"
						svn.checkout.dir="@{izpack-custom.svn.dir}"
						/>
				</case>
				<case value="unix">
					<echo message="Retreiving izpack custom code from svn command line."/>
					<mkdir dir="@{izpack-custom.svn.dir}"/>
					<exec osfamily="unix" executable="svn" spawn="true">
						<arg line="co @{izpack-custom.svn.url} @{izpack-custom.svn.dir}" />
					</exec>
				</case>
				<default>
					<fail message="Unexpected OS type ${os.family}"/>
				</default>
			</switch>
			<sleep seconds="10"/>

			<copy todir="@{target.dir}/@{izpack.binary.name}/src/lib" overwrite="true">
				<fileset dir="@{izpack-custom.svn.dir}" />
			</copy>

			<!-- customize izpack 
			<xmlconfig in="@{target.dir}/@{izpack.binary.name}/src/build.xml" verbose="false">
				<insertbranch path="//target[@name='build.listeners']" srcxmlfile="@{izpack-custom.svn.dir}/resources/ProgressBarInstallerListener.xml" srcpath="//build-installer-listener" />
			</xmlconfig>
-->
			<xmltask failWithoutMatch="true" source="@{target.dir}/@{izpack.binary.name}/src/build.xml" 
				dest="@{target.dir}/@{izpack.binary.name}/src/build.xml">		
				<insert path="//target[@name='build.listeners']" file="@{izpack-custom.svn.dir}/resources/ProgressBarInstallerListener.xml"/>
			</xmltask>
			<copy file="@{izpack-custom.svn.dir}/resources/eng.xml" todir="@{target.dir}/@{izpack.binary.name}/bin/langpacks/installer" overwrite="true" />

			<!-- Copy over library files -->
			<mkdir dir="@{target.dir}/@{izpack.binary.name}/lib"/>
			<copy todir="@{target.dir}/@{izpack.binary.name}/lib">
				<fileset dir="@{bda-utils.dir}">
					<include name="ant-1.7.0.jar"/>
					<include name="ant-launcher-1.7.0.jar"/>
					<include name="ant-nodeps-1.7.0.jar"/>
				</fileset>
			</copy>

			<!-- Compile the izpack with custom code -->
			<ant inheritall="false" antfile="@{target.dir}/@{izpack.binary.name}/src/build.xml" />

			<if>
				<os family="unix" />
				<then>
					<chmod dir="@{target.dir}/@{izpack.binary.name}/bin" perm="ugo+rx" includes="compile" />
				</then>
			</if>
		</sequential>
	</macrodef>
	<macrodef name="jboss-read-ldapconfig" description="check if the application is installed">
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="ldap.url.property" default="ldap.url" />
		<attribute name="ldap.basedn.property" default="ldap.basedn" />
		<attribute name="ldap.searchprefix.property" default="ldap.searchprefix" />
		<sequential>
			<if>
				<not>
					<isset  property="@{ldap.url.property}"/>
				</not>
				<then>
					<property name="read.login-config.flag" value="true"/>
				</then>
			</if>
			<available file="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml" property="login-config.exists"/>
			<if>
				<isset property="read.login.flag"/>
				<then>
					<if>
						<not>
							<isset property="login-config.exists" />
						</not>
						<then>
							<echo message="LDAP properties not set and can't open login-config.xml to see if JBoss is setup to use LDAP for authentication."/>
						</then>
						<else>
<!--					
							<xmlconfig in="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml" verbose="true">
								<read path="//module-optio[@name]='ldapHost'" property="read.ldap.url" />
								<read path="//module-optio[@name]='ldapSearchableBase'" property="read.ldap.basedn" />
								<read path="//module-optio[@name]='ldapUserIdLabel'" property="read.ldap.searchprefix" />
							</xmlconfig>
-->							
							<xmltask source="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml" dest="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml">
								<copy path="//module-option[@name='ldapHost']/text()" property="read.ldap.url" />
								<copy path="//module-option[@name='ldapSearchableBase']/text()" property="read.ldap.basedn" />
								<copy path="//module-option[@name='ldapUserIdLabel']/text()" property="read.ldap.searchprefix" />
							</xmltask>							
							<if>
								<isset property="read.ldap.url"/>
								<then>
									<property name="@{ldap.url.property}" value="${read.ldap.url}" />
									<property name="@{ldap.basedn.property}" value="${read.ldap.basedn}" />
									<property name="@{ldap.searchprefix.property}" value="${read.ldap.searchprefix}" />
									<property name="authentication.type" value="ldap"/>
								</then>
								<else>
									<property name="authentication.type" value="db"/>
								</else>
							</if>
						</else> 
					</if>   
				</then>
				<else>
					<property name="authentication.type" value="db"/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<macrodef name="report-dir-diff">
		<attribute name="dir1"/>
		<attribute name="dir2"/>
		<attribute name="reportFile"/>
		<sequential>
			<if>
				<or>
					<os family="unix"/>     
					<os family="mac"/>     
				</or>
				<then>

			<groovy>
				<arg line="@{dir1} @{dir2} @{reportFile}"/>
				dir1 = new File(args[0]).getAbsoluteFile()
				dir2 = new File(args[1]).getAbsoluteFile()
				reportFile = new File(args[2]).getAbsoluteFile()
				Integer dir1Length = dir1.toString().length()
				Integer dir2Length = dir2.toString().length()

				println "Command line args are "
				println "\t dir1 -\t\t" + dir1
				println "\t dir2 -\t\t" + dir2
				println "\t reportFile -\t" + reportFile

				reportText = ""

				println "## Comparing files in " + dir1 + " to files in " + dir2
				dir1.eachFileRecurse
				{ file1 ->
				if (file1.isFile())
				{
				// println file1.toString() + " is a file"
				file1Name = file1.getName() 
				file1Path = file1.getParent()
				file2Str = dir2.toString() + "/" + file1.toString().substring(dir1Length)
				file2 = new File(file2Str)
				// println file2.toString() + " debug"
				if (!file2.isFile() &amp;&amp; !file2.isDirectory()) 
				{
				println file2.toString() + " is a new file."
				reportText += "## " + file2.toString() + " is a new file.\n"
				}
				if (file2.isFile())
				{
				// println file2.toString() + " is a file"
				diffCmd = "diff -c --ignore-all-space --ignore-blank-lines " + file1 + " " + file2
				String diffText = diffCmd.execute().text
				if (diffText.length() > 0)
				{
				println file2.toString() + " differences found"
				reportText += "## Differences found between " + file1 + " " + file2 + "\n"
				diffText.eachLine {reportText += "\t" + it + "\n"}
				}
				}
				}
				}
				println "## Looking for new files in " + dir2 + " ..."
				dir2.eachFileRecurse
				{ file2 ->
				if (file2.isFile())
				{
				file1Str = dir1.toString() + "/" + file2.toString().substring(dir2Length)
				file1 = new File(file1Str)
				//println file2.toString() + " debug"
				if (!file1.isFile() &amp;&amp; !file1.isDirectory()) 
				{
				println file2.toString() + " is missing in new installation."
				reportText += "## " + file2.toString() + " is a new file.\n"
				}
				}
				}

				reportFile.write(reportText)
			</groovy>
				</then>
				<else>
					<echo message="Not a Unix system, report not generated"/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<macrodef name="backup-roll">
		<attribute name="backupDir"/>
		<attribute name="backupCount"/>
		<sequential>
			<groovy>
				<arg line="@{backupDir} @{backupCount}"/>

				String backupDir = args[0]
				Integer backupCount = new Integer(0).valueOf(args[1])

				println "Command Line Arguments:"
				println "\tbackupDir -\t" + backupDir
				println "\tbackupCount -\t" + backupCount

				ant = new AntBuilder()
				i = 1..backupCount.minus(1)

				File rmdir= new File(backupDir + "/backup" + backupCount)

				if (rmdir.exists()) {ant.delete(dir:rmdir)}

				i.reverse().each
				{
				File mv_src_dir= new File(backupDir + "/backup" + it)
				File mv_dest_dir= new File(backupDir + "/backup" + (it+1))
				if (mv_src_dir.exists())
				{
				println "move ${mv_src_dir} ${mv_dest_dir}"
				ant.move(file: mv_src_dir, tofile: mv_dest_dir);
				}
				}
			</groovy>
		</sequential>
	</macrodef>

	<macrodef name="backup-dir">
		<attribute name="src.dir"/>
		<attribute name="backup.base.dir"/>
		<attribute name="backup.count" default="5" />
		<sequential>
			<backup-roll
				backupDir="@{backup.base.dir}"
				backupCount="@{backup.count}"
				/>                      
			<delete dir="@{backup.base.dir}/backup"/>
			<mkdir dir="@{backup.base.dir}/backup"/>
			<mkdir dir="@{src.dir}"/>
			<move file="@{src.dir}" todir="@{backup.base.dir}/backup"/>
			<delete dir="@{src.dir}" quiet="false" />
		</sequential>
	</macrodef>
	<macrodef name="jboss-install-binaries">
		<attribute name="application.base.path" default="${application.base.path}"/>
		<attribute name="jboss.binaries.file" default="${tools.dir}/${jboss.binaries.file}" />
		<sequential>
			<propertyregex property="jboss.file.is.zip"
				input="@{jboss.binaries.file}"
				regexp=".*.zip"
				select="true"
				/>
			<propertyregex property="jboss.file.is.jar"
				input="@{jboss.binaries.file}"
				regexp=".*.jar"
				select="true"
				/>
			<if>
				<isset property="jboss.file.is.zip"/>
				<then>
					<unzip dest="${application.base.path}" src="${tools.dir}/${jboss.binaries.file}" />
				</then>
			</if>
			<if>
				<isset property="jboss.file.is.jar"/>
				<then>
					<java jar="${tools.dir}/${jboss.binaries.file}" fork="true">
						<arg line="-installGroup ejb3 installpath=${jboss.home}"/>
					</java>         
				</then>
			</if>

			<!-- make sure default server is renamed if applicable -->
			<if>            
				<not>                   
					<equals arg1="${jboss.server.name}" arg2="default"/>
				</not>                  
				<then>                  
					<move todir="${jboss.home}/server/${jboss.server.name}">
						<fileset dir="${jboss.home}/server/default"/>
					</move>                         
				</then>                 
			</if>           

			<if>            
				<os family="unix"/>     
				<then>                  
					<chmod dir="${jboss.home}/bin" perm="ugo+rx" 
						includes="**/*.sh"/>                    
				</then>                 
			</if>           
		</sequential>
	</macrodef>
	<macrodef name="jboss-login-config">
		<attribute name="authentication.type" default="${authentication.type}"/>
		<attribute name="application.context.name" default="${application.context.name}"/>
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="login-config.ldap.file"/>
		<attribute name="login-config.db.file"/>
		<sequential>
			<if>                            
				<equals arg1="@{authentication.type}" arg2="ldap"/>
				<then>                  
					<property name="login-config.block.file" value="@{login-config.ldap.file}"/>
				</then>                                 
				<else>                                  
					<if>                                            
						<equals arg1="@{authentication.type}" arg2="db"/>
						<then>                                  
							<property name="login-config.block.file" value="@{login-config.db.file}"/>
						</then>                                         
						<else>
							<fail message="@{authentication.type} is not a valid authentiation type, please change to db or ldap and re-run the build."/>
						</else>                         
					</if>                   
				</else>         
			</if>           
			<echo message="Inserting ${login-config.block.file} into @{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml"/>
<!--
			<xmlconfig in="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml" verbose="false">
				<insertbranch path="//policy" srcxmlfile="${login-config.block.file}" srcpath="//application-policy" />
			</xmlconfig>
-->
			<xmltask source="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml" 
				dest="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml">		
				<remove path="//policy/application-policy[@name='@{application.context.name}']"/>
			</xmltask>
			<xmltask failWithoutMatch="true" source="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml" 
				dest="@{jboss.home}/server/@{jboss.server.name}/conf/login-config.xml">		
				<insert path="//policy" file="${login-config.block.file}"/>
			</xmltask>   
		</sequential>
	</macrodef>
	<macrodef name="jboss-log4j-config">
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="log4j.template.file"/>
		<sequential>
			<validate-log4j
				log4j.template.file="@{log4j.template.file}"
				/>

			<copy file="@{jboss.home}/server/@{jboss.server.name}/conf/log4j.xml" tofile="@{jboss.home}/server/@{jboss.server.name}/conf/log4j.xml.bak" overwrite="true"/>
			<copy file="@{log4j.template.file}" tofile="@{jboss.home}/server/@{jboss.server.name}/conf/log4j.xml" overwrite="true">
				<filterset>
					<filtersfile file="${properties.file}"/>
					<filtersfile file="project.properties"/>
				</filterset>
			</copy>
		</sequential>
	</macrodef>
	<macrodef name="validate-log4j">
		<attribute name="log4j.file" default="${jboss.home}/server/${jboss.server.name}/conf/log4j.xml"/>
		<sequential>
			<echo message="Validating log4j configuration at @{log4j.file}"/>
			<groovy>
				<arg line="@{log4j.file}"/>
				import java.util.regex.Matcher
				import java.util.regex.Pattern

				sizeMap = [
				KB: 1024,
				MB: (1024*1024),
				GB: (1024*1024*1024),
				]

				Integer thresholdFileNum = 15
				Integer thresholdFileSize = (1 * sizeMap["GB"])
				Integer exitCode = 2
				String errorMsg = '''
				There was an violation with your log4j configuraiton, see the rules below.
				All appenders except "console" should be a rolling type appender
				All appenders must have a MaxFileSize and be less than 1TB
				All appenders must have a MaxBackupIndex and be less than 15
				'''

				log4jFile = new File(args[0]).getAbsoluteFile()
				log4j = new XmlParser(false,false).parse(log4jFile)

				// Test Appenders
				println log4j.appender."@name"
				log4j.appender."@name".each{name ->
				if (name != "CONSOLE" &amp;&amp; name != "FILE")
				{
				appenderClass = log4j.appender.find{it.'@name'==name}."@class"
				println "Appender Name-\t${name}"
				println "Appender Class-\t${appenderClass}"
				if (appenderClass.indexOf("Roll") &lt; 1)
				{
				println "WARNING - Appender should be a rolling appender."
				//println errorMsg
				//System.exit(exitCode)
				}
				// Test Thresholds
				String fileSize="" 
				if (log4j.appender.find{it.'@name'==name}.param.find{it.'@name'=='MaxFileSize'})
				{
				fileSize = log4j.appender.find{it.'@name'==name}.param.find{it.'@name'=='MaxFileSize'}."@value"
				}
				else
				{
				println "WARNING - Max Size is not set."
				//println errorMsg
				//System.exit(exitCode)
				}
				Integer numFiles
				if ( log4j.appender.find{it.'@name'==name}.param.find{it.'@name'=='MaxBackupIndex'})
				{
				numFiles =  log4j.appender.find{it.'@name'==name}.param.find{it.'@name'=='MaxBackupIndex'}."@value".toInteger()
				}
				else
				{
				println "WARNING - Max Files is not set." 
				//println errorMsg
				//System.exit(exitCode)
				}

				println "Appender MaxSize-\t${fileSize}"
				println "Appender MaxFiles-\t${numFiles}"


				numMatcher =  java.util.regex.Pattern.compile(/(\d+)(\D*)/).matcher(fileSize)
				numMatches = numMatcher.matches()
				Integer numUnits = numMatcher.group(1).toInteger()
				String unit = numMatcher.group(2)


				Integer maxSize = numUnits 
				if (unit.length() > 0 ) 
				{
				maxSize = numUnits * sizeMap[unit]
				}
				if (maxSize > thresholdFileSize)
				{
				println "WARNING - MaxFileSize exceeds threshold of ${thresholdFileSize}"
				//println errorMsg
				//System.exit(exitCode)
				}

				if (numFiles > thresholdFileNum)
				{
				println "WARNING - MaxFileNum exceeds threshold of ${thresholdFileNum}"
				//println errorMsg
				//System.exit(exitCode)
				}
				println "Appender Processed Sucessfully.\n"
				}
				}
			</groovy>
		</sequential>
	</macrodef>
	<macrodef name="deploy-local">
		<attribute name="build.dir" default="${build.dir}"/>
		<attribute name="install.dir" default="${dist.exploded.dir}" />
		<attribute name="properties.file" default="${properties.file}" />
		<attribute name="target.name" />
		<sequential>
			<!-- Copies over all files so linux and windows properties are present --> 
			<copy todir="@{install.dir}">
				<fileset dir="@{build.dir}">
					<include name="*.properties" /> 
				</fileset>              
			</copy>         
			<exec osfamily="unix" executable="ant" dir="@{install.dir}" failonerror="true">
				<!-- use alternate properties file since default has replace values -->
				<arg value="-Dproperties.file=@{properties.file}" />
				<!-- force reinstall of database and jboss without prompting -->
				<arg value="-Dforce.reinstall=true" />
				<arg value="@{target.name}" />
			</exec>         
			<exec osfamily="windows" executable="ant.bat" dir="@{install.dir}" failonerror="true">
				<!-- use alternate properties file since default has replace values -->
				<arg value="-Dproperties.file=@{properties.file}" />
				<!-- force reinstall of database and jboss without prompting -->
				<arg value="-Dforce.reinstall=true" />
				<arg value="@{target.name}" />
			</exec>         
			<!-- ant returns exit code zero on failure to psexec, issue still lives on
			<exec osfamily="windows" executable="${bda-utils.dir}/resource/psexec.exe" dir="@{install.dir}" failonerror="true">
				<arg line="ant.bat -Dproperties.file=@{properties.file} -Dforce.reinstall=true @{target.name}"/>
			</exec>         
			-->
		</sequential>
	</macrodef>
	<macrodef name="deploy-files" description="Macro for deploying and extracting distrution to server">
		<attribute name="ssh.user" default="${ssh.server.username}" />
		<attribute name="ssh.host" default="${ssh.server.hostname}" />
		<attribute name="remote.directory.property.name" default="ssh.dir.temp" />
		<attribute name="properties.file" default="${properties.file}" />
		<attribute name="dist.dir" default="${dist.dir}" />
		<attribute name="dist.file" />
		<sequential>
			<!-- Validate remote directory is valid -->
			<propertycopy name="remote.dir" from="@{remote.directory.property.name}" />
			<check-valid-directory-name directory.property="remote.dir" />
			<!-- Delete/re-create remote directory -->
			<remote-ssh 
				remoteSshHost="@{remoteSshHost}"
				remoteSshUser="@{remoteSshUser}"
				remotesshcommand="rm -rf ${remote.dir};mkdir -p ${remote.dir}" />
			<!-- work around for issue where basedir is required but is not currently used -->
			<remote-ssh 
				remoteSshHost="@{remoteSshHost}"
				remoteSshUser="@{remoteSshUser}"
				remotesshcommand="mkdir -p ${remote.dir}/lib" /> 

			<!-- copy distribution and prop file to remote system -->
			<remote-scp 
				remoteSshHost="@{remoteSshHost}"
				remoteSshUser="@{remoteSshUser}"
				remoteScpFileToCopy="@{dist.dir}/@{dist.file}" remoteScpToDir="@{ssh.user}@@@{ssh.host}:${remote.dir}" />
			<remote-scp 
				remoteSshHost="@{remoteSshHost}"
				remoteSshUser="@{remoteSshUser}"
				remoteScpFileToCopy="@{properties.file}" remoteScpToDir="@{ssh.user}@@@{ssh.host}:${remote.dir}" />
			<!-- Extract zip file -->
			<remote-ssh 
				remoteSshHost="@{remoteSshHost}"
				remoteSshUser="@{remoteSshUser}"
				remotesshcommand="cd ${remote.dir}; unzip -q @{dist.file}" />
		</sequential>
	</macrodef>
	<macrodef name="dist-prep" description="Macro for copying files to dist area">
		<attribute name="dist.exploded.dir" default="${dist.exploded.dir}" />
		<attribute name="build.dir" default="${build.dir}" />
		<attribute name="bda-utils.dir" default="${bda-utils.dir}" />
		<attribute name="common.dir" default="${common.dir}" />
		<attribute name="download.dir" default="${download.dir}" />
		<attribute name="copy.tools.flag" default="Y" />
		<attribute name="default.target" default="install" />
		<sequential>
			<!-- Do some cleanup -->
			<delete dir="@{distexploded.dir}" />
			<delete>
				<fileset dir="@{dist.exploded.dir}">
					<include name="build.xml" />
					<include name="*properties*" />
				</fileset>
			</delete>

			<!-- Copy install related xml and properties files -->
			<echo message="Copying build and property files"/>
			<copy todir="@{dist.exploded.dir}" overwrite="true">
				<fileset dir="@{build.dir}">
					<include name="install.xml" />
					<include name="install.properties" />
					<include name="*properties.template" />
					<include name="project.properties" />
				</fileset>
			</copy>

			<!-- Set default target and properyties.file to install and install.properties -->
			<replaceregexp file="@{dist.exploded.dir}/install.xml" byline="true" match="(.project.*default=.)\w+(.\s+.*)" replace="\1@{default.target}\2" />

			<!-- Rename install.xml to build.xml so manual installs will not need to include the -f optoin on ant, simplifying the install proces. -->
			<move file="@{dist.exploded.dir}/install.xml" tofile="@{dist.exploded.dir}/build.xml" />

			<!-- Copy over BDA macrodefs and librarires -->
			<echo message="Copying bda-utils dir"/>
			<copy todir="@{dist.exploded.dir}/bda-utils" overwrite="true">
				<fileset dir="@{bda-utils.dir}"> 
					<include name="**/*" />
				</fileset>
			</copy>

			<!-- This  copies common files over, common files are currently resource files like jboss configuration files and database scripts -->
			<echo message="Copying common dir"/>
			<copy todir="@{dist.exploded.dir}/common" overwrite="true">
				<fileset dir="@{common.dir}">
					<include name="**/resources/**/*" />
				</fileset>
			</copy>

			<if>
				<equals arg1="@{copy.tools.flag}" arg2="Y"/>
				<then>
					<echo message="Copying tools dir"/>
					<!-- Copy over binary distributions downloaded earlier -->
					<copy todir="@{dist.exploded.dir}/tools" overwrite="true">
						<fileset dir="@{download.dir}">
							<include name="**/*" />
						</fileset>
					</copy>
				</then>
				<else>
					<echo message="Not copying tools based on flag"/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<macrodef name="appserver-ssl-configure" description="macro for enabling ssl in jboss">
		<attribute name="appserver.conf.dir" default="${jboss.home}/server/${jboss.server.name}/conf"/>
		<attribute name="appserver.server-xml.file" default="${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml"/>
		<attribute name="appserver.server-xml.service.name" default="jboss.web"/>
		<attribute name="appserver.ssl.enable" default="${jboss.ssl.enable}"/>
		<attribute name="appserver.ssl.port" default="8443"/>
		<attribute name="appserver.ssl.keystore.file" default="${jboss.ssl.keystore.file}"/>
		<attribute name="appserver.ssl.keystore.dir" default="${jboss.ssl.keystore.dir}"/>
		<attribute name="appserver.ssl.keystore.pass" default="${jboss.ssl.keystore.pass}"/>
		<attribute name="appserver.ssl.keystore.alias" default="${jboss.ssl.keystore.alias}"/>
		<attribute name="appserver.ssl.fullyqualified.hostname" default="${jboss.ssl.fullyqualified.hostname}"/>

		<sequential>
			<!-- Questions
			If you connect to http will it automatically redirect you to https?
			Will bindnings work?
			-->
			<if>
				<equals arg1="@{appserver.ssl.enable}" arg2="true"/>
				<then>
					<echo message="Install JBoss SSL configurations"/>

					<!-- copy keystore to ${jboss.home}/server/${jboss.server.name}/conf -->
					<copy todir="@{appserver.conf.dir}" file="@{appserver.ssl.keystore.dir}/@{appserver.ssl.keystore.file}"/>

					<!-- modify ${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml -->
					<xmltask source="@{appserver.server-xml.file}"
						dest="@{appserver.server-xml.file}">
		
						<remove	path="/Server/Service[@name='@{appserver.server-xml.service.name}']/Connector[@port='@{appserver.ssl.port}']" />
		
						<insert path="/Server/Service[@name='@{appserver.server-xml.service.name}']">
							<![CDATA[
							<Connector port="@{appserver.ssl.port}"
								maxThreads="100"
								strategy="ms"
							       	maxHttpHeaderSize="8192"
								emptySessionPath="true"
								scheme="https"
								secure="true"
							       	clientAuth="false" 
								keystoreFile="@{appserver.conf.dir}/@{appserver.ssl.keystore.file}"
								keystorePass="@{appserver.ssl.keystore.pass}"
								keyAlias="@{appserver.ssl.keystore.alias}"
							       	sslProtocol = "TLS" />
							]]>
						</insert>
					</xmltask>
					<!--
							<Connector port="@{appserver.ssl.port}"
							       	address="\${jboss.bind.address}"
								maxThreads="100"
								strategy="ms"
							       	maxHttpHeaderSize="8192"
								emptySessionPath="true"
								scheme="https"
								secure="true"
							       	clientAuth="false" 
								keystoreFile="@{appserver.conf.dir}/@{appserver.ssl.keystore.file}"
								keystorePass="@{appserver.ssl.keystore.pass}"
								keyAlias="@{appserver.ssl.keystore.alias}"
							       	sslProtocol = "TLS" />
					-->
				</then>
				<else>
					<echo message="appserver.ssl.enable not set or true so skipping install of JBoss SSL configuration"/>
				</else>
			</if>

		</sequential>
	</macrodef>
	<macrodef name="verify-keystore" description="macro for verifying a keystore">
		<attribute name="appserver.ssl.enable" default="${jboss.ssl.enable}"/>
		<attribute name="appserver.ssl.keystore.file" default="${jboss.ssl.keystore.file}"/>
		<attribute name="appserver.ssl.keystore.dir" default="${jboss.ssl.keystore.dir}"/>
		<attribute name="appserver.ssl.keystore.pass" default="${jboss.ssl.keystore.pass}"/>
		<attribute name="appserver.ssl.keystore.alias" default="${jboss.ssl.keystore.alias}"/>
		<attribute name="appserver.ssl.fullyqualified.hostname" default="${jboss.ssl.fullyqualified.hostname}"/>
		<sequential>
			<if>                            
				<equals arg1="@{appserver.ssl.enable}" arg2="true"/>
				<then>                                  
					<var name="keytool.output" unset="true"/>
					<var name="keytool.error" unset="true"/>
					<var name="keytool.result" unset="true"/>
					<echo message="Validating JBoss SSL configurations"/>
					<exec executable="keytool" outputproperty="keytool.output" errorproperty="keytool.error" resultproperty="keytool.result">
						<arg line="-list -keystore @{appserver.ssl.keystore.dir}/@{appserver.ssl.keystore.file} -storepass @{appserver.ssl.keystore.pass} -alias  @{appserver.ssl.keystore.alias} -v"/>
					</exec>                                 
					<if>                                            
						<not>                                                   
							<equals arg1="${keytool.result}" arg2="0"/>     
						</not>                                          
						<then>                                                  
							<fail message="keytool failed - ${keytool.output} ${keytool.error}"/>
						</then>                                         
						<else>                                                  
							<echo message="debug - ${keytool.result} ${keytool.output} ${keytool.error}"/>
			<groovy>                
				<arg line="${keytool.output} @{appserver.ssl.fullyqualified.hostname}"/>
				import java.util.regex.Pattern

				String keytoolOutput = args[0]
				String fqhn = args[3]

				keytoolOutput.eachLine
				{ cline ->
				//Owner: CN=*.nci.nih.gov, OU=National Cancer Institute, O=National Institute of Health, L=Rockville, ST=Maryland, C=US
				//m = java.util.regex.Pattern.compile(/^Owner:\s+CN=([\w\d\-\_\.\*]+).*/).matcher(cline)
				m = cline =~ /^Owner:\s+CN=([^\.]+)([\w\d\-\_\.]+).*/
				if (m.matches())
				{
				host = m.group(1)
				domain = m.group(2)
				certfqhn = host + domain
				println "Found host = '${host}' domain = '${domain}' in - ${cline}"
				if (host.equals('*'))
				{
				if (fqhn.indexOf(domain) > 0)
				{
				println "${fqhn} matches ${domain}"
				} else
				{
				System.err.println "${fqhn} FAILED MATCH ${domain}"
				System.exit(2)
				}
				} else
				{
				if (fqhn.equals(certfqhn))
				{
				println "${fqhn} matches ${certfqhn}"
				} else
				{
				System.err.println "${fqhn} FAILED MATCH ${certfqhn}"
				System.exit(2)
				}
				}
				}
				}
			</groovy>
						</else>                                       
					</if>                                   
				</then>                         
				<else>                          
					<echo message="appserver.ssl.enable not set or true so skipping ssl validation"/>
				</else>                         
			</if>                   
		</sequential>
	</macrodef>

	<macrodef name="grid-secure-configure-connector" description="Inserts a secure connector configuration into a tomcat configuration, including jboss tomcat">
		<attribute name="appserver.conf.dir" default="${jboss.home}/server/${jboss.server.name}/conf"/>
		<attribute name="appserver.server-xml.file" default="${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml"/>
		<attribute name="appserver.server-xml.service.name" default="jboss.web"/>
		<attribute name="grid.secure.enable" default="${grid.secure.enable}"/>
		<attribute name="grid.secure.port" default="@{grid.secure.port}"/>
		<attribute name="grid.secure.dir" default="${grid.secure.dir}"/>
		<attribute name="grid.secure.key.file" default="${grid.secure.key.file}" />
		<attribute name="grid.secure.cert.file" default="${grid.secure.cert.file}" />
		<sequential>
			<if>
				<equals arg1="@{grid.secure.enable}" arg2="true"/>
				<then>
					<propertyregex property="is.jboss4"
						input="@{appserver.conf.dir}"
						regexp="jboss-4.0...GA"
						select="\1"
						/>
					<propertyregex property="is.tomcat50"
						input="@{appserver.conf.dir}"
						regexp="tomcat-5.0..."
						select="\1"
						/>
					<propertyregex property="is.tomcat55"
						input="@{appserver.conf.dir}"
						regexp="tomcat-5.5..."
						select="\1"
						/>
					<if>
						<or>
							<isset property="is.jboss4"/>
							<isset property="is.tomcat55"/>
						</or>
						<then>
							<echo message="is.tomcat50 = ${is.tomcat50} is.tomcat55 = ${is.tomcat55} is.jboss4 = ${is.jboss4} "/>
							<var name="tomcat55.extras" value="protocolHandlerClassName=&quot;org.apache.coyote.http11.Http11Protocol&quot;${line.separator}socketFactory=&quot;org.globus.tomcat.catalina.net.BaseHTTPSServerSocketFactory&quot;"/>
						</then>
						<elseif>
							<isset property="is.tomcat50"/>
							<then>
								<echo message="is.tomcat50 = ${is.tomcat50} is.tomcat55 = ${is.tomcat55} is.jboss4 = ${is.jboss4} "/>
								<var name="tomcat55.extras" value=""/>
							</then>
						</elseif>
						<else>
							<echo message="is.tomcat50 = ${is.tomcat50} is.tomcat55 = ${is.tomcat55} is.jboss4 = ${is.jboss4} "/>
							<fail message="Not using Jboss 4.x or Tomcat 5.0.x or Tomcat 5.5.x cannot configure a secure container, failing build.  Please be sure to include the applcation and version as the name of the directory for tomcat.home or jboss.home"/>
						</else>
					</if>


					<echo message="grid.secure.enable set so secure grid is being configured"/>
					<copy todir="@{appserver.conf.dir}" file="@{grid.secure.dir}/@{grid.secure.cert.file}"/>
					<copy todir="@{appserver.conf.dir}" file="@{grid.secure.dir}/@{grid.secure.key.file}"/>
					<switch value="@{appserver.server-xml.service.name}">
						<case value="jboss.web">
							<var name="valve.name" value="org.globus.tomcat.coyote.valves.HTTPSValve55"/>
						</case>
						<case value="Catalina">
							<var name="valve.name" value="org.globus.tomcat.coyote.valves.HTTPSValve"/>
						</case>
						<default>
							<fail message="Unkown server.xml service name - @{appserver.server-xml.service.name}, don't know how to handle"/>
						</default>
					</switch>
					<xmltask source="@{appserver.server-xml.file}"
						dest="@{appserver.server-xml.file}" >
						<remove	path="/Server/Service[@name='@{appserver.server-xml.service.name}']/Connector[@port='@{grid.secure.port}']" />
						<insert path="/Server/Service[@name='@{appserver.server-xml.service.name}']">
							<![CDATA[
							<Connector className="org.globus.tomcat.coyote.net.HTTPSConnector"
								port="@{grid.secure.port}" 
								maxThreads="150" 
								minSpareThreads="25" 
								maxSpareThreads="75" 
								autoFlush="true"
								disableUploadTimeout="true" 
								scheme="https"
								enableLookups="true" 
								acceptCount="10" 
								debug="0" 
								cert="@{appserver.conf.dir}/@{grid.secure.cert.file}"
								key="@{appserver.conf.dir}/@{grid.secure.key.file}"
								${tomcat55.extras}
								>
									<Valve className="${valve.name}"/>
								</Connector>
							]]>
						</insert>
					</xmltask>
				</then>
				<else>
					<echo message="grid.secure.enable not set so secure grid not configured"/>
				</else>
			</if>
		</sequential>      
	</macrodef>
	<macrodef name="grid-secure-configure-valve">
		<attribute name="appserver.server-xml.file" default="${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml"/>
		<attribute name="appserver.server-xml.service.name" default="jboss.web"/>
		<sequential>    
			<!-- Functionallity moved to grid-secure-configure-connector
			<switch value="@{appserver.server-xml.service.name}">
				<case value="jboss.web">
					<var name="valve.name" value="org.globus.tomcat.coyote.valves.HTTPSValve55"/>
				</case>
				<case value="Catalina">
					<var name="valve.name" value="org.globus.tomcat.coyote.valves.HTTPSValve"/>
				</case>
				<default>
					<fail message="Unkown server.xml service name - @{appserver.server-xml.service.name}, don't know how to handle"/>
				</default>
			</switch>
			<xmltask source="@{appserver.server-xml.file}"
				dest="@{appserver.server-xml.file}">
				<remove path="/Server/Service[@name='@{appserver.server-xml.service.name}']/ConnenctorEngine[@name='@{appserver.server-xml.service.name}']/Valve[@className='${valve.name}']" />
				<insert path="/Server/Service[@name='@{appserver.server-xml.service.name}']/Engine[@name='@{appserver.server-xml.service.name}']">
					<![CDATA[                               
					<Valve className="${valve.name}"/>
					]]>                                     
				</insert>                       
			</xmltask>              
			-->
		</sequential>   
	</macrodef>

	<macrodef name="grid-secure-configure-secdesc">
		<attribute name="appserver.conf.dir" default="${jboss.home}/server/${jboss.server.name}/conf/"/>
		<attribute name="appserver.webapp.dir" default="${jboss.home}/server/${jboss.server.name}/deploy/"/>
		<attribute name="grid.application.relative.dir" default="${grid.dir.dest}"/>
		<attribute name="grid.secdesc.file" default="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/globus_wsrf_core/global_security_descriptor.xml"/>
		<attribute name="grid.secure.key.file" default="${grid.secure.key.file}" />
		<attribute name="grid.secure.cert.file" default="${grid.secure.cert.file}" />
		<sequential>
			<if>
				<available file="@{grid.secdesc.file}" />
				<then>
					<xmltask source="@{grid.secdesc.file}" 
						dest="@{grid.secdesc.file}"
						failWithoutMatch="true">
						<remove path="/*[local-name()='securityConfig']/*[local-name()='gridmap']" />
						<attr   path="/*[local-name()='securityConfig']/*[local-name()='credential']/*[local-name()='key-file']"
							attr="value" 
							value="@{appserver.conf.dir}/@{grid.secure.key.file}" />
						<attr   path="/*[local-name()='securityConfig']/*[local-name()='credential']/*[local-name()='cert-file']"
							attr="value" 
							value="@{appserver.conf.dir}/@{grid.secure.cert.file}" />
					</xmltask>
				</then>
				<else>
					<fail message="Cannot filed security descriptor file @{grid.secdesc.file}"/>
					<!--
					<echoxml file="@{grid.secdesc.file}">
						<securityConfig xmlns="http://www.globus.org">
							<credential>
								<key-file value="@{appserver.conf.dir}/@{grid.secure.key.file}"/>
								<cert-file value="@{appserver.conf.dir}/@{grid.secure.key.file}"/>
							</credential>
						</securityConfig>
					</echoxml>
					-->
				</else>
			</if>
		</sequential>
	</macrodef>


	<macrodef name="grid-configure-server-config">
		<attribute name="appserver.webapp.dir" default="${jboss.home}/server/${jboss.server.name}/deploy/"/>
		<attribute name="grid.application.relative.dir" default="${grid.dir.dest}"/>
		<attribute name="server-config.file" default="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/globus_wsrf_core/server-config.wsdd" />
		<attribute name="grid.secdesc.file" default="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/etc/globus_wsrf_core/global_security_descriptor.xml"/>
		<attribute name="grid.external.secure.host" default="${grid.external.secure.host}"/>
		<attribute name="grid.secure.enable" default="true"/>
		<sequential>
			
			<propertyregex property="grid.external.secure.host.has.value"
				input="@{grid.external.secure.host}"
				regexp="\S+"
				select="true"
				/>
			<if>
				<isset property="grid.external.secure.host.has.value"/>
				<then>
					<echo message="grid.external.secure.host is @{grid.external.secure.host}, proceeding with configuration"/>
					<xmltask source="@{server-config.file}" dest="@{server-config.file}">
						<remove path="/*[local-name()='deployment']/*[local-name()='globalConfiguration']/*[local-name()='parameter' and @name='logicalHost']" />
						<remove path="/*[local-name()='deployment']/*[local-name()='globalConfiguration']/*[local-name()='parameter' and @name='publishHostName']" />
						<insert path="/*[local-name()='deployment']/*[local-name()='globalConfiguration']">
							<![CDATA[
							<parameter xmlns="http://xml.apache.org/axis/wsdd/"
								name="logicalHost"
								value="@{grid.external.secure.host}"/>
							<parameter xmlns="http://xml.apache.org/axis/wsdd/"
										name="publishHostName"
								value="true"/>
							<parameter xmlns="http://xml.apache.org/axis/wsdd/"
								name="disableDNS"
										value="true"/>
							]]>
						</insert>
					</xmltask>
				</then>
				<else>
					<echo message="grid.external.secure.host is is not set skipping external host configuration."/>
				</else>
			</if>
			<if>
				<equals arg1="@{grid.secure.enable}" arg2="true" trim="true" />
				<then>
					<xmltask source="@{server-config.file}" dest="@{server-config.file}">
						<remove path="/*[local-name()='deployment']/*[local-name()='globalConfiguration']/*[local-name()='parameter' and @name='containerSecDesc']" />
						<insert path="/*[local-name()='deployment']/*[local-name()='globalConfiguration']">
							<![CDATA[
							<parameter xmlns="http://xml.apache.org/axis/wsdd/"
								name="containerSecDesc"
								value="@{grid.secdesc.file}"/>
							]]>
						</insert>
						<remove path="/*[local-name()='deployment']/*[local-name()='globalConfiguration']/*[local-name()='requestFlow']/*[local-name()='handler' and @type='java:org.globus.wsrf.impl.security.authentication.transport.TomcatTransportSecurityHandler']" />
						<insert path="/*[local-name()='deployment']/*[local-name()='globalConfiguration']/*[local-name()='requestFlow']/*[local-name()='handler' and @type='java:org.globus.wsrf.handlers.URLMapper']"
							position="after">
							<![CDATA[
							<handler type="java:org.globus.wsrf.impl.security.authentication.transport.TomcatTransportSecurityHandler"
								xmlns="http://xml.apache.org/axis/wsdd/"/>
							]]>
						</insert>
	
					</xmltask>
				</then>
			</if>
		</sequential>
	</macrodef>


	<macrodef name="update-grid-web-xml-protocol">
		<attribute name="appserver.webapp.dir" default="${jboss.home}/server/${jboss.server.name}/deploy/"/>
		<attribute name="grid.application.relative.dir" default="${grid.dir.dest}"/>
		<attribute name="web-xml.location" default="@{appserver.webapp.dir}/@{grid.application.relative.dir}/WEB-INF/web.xml"/>
		<attribute name="scheme" default="http" />
		<attribute name="port" default="${jboss.server.port}"/>
		<sequential>
			<xmltask source="@{web-xml.location}" dest="@{web-xml.location}">
				<xmlcatalog refid="installer.catalog"/>
				<remove path="/web-app/servlet[servlet-name='WSRFServlet']/init-param[param-name='defaultProtocol']" />
				<remove path="/web-app/servlet[servlet-name='WSRFServlet']/init-param[param-name='defaultPort']" />
				<insert path="/web-app/servlet[servlet-name='WSRFServlet']/servlet-class"
					position="after">
					<![CDATA[
					<init-param>
						<param-name>defaultProtocol</param-name>
						<param-value>@{scheme}</param-value>
					</init-param>
					<init-param>
						<param-name>defaultPort</param-name>
						<param-value>@{port}</param-value>
					</init-param>
					]]>
				</insert>
			</xmltask>
		</sequential>
	</macrodef>
	<macrodef name="appserver-configure-external-hostname">
		<attribute name="appserver.server-xml.file" default="${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml"/>
		<attribute name="appserver.server-xml.service.name" default="jboss.web"/>
		<attribute name="appserver.external.host" default="${jboss.external.ssl.host}"/>
		<attribute name="appserver.external.port" default="${jboss.external.ssl.port}"/>
		<attribute name="proxy.update.connector.port" default="8443"/>
		<sequential>
			<propertyregex property="appserver.external.host.has.value"
				input="@{appserver.external.host}"
				regexp="\S+"
				select="true"
				/>
			<if>
				<equals arg1="${appserver.external.host.has.value}" arg2="true"/>
				<then>
					<echo message="Grid External Host Name set so configuring proxy settings"/>
					<xmltask source="@{appserver.server-xml.file}"
						dest="@{appserver.server-xml.file}">
						<attr path="/Server/Service[@name='@{appserver.server-xml.service.name}']/Connector[@port='@{proxy.update.connector.port}']" 
							attr="proxyPort" 
							value="@{appserver.external.port}"/>
						<attr path="/Server/Service[@name='@{appserver.server-xml.service.name}']/Connector[@port='@{proxy.update.connector.port}']" 
							attr="proxyName" 
							value="@{appserver.external.host}"/>
					</xmltask>
				</then>
				<else>
					<echo message="Grid External Host Name not set so doing nothing"/>
				</else>
			</if>
		</sequential>
	</macrodef>

	<macrodef name="tomcat-configure-server-xml-db">
		<attribute name="tomcat.home" default="${tomcat.home}"/>
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.name" default="${database.name}" />
		<attribute name="database.jndi.datasource.name" default="${database.jndi.datasource.name}" />
		<attribute name="database.context.path" default="${database.jndi.datasource.name}" />
		<sequential>
			<xmltask source="@{tomcat.home}/conf/server.xml" dest="@{tomcat.home}/conf/server.xml">
				<xmlcatalog refid="installer.catalog"/>
				<remove path="/Server/Service[@name='Catalina']/Engine[@name='Catalina']/Context[@path='/@{database.context.path}']"/>
				<insert path="/Server/Service[@name='Catalina']/Engine[@name='Catalina']">
					<![CDATA[
					<Context path="/@{database.context.path}" docBase="@{database.context.path}" reloadable="false">
						<Resource name="@{database.jndi.datasource.name}" auth="Container" type="javax.sql.DataSource"
							username="@{database.user}"
							password="@{database.password}"
							driverClassName="@{database.driver}"
							url="@{database.url}?autoReconnect=true"
							maxActive="20" />
					</Context>
					]]>
				</insert>
			</xmltask>
		</sequential>
	</macrodef>

	<macrodef name="tomcat-configure">
		<attribute name="tomcat.port.http" default ="${tomcat.port.http}"/>
		<attribute name="tomcat.port.ssl" default="${tomcat.port.ssl}"/>
		<attribute name="tomcat.port.ajp" default="${tomcat.port.ajp}"/>
		<attribute name="tomcat.port.shutdown" default="${tomcat.port.shutdown}"/>
		<attribute name="tomcat.home" default="${tomcat.home}"/>
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.name" default="${database.name}" />
		<attribute name="database.jndi.datasource.name" default="${database.jndi.datasource.name}" />
		<attribute name="database.context.path" default="${database.jndi.datasource.name}" />

		<!--appserver-ssl-configure -->
		<attribute name="tomcat.conf.dir" default="${tomcat.home}/conf"/>
		<attribute name="tomcat.server-xml.file" default="${tomcat.home}/conf/server.xml"/>
		<attribute name="tomcat.server-xml.service.name" default="Catalina"/>
		<attribute name="tomcat.ssl.enable" default="${tomcat.ssl.enable}"/>
		<attribute name="tomcat.ssl.port" default="${tomcat.port.ssl}"/>
		<attribute name="tomcat.ssl.keystore.file" default="${tomcat.ssl.keystore.file}"/>
		<attribute name="tomcat.ssl.keystore.dir" default="${tomcat.ssl.keystore.dir}"/>
		<attribute name="tomcat.ssl.keystore.pass" default="${tomcat.ssl.keystore.pass}"/>
		<attribute name="tomcat.ssl.keystore.alias" default="${tomcat.ssl.keystore.alias}"/>
		<attribute name="tomcat.ssl.fullyqualified.hostname" default="${tomcat.ssl.fullyqualified.hostname}"/>
		<!-- appserver-configure-external-hostname -->
		<attribute name="tomcat.external.ssl.host" default="${tomcat.external.ssl.host}"/>
		<attribute name="tomcat.external.ssl.port" default="${tomcat.external.ssl.port}"/>
		<attribute name="tomcat.external.http.host" default="${tomcat.external.http.host}"/>
		<attribute name="tomcat.external.http.port" default="${tomcat.external.http.port}"/>
		<attribute name="proxy.update.connector.port.ssl" default="8443"/>
		<attribute name="proxy.update.connector.port.http" default="8080"/>
		<attribute name="grid.external.secure.host" default="${grid.external.secure.host}"/>
		<attribute name="grid.external.secure.port" default="${grid.external.secure.port}"/>
		<!--appserver-configure-hostname -->
		<attribute name="tomcat.hostname" default="${tomcat.hostname}"/>
		<!--grid-secure-configure-connector-->
		<attribute name="tomcat.grid.configure" default="false"/>
		<attribute name="grid.secure.enable" default="${grid.secure.enable}"/>
		<attribute name="grid.secure.port" default="${grid.secure.port}"/>
		<attribute name="grid.secure.dir" default="${grid.secure.dir}"/>
		<attribute name="grid.secure.key.file" default="${grid.secure.key.file}" />
		<attribute name="grid.secure.cert.file" default="${grid.secure.cert.file}" />
		<sequential>
			<if>
				<not>
					<equals arg1="${exclude.tomcat-config}" arg2="true"/>
				</not>
				<then>
					<echo message="Configuring datasource for jboss"/>
					<tomcat-configure-server-xml-db
						tomcat.home="@{tomcat.home}"
						database.driver="@{database.driver}"
						database.url="@{database.url}"
						database.user="@{database.user}"
						database.password="@{database.password}"
						database.name="@{database.name}"
						database.jndi.datasource.name="@{database.jndi.datasource.name}"
						database.context.path="@{database.context.path}"
						/>
		
					<echo message="Securing tomcat app server"/>
					<appserver-ssl-configure
						appserver.conf.dir="@{tomcat.conf.dir}"
								appserver.server-xml.file="@{tomcat.server-xml.file}"
						appserver.server-xml.service.name="@{tomcat.server-xml.service.name}"
						appserver.ssl.enable="@{tomcat.ssl.enable}"
						appserver.ssl.port="@{tomcat.ssl.port}"
						appserver.ssl.keystore.file="@{tomcat.ssl.keystore.file}"
						appserver.ssl.keystore.dir="@{tomcat.ssl.keystore.dir}"
						appserver.ssl.keystore.pass="@{tomcat.ssl.keystore.pass}"
						appserver.ssl.keystore.alias="@{tomcat.ssl.keystore.alias}"
						appserver.ssl.fullyqualified.hostname="@{tomcat.ssl.fullyqualified.hostname}"
						/>
		
					<!-- needs to be done before changing ports -->
					<echo message="Configuring tomcat proxy settings for ssl"/>
					<appserver-configure-external-hostname
						appserver.server-xml.file="@{tomcat.server-xml.file}"
						appserver.server-xml.service.name="@{tomcat.server-xml.service.name}"
						appserver.external.host="@{tomcat.external.ssl.host}"
						appserver.external.port="@{tomcat.external.ssl.port}"
						proxy.update.connector.port="@{proxy.update.connector.port.ssl}"
						/>                                                                      
					<!-- needs to be done before changing ports -->
					<echo message="Configuring tomcat proxy settings for http"/>
					<appserver-configure-external-hostname
						appserver.server-xml.file="@{tomcat.server-xml.file}"
						appserver.server-xml.service.name="@{tomcat.server-xml.service.name}"
						appserver.external.host="@{tomcat.external.http.host}"
						appserver.external.port="@{tomcat.external.http.port}"
						proxy.update.connector.port="@{proxy.update.connector.port.http}"
						/>                                                                      
					<!-- needs to be done before changing ports -->
					<echo message="Configuring JBoss hostname in server.xml"/>
					<appserver-configure-hostname
						appserver.server-xml.file="@{tomcat.server-xml.file}"
						appserver.server-xml.service.name="@{tomcat.server-xml.service.name}"
						appserver.hostname="@{tomcat.hostname}"
						/>

					<echo message="Updating Tomcat Ports"/> 
<!--					
					<xmlconfig in="@{tomcat.home}/conf/server.xml" verbose="false">
						<update path="(//Connector)[@port=8080]/@port" value="@{tomcat.port.http}" />
						<update path="(//Connector)[@redirectPort=8443]/@redirectPort" value="@{tomcat.port.ssl}" />
						<update path="(//Connector)[@port=8009]/@port" value="@{tomcat.port.ajp}" />
						<update path="(//Connector)[@port=8443]/@port" value="@{tomcat.port.ssl}" />
						<update path="(//Server)[@port=8005]/@port" value="@{tomcat.port.shutdown}" />
					</xmlconfig>
-->
					<xmltask source="@{tomcat.home}/conf/server.xml" dest="@{tomcat.home}/conf/server.xml">
						<replace path="(//Connector)[@port=8080]/@port" withtext="@{tomcat.port.http}" />
						<replace path="(//Connector)[@redirectPort=8443]/@redirectPort" withtext="@{tomcat.port.ssl}" />
						<replace path="(//Connector)[@port=8009]/@port" withtext="@{tomcat.port.ajp}" />
						<replace path="(//Connector)[@port=8443]/@port" withtext="@{tomcat.port.ssl}" />
						<replace path="(//Server)[@port=8005]/@port" withtext="@{tomcat.port.shutdown}" />				
					</xmltask>
		
		
					<if>
						<equals arg1="@{tomcat.grid.configure}" arg2="true"/>
						<then>
							<echo message="Configuring secure grid in tomcat"/>
							<grid-secure-configure-connector
								appserver.conf.dir="@{tomcat.conf.dir}"
								appserver.server-xml.file="@{tomcat.server-xml.file}"
								appserver.server-xml.service.name="@{tomcat.server-xml.service.name}"
								grid.secure.enable="@{grid.secure.enable}"
								grid.secure.port="@{grid.secure.port}"
								grid.secure.dir="@{grid.secure.dir}"
								grid.secure.cert.file="@{grid.secure.cert.file}"
								grid.secure.key.file="@{grid.secure.key.file}"
								/>
							<!-- needs to be done after adding connector -->
							<if>
								<equals arg1="@{grid.secure.enable}" arg2="true"/>
								<then>
									<echo message="Configuring tomcat proxy settings for secure grid"/>
									<appserver-configure-external-hostname
										appserver.server-xml.file="@{tomcat.server-xml.file}"
												appserver.server-xml.service.name="@{tomcat.server-xml.service.name}"
										appserver.external.host="@{grid.external.secure.host}"
										appserver.external.port="@{grid.external.secure.port}"
										proxy.update.connector.port="@{grid.secure.port}"
										/>                                                                      
								</then>
								<else>
									<echo message="Skipping configuring tomcat proxy settings for secure grid since secure grid is not set."/>
								</else>
							</if>
						</then>
						<else>
							<echo message="Skipping configuration of GRID on Tomcat"/>
						</else>
					</if>

					<appserver-accesslog-configure
						appserver.conf.dir="@{tomcat.conf.dir}"
						appserver.server-xml.file="@{tomcat.server-xml.file}"
						appserver.server-xml.service.name="@{tomcat.server-xml.service.name}"
						appserver.hostname="@{tomcat.hostname}"
						/>
				</then>
				<else>
					<echo message="Skipping Tomcat Config because exclude.tomcat-config is set"/>
				</else>
			</if>
		</sequential>
	</macrodef>
	<macrodef name="jboss-configure">
		<!-- jboss-bindings -->
		<attribute name="jboss.home" default="${jboss.home}"/>
		<attribute name="jboss.server.name" default="${jboss.server.name}"/>
		<attribute name="jboss.server.ports.name" default="${jboss.port.configuration}"/>
		<attribute name="jboss.server.bindingfile.location" default="${jboss.home}/server/${jboss.server.name}/conf/bindings.xml"/>
		<attribute name="jboss.server.binding.template.location" default="${basedir}/${jboss-bindings.file}"/>
		<attribute name="jboss.server.service.template.location" default="${bda-utils.resource.dir}/template-jboss-service.xml"/>
		<!-- jboss-login-config -->
		<attribute name="authentication.type" default="${authentication.type}"/>
		<attribute name="login-config.ldap.file" default="${jboss-conf.dir.dest}/login-config.ldap-block.xml"/>
		<attribute name="login-config.db.file" default="${jboss-conf.dir.dest}/login-config.db-block.xml"/>
		<!-- secure-jboss-console -->
		<attribute name="jboss.web.user" default="${jboss.web.user}"/>
		<attribute name="jboss.web.password" default="${jboss.web.password}"/>
		<!-- jboss-update-shutdown -->
		<attribute name="jboss.server.jndi.port" default="${jboss.server.jndi.port}" />
		<!-- appserver-ssl-configure -->
		<attribute name="jboss.conf.dir" default="${jboss.home}/server/${jboss.server.name}/conf"/>
		<attribute name="jboss.server-xml.file" default="${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml"/>
		<attribute name="jboss.server-xml.service.name" default="jboss.web"/>
		<attribute name="jboss.ssl.enable" default="${jboss.ssl.enable}"/>
		<attribute name="jboss.ssl.port" default="8443"/>
		<attribute name="jboss.ssl.keystore.file" default="${jboss.ssl.keystore.file}"/>
		<attribute name="jboss.ssl.keystore.dir" default="${jboss.ssl.keystore.dir}"/>
		<attribute name="jboss.ssl.keystore.pass" default="${jboss.ssl.keystore.pass}"/>
		<attribute name="jboss.ssl.keystore.alias" default="${jboss.ssl.keystore.alias}"/>
		<attribute name="jboss.ssl.fullyqualified.hostname" default="${jboss.ssl.fullyqualified.hostname}"/>
		<!-- appserver-configure-external-hostname -->
		<attribute name="jboss.external.ssl.host" default="${jboss.external.ssl.host}"/>
		<attribute name="jboss.external.ssl.port" default="${jboss.external.ssl.port}"/>
		<attribute name="proxy.update.connector.port.ssl" default="8443"/>
		<attribute name="jboss.external.http.host" default="${jboss.external.http.host}"/>
		<attribute name="jboss.external.http.port" default="${jboss.external.http.port}"/>
		<attribute name="proxy.update.connector.port.http" default="8080"/>
		<attribute name="grid.external.secure.host" default="${grid.external.secure.host}"/>
		<attribute name="grid.external.secure.port" default="${grid.external.secure.port}"/>
		<!--appserver-configure-hostname -->
		<attribute name="jboss.server.hostname" default="${jboss.server.hostname}"/>
		<!-- grid-secure-configure-connector -->
		<attribute name="jboss.grid.configure" default="false"/>
		<attribute name="grid.secure.dir" default="${grid.secure.dir}"/>
		<attribute name="grid.secure.enable" default="${grid.secure.enable}"/>
		<attribute name="grid.secure.port" default="${grid.secure.port}"/>
		<attribute name="grid.secure.key.file" default="${grid.secure.key.file}" />
		<attribute name="grid.secure.cert.file" default="${grid.secure.cert.file}" />
		<!--jboss-configure-java_opts -->
		<attribute name="jboss.java.opts" default="${jboss.java.opts}"/>
		<sequential>
			<if>
				<not>
					<equals arg1="${exclude.jboss-config}" arg2="true"/>
				</not>
				<then>
					<if>
						<not>
							<equals arg1="${exclude.jboss-bindings}" arg2="true"/>
						</not>
						<then>
							<echo message="Configuring JBoss ports (bindings)"/>
							<jboss-bindings
								jboss.home="@{jboss.home}"
								jboss.server.name="@{jboss.server.name}"
								jboss.server.ports.name="@{jboss.server.ports.name}"
								jboss.server.bindingfile.location="@{jboss.server.bindingfile.location}"
								jboss.server.binding.template.location="@{jboss.server.binding.template.location}"
								jboss.server.service.template.location="@{jboss.server.service.template.location}"
								/>
						</then>
						<else>
							<echo message="Skipping configuring JBoss ports (bindings) because exclude.jboss-bindings is set"/>
						</else>
					</if>
		
					<if>
						<not>
							<equals arg1="${exclude.jboss-login-config}" arg2="true"/>
						</not>
						<then>
							<echo message="Configuring JBoss authentication settins (login-config.xml)"/>
							<jboss-login-config
								authentication.type="@{authentication.type}"
								jboss.home="@{jboss.home}"
								jboss.server.name="@{jboss.server.name}"
								login-config.ldap.file="@{login-config.ldap.file}"
								login-config.db.file="@{login-config.db.file}"
								/>
						</then>
						<else>
							<echo message="Skipping configuring JBoss login-config.xml because exclude.jboss-bindings is set"/>
						</else>
					</if>
		
					<echo message="Adding user and password to JBoss console apps"/>
					<secure-jboss-console
						jboss.home="@{jboss.home}"
						jboss.server.name="@{jboss.server.name}"
						jboss.web.user="@{jboss.web.user}"
						jboss.web.password="@{jboss.web.password}"
						/>
		
					<echo message="Updating JBoss shutdown.jar to allow shutdown without command line args"/>
					<jboss-update-shutdown
						jboss.home="@{jboss.home}"
						jboss.server.hostname="@{jboss.server.hostname}"
						jboss.server.jndi.port="@{jboss.server.jndi.port}"
						/>
		
					<echo message="Enableing SSL for JBoss"/>
					<appserver-ssl-configure
						appserver.conf.dir="@{jboss.conf.dir}"
						appserver.server-xml.file="@{jboss.server-xml.file}"
						appserver.server-xml.service.name="@{jboss.server-xml.service.name}"
						appserver.ssl.enable="@{jboss.ssl.enable}"
						appserver.ssl.port="@{jboss.ssl.port}"
						appserver.ssl.keystore.file="@{jboss.ssl.keystore.file}"
						appserver.ssl.keystore.dir="@{jboss.ssl.keystore.dir}"
						appserver.ssl.keystore.pass="@{jboss.ssl.keystore.pass}"
						appserver.ssl.keystore.alias="@{jboss.ssl.keystore.alias}"
						appserver.ssl.fullyqualified.hostname="@{jboss.ssl.fullyqualified.hostname}"
						/>
		
					<echo message="Configuring JBoss proxy settings for ssl"/>
					<appserver-configure-external-hostname
						appserver.server-xml.file="@{jboss.server-xml.file}"
						appserver.server-xml.service.name="@{jboss.server-xml.service.name}"
						appserver.external.host="@{jboss.external.ssl.host}"
						appserver.external.port="@{jboss.external.ssl.port}"
						proxy.update.connector.port="@{proxy.update.connector.port.ssl}"
						/>                                                                      
					<echo message="Configuring JBoss proxy settings for http"/>
					<appserver-configure-external-hostname
						appserver.server-xml.file="@{jboss.server-xml.file}"
						appserver.server-xml.service.name="@{jboss.server-xml.service.name}"
						appserver.external.host="@{jboss.external.http.host}"
						appserver.external.port="@{jboss.external.http.port}"
						proxy.update.connector.port="@{proxy.update.connector.port.http}"
						/>                                                                      
					<echo message="Configuring JBoss hostname in server.xml"/>
					<appserver-configure-hostname
						appserver.server-xml.file="@{jboss.server-xml.file}"
						appserver.server-xml.service.name="@{jboss.server-xml.service.name}"
						appserver.hostname="@{jboss.server.hostname}"
								/>
		
					<echo message="Configuring secure grid in JBoss"/>
					<if>
						<equals arg1="@{jboss.grid.configure}" arg2="true"/>
						<then>
							<echo message="Configuring grid on JBoss"/>
							<grid-secure-configure-connector
								appserver.conf.dir="@{jboss.conf.dir}"
								appserver.server-xml.file="@{jboss.server-xml.file}"
								appserver.server-xml.service.name="@{jboss.server-xml.service.name}"
								grid.secure.dir="@{grid.secure.dir}"
								grid.secure.enable="@{grid.secure.enable}"
								grid.secure.key.file="@{grid.secure.key.file}"
								grid.secure.cert.file="@{grid.secure.cert.file}"
								/>
							<!--
							<grid-secure-configure-valve
								appserver.server-xml.file="@{jboss.server-xml.file}"
								appserver.server-xml.service.name="@{jboss.server-xml.service.name}"
								/>
							-->
							<!-- needs to be done after adding connector -->
							<if>
								<equals arg1="@{grid.secure.enable}" arg2="true"/>
										<then>
									<echo message="Configuring jboss proxy settings for secure grid"/>
									<appserver-configure-external-hostname
										appserver.server-xml.file="@{jboss.server-xml.file}"
										appserver.server-xml.service.name="@{jboss.server-xml.service.name}"
										appserver.external.host="@{grid.external.secure.host}"
										appserver.external.port="@{grid.external.secure.port}"
										proxy.update.connector.port="@{grid.secure.port}"
										/>                                                                      
								</then>
								<else>
									<echo message="Skipping configuring jboss proxy settings for secure grid since secure grid is not set."/>
								</else>
							</if>
						</then>
						<else>
							<echo message="Skipping configuration of GRID on JBos"/>
						</else>
					</if>
					<appserver-accesslog-configure
						appserver.conf.dir="@{jboss.conf.dir}"
						appserver.server-xml.file="@{jboss.server-xml.file}"
						appserver.server-xml.service.name="@{jboss.server-xml.service.name}"
						appserver.hostname="@{jboss.server.hostname}"
						/>
				</then>
				<else>
					<echo message="Skipping jboss configuraiton because exclude.jboss-config is set"/>
				</else>
			</if>
		</sequential>
	</macrodef>
	<macrodef name="appserver-configure-hostname">
		<attribute name="appserver.server-xml.file" default="${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml"/>
		<attribute name="appserver.server-xml.service.name" default="jboss.web"/>
		<attribute name="appserver.hostname" default="${jboss.server.hostname}"/>
		<sequential>
			<echo message="Updateing hostname in server.xml"/>
			<xmltask source="@{appserver.server-xml.file}"
				dest="@{appserver.server-xml.file}">
				<attr path="//Engine[@name='@{appserver.server-xml.service.name}']" 
					attr="defaultHost"                    
					value="@{appserver.hostname}" />              
				<attr path="//Engine[@name='@{appserver.server-xml.service.name}']/Host"
					attr="name"                           
					value="@{appserver.hostname}" />              
			</xmltask>
		</sequential>
	</macrodef>
	<macrodef name="jboss-configure-java_opts">
		<attribute name="jboss.home" default="${jboss.home}" />
		<attribute name="jboss.java.opts" default="${jboss.java.opts}" />
		<sequential>
			<osfamily property="os.family"/>
			<echo message="os.family=${os.family}"/>
			<switch value="${os.family}">
				<case value="unix">
					<replaceregexp file="${jboss.home}/bin/run.conf" byline="true"
						match="^(\s+JAVA_OPTS)=(.*)"
						replace="\1='@{jboss.java.opts}'"
						/>
				</case>
				<case value="mac">
					<replaceregexp file="${jboss.home}/bin/run.conf" byline="true"
						match="^(\s+JAVA_OPTS)=(.*)"
						replace="\1='@{jboss.java.opts}'"
						/>
				</case>
				<case value="windows">
					<replaceregexp file="${jboss.home}/bin/run.bat" byline="true"
						match="^(set\s+JAVA_OPTS)=(.*)"
						replace="rem \1=\2"
						/>
					<replaceregexp file="${jboss.home}/bin/run.bat" byline="true"
						match="^(rem JVM memory.*)"
						replace="rem added by BDA installer${line.separator}set JAVA_OPTS=@{jboss.java.opts}${line.separator}\1"
						/>
				</case>
			</switch>
		</sequential>
	</macrodef>

	<macrodef name="database-upgrade-fix" description="Diagnose the host system before the installation">
		<attribute name="database.driver" default="${database.driver}" />
		<attribute name="database.url" default="${database.url}" />
		<attribute name="database.user" default="${database.user}" />
		<attribute name="database.password" default="${database.password}" />
		<attribute name="database.driver.file" default="${database.driver.file}" />
		<attribute name="database.changelog.file" default="${os.temp.dir}/${project.name}/db-upgrade.xml" />
		<sequential>
			<basename property="changelog.file" file="@{database.changelog.file}"/>
			<echo message="Updateing liquibase metadata file name to @{database.changelog.file}  where filename includes ${changelog.file}"/>
			<sql    
				driver="@{database.driver}"
				url="@{database.url}"
				userid="@{database.user}"
				password="@{database.password}"
				expandproperties="true"
				onerror="continue"
				autocommit="true"
				>
				<classpath>
					<pathelement location="${database.driver.file}" />
				</classpath>
				update databasechangelog set filename='@{database.changelog.file}' where filename like '%${changelog.file}';
			</sql>  
		</sequential>
	</macrodef>
	<macrodef name="appserver-accesslog-configure" description="macro for enabling ssl in jboss">
		<attribute name="appserver.conf.dir" default="${jboss.home}/server/${jboss.server.name}/conf"/>
		<attribute name="appserver.server-xml.file" default="${jboss.home}/server/${jboss.server.name}/deploy/jbossweb-tomcat55.sar/server.xml"/>
		<attribute name="appserver.server-xml.service.name" default="jboss.web"/>
		<attribute name="appserver.hostname" default="${jboss.server.hostname}"/>
		<sequential>
			<echo message="access log @{appserver.conf.dir} @{appserver.server-xml.file} @{appserver.server-xml.service.name} @{appserver.hostname}"/>
			<xmltask source="@{appserver.server-xml.file}"
				dest="@{appserver.server-xml.file}">
				<remove	path="/Server/Service[@name='@{appserver.server-xml.service.name}']/Engine[@name='@{appserver.server-xml.service.name}']/Host[@name='@{appserver.hostname}']/Valve[@className='org.apache.catalina.valves.AccessLogValve']"/>
			</xmltask>
			<xmltask source="@{appserver.server-xml.file}"
				dest="@{appserver.server-xml.file}"
				failWithoutMatch="true">
				<insert path="/Server/Service[@name='@{appserver.server-xml.service.name}']/Engine[@name='@{appserver.server-xml.service.name}']/Host[@name='@{appserver.hostname}']">
					<![CDATA[
					<Valve className="org.apache.catalina.valves.AccessLogValve"
						directory="logs"
						prefix="localhost_access_log."
						suffix=".txt"
						pattern="common"
						resolveHosts="false"/>
					]]>
				</insert>
			</xmltask>
			<!-- when using proxies can pattern can be changed pattern="%{x-forwarded-for}i %l %u %t %r %s %b" -->
		</sequential>
	</macrodef>

	<macrodef name="validate-appserver-versions">
		<attribute name="jboss.binaries.relative.dir" default="${jboss.binaries.relative.dir}"/>
		<attribute name="tomcat.binaries.relative.dir" default="${tomcat.binaries.relative.dir}"/>
		<sequential>
			<var name="jboss.version.check" unset="true"/>
			<propertyregex property="jboss.version.check"
				input="@{jboss.binaries.relative.dir}"
				regexp="(\d+\.\d+\.\d+).*"
				select="\1"
				/>
			<var name="tomcat.version.check" unset="true"/>
			<propertyregex property="tomcat.version.check"
				input="@{tomcat.binaries.relative.dir}"
				regexp="(\d+\.\d+\.\d+).*"
				select="\1"
				/>                      
			<echo message="checking jboss version - ${jboss.version.check}."/>
			<if>
				<isset property="jboss.version.check"/>
				<then>
					<compare-version-major-min-patch
						version.check="${jboss.version.check}"
						version.min="${jboss.version.min}"
						version.max="${jboss.version.max}"
						/>
				</then>
			</if>
			<echo message="checking tomcat version - ${tomcat.version.check}."/>
			<if>
				<isset property="tomcat.version.check"/>
				<then>
					<compare-version-major-min-patch
						version.check="${tomcat.version.check}"
						version.min="${tomcat.version.min}"
						version.max="${tomcat.version.max}"
						/>
				</then>
			</if>


		</sequential>
	</macrodef>
	<macrodef name="compare-version-major-min-patch">
		<attribute name="version.check"/>
		<attribute name="version.min"/>
		<attribute name="version.max"/>
		<sequential>
			<groovy>
				<arg line="@{version.check} @{version.min} @{version.max}"/>

				import java.util.regex.Matcher
				import java.util.regex.Pattern

				versionCheck = args[0]
				versionMin = args[1]
				versionMax = args[2]
				BigInteger checkCalcVersion
				BigInteger minCalcVersion
				BigInteger maxCalcVersion

				try {
				checkMatcher =  java.util.regex.Pattern.compile(/(\d+)\.(\d+)\.(\d+)/).matcher(versionCheck)
				checkMatches = checkMatcher.matches()
				Integer checkMajor = checkMatcher.group(1).toInteger()
				Integer checkMinor = checkMatcher.group(2).toInteger()
				Integer checkPatch = checkMatcher.group(3).toInteger()

				checkCalcVersion= ((checkMajor*1000000)+(checkMinor*1000)+checkPatch)
				println "Check version is ${checkCalcVersion}"
				} catch (Throwable ex) {
				println "Check version is not in the format major.minor.patch (up to 3 digits each)."
				System.exit(3)
				}

				try {
				minMatcher =  java.util.regex.Pattern.compile(/(\d+)\.(\d+)\.(\d+)/).matcher(versionMin)
				minMatches = minMatcher.matches()
				Integer minMajor = minMatcher.group(1).toInteger()
				Integer minMinor = minMatcher.group(2).toInteger()
				Integer minPatch = minMatcher.group(3).toInteger()

				minCalcVersion= ((minMajor*1000000)+(minMinor*1000)+minPatch)
				println "Min version is ${minCalcVersion}"
				} catch (Throwable ex) {
				println "Minimum version is not in the format major.minor.patch (up to 3 digits each)."
				System.exit(3)
				}

				try {
				maxMatcher =  java.util.regex.Pattern.compile(/(\d+)\.(\d+)\.(\d+)/).matcher(versionMax)
				maxMatches = maxMatcher.matches()
				Integer maxMajor = maxMatcher.group(1).toInteger()
				Integer maxMinor = maxMatcher.group(2).toInteger()
				Integer maxPatch = maxMatcher.group(3).toInteger()

				maxCalcVersion= ((maxMajor*1000000)+(maxMinor*1000)+maxPatch)
				println "Max version is ${maxCalcVersion}"
				} catch (Throwable ex) {
				println "Maximum version is not in the format major.minor.patch (up to 3 digits each)."
				System.exit(3)
				}

				if ( checkCalcVersion &lt; minCalcVersion)
				{
				println "The check version ${checkCalcVersion} is less than the minium supported version ${minCalcVersion}."
				System.exit(2)
				}

				if ( checkCalcVersion &gt; maxCalcVersion)
				{
				println "The check version ${checkCalcVersion} is greater than the maximum supported version ${maxCalcVersion}."
				System.exit(2)
				}


			</groovy>
		</sequential>
	</macrodef>
</project>
